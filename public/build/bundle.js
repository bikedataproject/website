
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_options(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            option.selected = ~value.indexOf(option.__value);
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /*
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     */

    const isUndefined = value => typeof value === "undefined";

    const isFunction = value => typeof value === "function";

    const isNumber = value => typeof value === "number";

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
    	return (
    		!event.defaultPrevented &&
    		event.button === 0 &&
    		!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    	);
    }

    function createCounter() {
    	let i = 0;
    	/**
    	 * Returns an id and increments the internal state
    	 * @returns {number}
    	 */
    	return () => i++;
    }

    /**
     * Create a globally unique id
     *
     * @returns {string} An id
     */
    function createGlobalId() {
    	return Math.random().toString(36).substring(2);
    }

    const isSSR = typeof window === "undefined";

    function addListener(target, type, handler) {
    	target.addEventListener(type, handler);
    	return () => target.removeEventListener(type, handler);
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    /*
     * Adapted from https://github.com/EmilTholin/svelte-routing
     *
     * https://github.com/EmilTholin/svelte-routing/blob/master/LICENSE
     */

    const createKey = ctxName => `@@svnav-ctx__${ctxName}`;

    // Use strings instead of objects, so different versions of
    // svelte-navigator can potentially still work together
    const LOCATION = createKey("LOCATION");
    const ROUTER = createKey("ROUTER");
    const ROUTE = createKey("ROUTE");
    const ROUTE_PARAMS = createKey("ROUTE_PARAMS");
    const FOCUS_ELEM = createKey("FOCUS_ELEM");

    const paramRegex = /^:(.+)/;

    /**
     * Check if `string` starts with `search`
     * @param {string} string
     * @param {string} search
     * @return {boolean}
     */
    const startsWith$1 = (string, search) =>
    	string.substr(0, search.length) === search;

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    const isRootSegment = segment => segment === "";

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    const isDynamic = segment => paramRegex.test(segment);

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    const isSplat = segment => segment[0] === "*";

    /**
     * Strip potention splat and splatname of the end of a path
     * @param {string} str
     * @return {string}
     */
    const stripSplat = str => str.replace(/\*.*$/, "");

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    const stripSlashes = str => str.replace(/(^\/+|\/+$)/g, "");

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri, filterFalsy = false) {
    	const segments = stripSlashes(uri).split("/");
    	return filterFalsy ? segments.filter(Boolean) : segments;
    }

    /**
     * Add the query to the pathname if a query is given
     * @param {string} pathname
     * @param {string} [query]
     * @return {string}
     */
    const addQuery = (pathname, query) =>
    	pathname + (query ? `?${query}` : "");

    /**
     * Normalizes a basepath
     *
     * @param {string} path
     * @returns {string}
     *
     * @example
     * normalizePath("base/path/") // -> "/base/path"
     */
    const normalizePath = path => `/${stripSlashes(path)}`;

    /**
     * Joins and normalizes multiple path fragments
     *
     * @param {...string} pathFragments
     * @returns {string}
     */
    function join(...pathFragments) {
    	const joinFragment = fragment => segmentize(fragment, true).join("/");
    	const joinedSegments = pathFragments.map(joinFragment).join("/");
    	return normalizePath(joinedSegments);
    }

    // We start from 1 here, so we can check if an origin id has been passed
    // by using `originId || <fallback>`
    const LINK_ID = 1;
    const ROUTE_ID = 2;
    const ROUTER_ID = 3;
    const USE_FOCUS_ID = 4;
    const USE_LOCATION_ID = 5;
    const USE_MATCH_ID = 6;
    const USE_NAVIGATE_ID = 7;
    const USE_PARAMS_ID = 8;
    const USE_RESOLVABLE_ID = 9;
    const USE_RESOLVE_ID = 10;
    const NAVIGATE_ID = 11;

    const labels = {
    	[LINK_ID]: "Link",
    	[ROUTE_ID]: "Route",
    	[ROUTER_ID]: "Router",
    	[USE_FOCUS_ID]: "useFocus",
    	[USE_LOCATION_ID]: "useLocation",
    	[USE_MATCH_ID]: "useMatch",
    	[USE_NAVIGATE_ID]: "useNavigate",
    	[USE_PARAMS_ID]: "useParams",
    	[USE_RESOLVABLE_ID]: "useResolvable",
    	[USE_RESOLVE_ID]: "useResolve",
    	[NAVIGATE_ID]: "navigate",
    };

    const createLabel = labelId => labels[labelId];

    function createIdentifier(labelId, props) {
    	let attr;
    	if (labelId === ROUTE_ID) {
    		attr = props.path ? `path="${props.path}"` : "default";
    	} else if (labelId === LINK_ID) {
    		attr = `to="${props.to}"`;
    	} else if (labelId === ROUTER_ID) {
    		attr = `basepath="${props.basepath || ""}"`;
    	}
    	return `<${createLabel(labelId)} ${attr || ""} />`;
    }

    function createMessage(labelId, message, props, originId) {
    	const origin = props && createIdentifier(originId || labelId, props);
    	const originMsg = origin ? `\n\nOccurred in: ${origin}` : "";
    	const label = createLabel(labelId);
    	const msg = isFunction(message) ? message(label) : message;
    	return `<${label}> ${msg}${originMsg}`;
    }

    const createMessageHandler = handler => (...args) =>
    	handler(createMessage(...args));

    const fail = createMessageHandler(message => {
    	throw new Error(message);
    });

    // eslint-disable-next-line no-console
    const warn = createMessageHandler(console.warn);

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
    	const score = route.default
    		? 0
    		: segmentize(route.fullPath).reduce((acc, segment) => {
    				let nextScore = acc;
    				nextScore += SEGMENT_POINTS;

    				if (isRootSegment(segment)) {
    					nextScore += ROOT_POINTS;
    				} else if (isDynamic(segment)) {
    					nextScore += DYNAMIC_POINTS;
    				} else if (isSplat(segment)) {
    					nextScore -= SEGMENT_POINTS + SPLAT_PENALTY;
    				} else {
    					nextScore += STATIC_POINTS;
    				}

    				return nextScore;
    		  }, 0);

    	return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
    	return (
    		routes
    			.map(rankRoute)
    			// If two routes have the exact same score, we go by index instead
    			.sort((a, b) => {
    				if (a.score < b.score) {
    					return 1;
    				}
    				if (a.score > b.score) {
    					return -1;
    				}
    				return a.index - b.index;
    			})
    	);
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { fullPath, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick(routes, uri) {
    	let bestMatch;
    	let defaultMatch;

    	const [uriPathname] = uri.split("?");
    	const uriSegments = segmentize(uriPathname);
    	const isRootUri = uriSegments[0] === "";
    	const ranked = rankRoutes(routes);

    	for (let i = 0, l = ranked.length; i < l; i++) {
    		const { route } = ranked[i];
    		let missed = false;
    		const params = {};

    		// eslint-disable-next-line no-shadow
    		const createMatch = uri => ({ ...route, params, uri });

    		if (route.default) {
    			defaultMatch = createMatch(uri);
    			continue;
    		}

    		const routeSegments = segmentize(route.fullPath);
    		const max = Math.max(uriSegments.length, routeSegments.length);
    		let index = 0;

    		for (; index < max; index++) {
    			const routeSegment = routeSegments[index];
    			const uriSegment = uriSegments[index];

    			if (!isUndefined(routeSegment) && isSplat(routeSegment)) {
    				// Hit a splat, just grab the rest, and return a match
    				// uri:   /files/documents/work
    				// route: /files/* or /files/*splatname
    				const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

    				params[splatName] = uriSegments
    					.slice(index)
    					.map(decodeURIComponent)
    					.join("/");
    				break;
    			}

    			if (isUndefined(uriSegment)) {
    				// URI is shorter than the route, no match
    				// uri:   /users
    				// route: /users/:userId
    				missed = true;
    				break;
    			}

    			const dynamicMatch = paramRegex.exec(routeSegment);

    			if (dynamicMatch && !isRootUri) {
    				const value = decodeURIComponent(uriSegment);
    				params[dynamicMatch[1]] = value;
    			} else if (routeSegment !== uriSegment) {
    				// Current segments don't match, not dynamic, not splat, so no match
    				// uri:   /users/123/settings
    				// route: /users/:id/profile
    				missed = true;
    				break;
    			}
    		}

    		if (!missed) {
    			bestMatch = createMatch(join(...uriSegments.slice(0, index)));
    			break;
    		}
    	}

    	return bestMatch || defaultMatch || null;
    }

    /**
     * Check if the `route.fullPath` matches the `uri`.
     * @param {Object} route
     * @param {string} uri
     * @return {?object}
     */
    function match(route, uri) {
    	return pick([route], uri);
    }

    /**
     * Resolve URIs as though every path is a directory, no files. Relative URIs
     * in the browser can feel awkward because not only can you be "in a directory",
     * you can be "at a file", too. For example:
     *
     *  browserSpecResolve('foo', '/bar/') => /bar/foo
     *  browserSpecResolve('foo', '/bar') => /foo
     *
     * But on the command line of a file system, it's not as complicated. You can't
     * `cd` from a file, only directories. This way, links have to know less about
     * their current path. To go deeper you can do this:
     *
     *  <Link to="deeper"/>
     *  // instead of
     *  <Link to=`{${props.uri}/deeper}`/>
     *
     * Just like `cd`, if you want to go deeper from the command line, you do this:
     *
     *  cd deeper
     *  # not
     *  cd $(pwd)/deeper
     *
     * By treating every path as a directory, linking to relative paths should
     * require less contextual information and (fingers crossed) be more intuitive.
     * @param {string} to
     * @param {string} base
     * @return {string}
     */
    function resolve(to, base) {
    	// /foo/bar, /baz/qux => /foo/bar
    	if (startsWith$1(to, "/")) {
    		return to;
    	}

    	const [toPathname, toQuery] = to.split("?");
    	const [basePathname] = base.split("?");
    	const toSegments = segmentize(toPathname);
    	const baseSegments = segmentize(basePathname);

    	// ?a=b, /users?b=c => /users?a=b
    	if (toSegments[0] === "") {
    		return addQuery(basePathname, toQuery);
    	}

    	// profile, /users/789 => /users/789/profile
    	if (!startsWith$1(toSegments[0], ".")) {
    		const pathname = baseSegments.concat(toSegments).join("/");
    		return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
    	}

    	// ./       , /users/123 => /users/123
    	// ../      , /users/123 => /users
    	// ../..    , /users/123 => /
    	// ../../one, /a/b/c/d   => /a/b/one
    	// .././one , /a/b/c/d   => /a/b/c/one
    	const allSegments = baseSegments.concat(toSegments);
    	const segments = [];

    	allSegments.forEach(segment => {
    		if (segment === "..") {
    			segments.pop();
    		} else if (segment !== ".") {
    			segments.push(segment);
    		}
    	});

    	return addQuery(`/${segments.join("/")}`, toQuery);
    }

    /**
     * Normalizes a location for consumption by `Route` children and the `Router`.
     * It removes the apps basepath from the pathname
     * and sets default values for `search` and `hash` properties.
     *
     * @param {Object} location The current global location supplied by the history component
     * @param {string} basepath The applications basepath (i.e. when serving from a subdirectory)
     *
     * @returns The normalized location
     */
    function normalizeLocation(location, basepath) {
    	const { pathname, hash = "", search = "", state } = location;
    	const baseSegments = segmentize(basepath, true);
    	const pathSegments = segmentize(pathname, true);
    	while (baseSegments.length) {
    		if (baseSegments[0] !== pathSegments[0]) {
    			fail(
    				ROUTER_ID,
    				`Invalid state: All locations must begin with the basepath "${basepath}", found "${pathname}"`,
    			);
    		}
    		baseSegments.shift();
    		pathSegments.shift();
    	}
    	return {
    		pathname: join(...pathSegments),
    		hash,
    		search,
    		state,
    	};
    }

    const normalizeUrlFragment = frag => (frag.length === 1 ? "" : frag);

    /**
     * Creates a location object from an url.
     * It is used to create a location from the url prop used in SSR
     *
     * @param {string} url The url string (e.g. "/path/to/somewhere")
     *
     * @returns {{ pathname: string; search: string; hash: string }} The location
     */
    function createLocation$1(url) {
    	const searchIndex = url.indexOf("?");
    	const hashIndex = url.indexOf("#");
    	const hasSearchIndex = searchIndex !== -1;
    	const hasHashIndex = hashIndex !== -1;
    	const hash = hasHashIndex ? normalizeUrlFragment(url.substr(hashIndex)) : "";
    	const pathnameAndSearch = hasHashIndex ? url.substr(0, hashIndex) : url;
    	const search = hasSearchIndex
    		? normalizeUrlFragment(pathnameAndSearch.substr(searchIndex))
    		: "";
    	const pathname = hasSearchIndex
    		? pathnameAndSearch.substr(0, searchIndex)
    		: pathnameAndSearch;
    	return { pathname, search, hash };
    }

    /**
     * Resolves a link relative to the parent Route and the Routers basepath.
     *
     * @param {string} path The given path, that will be resolved
     * @param {string} routeBase The current Routes base path
     * @param {string} appBase The basepath of the app. Used, when serving from a subdirectory
     * @returns {string} The resolved path
     *
     * @example
     * resolveLink("relative", "/routeBase", "/") // -> "/routeBase/relative"
     * resolveLink("/absolute", "/routeBase", "/") // -> "/absolute"
     * resolveLink("relative", "/routeBase", "/base") // -> "/base/routeBase/relative"
     * resolveLink("/absolute", "/routeBase", "/base") // -> "/base/absolute"
     */
    function resolveLink(path, routeBase, appBase) {
    	return join(appBase, resolve(path, routeBase));
    }

    /**
     * Get the uri for a Route, by matching it against the current location.
     *
     * @param {string} routePath The Routes resolved path
     * @param {string} pathname The current locations pathname
     */
    function extractBaseUri(routePath, pathname) {
    	const fullPath = normalizePath(stripSplat(routePath));
    	const baseSegments = segmentize(fullPath, true);
    	const pathSegments = segmentize(pathname, true).slice(0, baseSegments.length);
    	const routeMatch = match({ fullPath }, join(...pathSegments));
    	return routeMatch && routeMatch.uri;
    }

    /*
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     */

    const POP = "POP";
    const PUSH = "PUSH";
    const REPLACE = "REPLACE";

    function getLocation(source) {
    	return {
    		...source.location,
    		pathname: encodeURI(decodeURI(source.location.pathname)),
    		state: source.history.state,
    		_key: (source.history.state && source.history.state._key) || "initial",
    	};
    }

    function createHistory(source) {
    	let listeners = [];
    	let location = getLocation(source);
    	let action = POP;

    	const notifyListeners = (listenerFns = listeners) =>
    		listenerFns.forEach(listener => listener({ location, action }));

    	return {
    		get location() {
    			return location;
    		},
    		listen(listener) {
    			listeners.push(listener);

    			const popstateListener = () => {
    				location = getLocation(source);
    				action = POP;
    				notifyListeners([listener]);
    			};

    			// Call listener when it is registered
    			notifyListeners([listener]);

    			const unlisten = addListener(source, "popstate", popstateListener);
    			return () => {
    				unlisten();
    				listeners = listeners.filter(fn => fn !== listener);
    			};
    		},
    		/**
    		 * Navigate to a new absolute route.
    		 *
    		 * @param {string|number} to The path to navigate to.
    		 *
    		 * If `to` is a number we will navigate to the stack entry index + `to`
    		 * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
    		 * @param {Object} options
    		 * @param {*} [options.state] The state will be accessible through `location.state`
    		 * @param {boolean} [options.replace=false] Replace the current entry in the history
    		 * stack, instead of pushing on a new one
    		 */
    		navigate(to, options) {
    			const { state = {}, replace = false } = options || {};
    			action = replace ? REPLACE : PUSH;
    			if (isNumber(to)) {
    				if (options) {
    					warn(
    						NAVIGATE_ID,
    						"Navigation options (state or replace) are not supported, " +
    							"when passing a number as the first argument to navigate. " +
    							"They are ignored.",
    					);
    				}
    				action = POP;
    				source.history.go(to);
    			} else {
    				const keyedState = { ...state, _key: createGlobalId() };
    				// try...catch iOS Safari limits to 100 pushState calls
    				try {
    					source.history[replace ? "replaceState" : "pushState"](
    						keyedState,
    						"",
    						to,
    					);
    				} catch (e) {
    					source.location[replace ? "replace" : "assign"](to);
    				}
    			}

    			location = getLocation(source);
    			notifyListeners();
    		},
    	};
    }

    function createStackFrame(state, uri) {
    	return { ...createLocation$1(uri), state };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
    	let index = 0;
    	let stack = [createStackFrame(null, initialPathname)];

    	return {
    		// This is just for testing...
    		get entries() {
    			return stack;
    		},
    		get location() {
    			return stack[index];
    		},
    		addEventListener() {},
    		removeEventListener() {},
    		history: {
    			get state() {
    				return stack[index].state;
    			},
    			pushState(state, title, uri) {
    				index++;
    				// Throw away anything in the stack with an index greater than the current index.
    				// This happens, when we go back using `go(-n)`. The index is now less than `stack.length`.
    				// If we call `go(+n)` the stack entries with an index greater than the current index can
    				// be reused.
    				// However, if we navigate to a path, instead of a number, we want to create a new branch
    				// of navigation.
    				stack = stack.slice(0, index);
    				stack.push(createStackFrame(state, uri));
    			},
    			replaceState(state, title, uri) {
    				stack[index] = createStackFrame(state, uri);
    			},
    			go(to) {
    				const newIndex = index + to;
    				if (newIndex < 0 || newIndex > stack.length - 1) {
    					return;
    				}
    				index = newIndex;
    			},
    		},
    	};
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = !!(
    	!isSSR &&
    	window.document &&
    	window.document.createElement
    );
    // Use memory history in iframes (for example in Svelte REPL)
    const isEmbeddedPage = !isSSR && window.location.origin === "null";
    const globalHistory = createHistory(
    	canUseDOM && !isEmbeddedPage ? window : createMemorySource(),
    );

    // We need to keep the focus candidate in a separate file, so svelte does
    // not update, when we mutate it.
    // Also, we need a single global reference, because taking focus needs to
    // work globally, even if we have multiple top level routers
    // eslint-disable-next-line import/no-mutable-exports
    let focusCandidate = null;

    // eslint-disable-next-line import/no-mutable-exports
    let initialNavigation = true;

    /**
     * Check if RouterA is above RouterB in the document
     * @param {number} routerIdA The first Routers id
     * @param {number} routerIdB The second Routers id
     */
    function isAbove(routerIdA, routerIdB) {
    	const routerMarkers = document.querySelectorAll("[data-svnav-router]");
    	for (let i = 0; i < routerMarkers.length; i++) {
    		const node = routerMarkers[i];
    		const currentId = Number(node.dataset.svnavRouter);
    		if (currentId === routerIdA) return true;
    		if (currentId === routerIdB) return false;
    	}
    	return false;
    }

    /**
     * Check if a Route candidate is the best choice to move focus to,
     * and store the best match.
     * @param {{
         level: number;
         routerId: number;
         route: {
           id: number;
           focusElement: import("svelte/store").Readable<Promise<Element>|null>;
         }
       }} item A Route candidate, that updated and is visible after a navigation
     */
    function pushFocusCandidate(item) {
    	if (
    		// Best candidate if it's the only candidate...
    		!focusCandidate ||
    		// Route is nested deeper, than previous candidate
    		// -> Route change was triggered in the deepest affected
    		// Route, so that's were focus should move to
    		item.level > focusCandidate.level ||
    		// If the level is identical, we want to focus the first Route in the document,
    		// so we pick the first Router lookin from page top to page bottom.
    		(item.level === focusCandidate.level &&
    			isAbove(item.routerId, focusCandidate.routerId))
    	) {
    		focusCandidate = item;
    	}
    }

    /**
     * Reset the focus candidate.
     */
    function clearFocusCandidate() {
    	focusCandidate = null;
    }

    function initialNavigationOccurred() {
    	initialNavigation = false;
    }

    /*
     * `focus` Adapted from https://github.com/oaf-project/oaf-side-effects/blob/master/src/index.ts
     *
     * https://github.com/oaf-project/oaf-side-effects/blob/master/LICENSE
     */
    function focus(elem) {
    	if (!elem) return false;
    	const TABINDEX = "tabindex";
    	try {
    		if (!elem.hasAttribute(TABINDEX)) {
    			elem.setAttribute(TABINDEX, "-1");
    			let unlisten;
    			// We remove tabindex after blur to avoid weird browser behavior
    			// where a mouse click can activate elements with tabindex="-1".
    			const blurListener = () => {
    				elem.removeAttribute(TABINDEX);
    				unlisten();
    			};
    			unlisten = addListener(elem, "blur", blurListener);
    		}
    		elem.focus();
    		return document.activeElement === elem;
    	} catch (e) {
    		// Apparently trying to focus a disabled element in IE can throw.
    		// See https://stackoverflow.com/a/1600194/2476884
    		return false;
    	}
    }

    function isEndMarker(elem, id) {
    	return Number(elem.dataset.svnavRouteEnd) === id;
    }

    function isHeading(elem) {
    	return /^H[1-6]$/i.test(elem.tagName);
    }

    function query(selector, parent = document) {
    	return parent.querySelector(selector);
    }

    function queryHeading(id) {
    	const marker = query(`[data-svnav-route-start="${id}"]`);
    	let current = marker.nextElementSibling;
    	while (!isEndMarker(current, id)) {
    		if (isHeading(current)) {
    			return current;
    		}
    		const heading = query("h1,h2,h3,h4,h5,h6", current);
    		if (heading) {
    			return heading;
    		}
    		current = current.nextElementSibling;
    	}
    	return null;
    }

    function handleFocus(route) {
    	Promise.resolve(get_store_value(route.focusElement)).then(elem => {
    		const focusElement = elem || queryHeading(route.id);
    		if (!focusElement) {
    			warn(
    				ROUTER_ID,
    				"Could not find an element to focus. " +
    					"You should always render a header for accessibility reasons, " +
    					'or set a custom focus element via the "useFocus" hook. ' +
    					"If you don't want this Route or Router to manage focus, " +
    					'pass "primary={false}" to it.',
    				route,
    				ROUTE_ID,
    			);
    		}
    		const headingFocused = focus(focusElement);
    		if (headingFocused) return;
    		focus(document.documentElement);
    	});
    }

    const createTriggerFocus = (a11yConfig, announcementText, location) => (
    	manageFocus,
    	announceNavigation,
    ) =>
    	// Wait until the dom is updated, so we can look for headings
    	tick().then(() => {
    		if (!focusCandidate || initialNavigation) {
    			initialNavigationOccurred();
    			return;
    		}
    		if (manageFocus) {
    			handleFocus(focusCandidate.route);
    		}
    		if (a11yConfig.announcements && announceNavigation) {
    			const { path, fullPath, meta, params, uri } = focusCandidate.route;
    			const announcementMessage = a11yConfig.createAnnouncement(
    				{ path, fullPath, meta, params, uri },
    				get_store_value(location),
    			);
    			Promise.resolve(announcementMessage).then(message => {
    				announcementText.set(message);
    			});
    		}
    		clearFocusCandidate();
    	});

    const visuallyHiddenStyle =
    	"position:fixed;" +
    	"top:-1px;" +
    	"left:0;" +
    	"width:1px;" +
    	"height:1px;" +
    	"padding:0;" +
    	"overflow:hidden;" +
    	"clip:rect(0,0,0,0);" +
    	"white-space:nowrap;" +
    	"border:0;";

    /* node_modules/svelte-navigator/src/Router.svelte generated by Svelte v3.44.0 */

    const file$z = "node_modules/svelte-navigator/src/Router.svelte";

    // (195:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}
    function create_if_block$a(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*$announcementText*/ ctx[0]);
    			attr_dev(div, "role", "status");
    			attr_dev(div, "aria-atomic", "true");
    			attr_dev(div, "aria-live", "polite");
    			attr_dev(div, "style", visuallyHiddenStyle);
    			add_location(div, file$z, 195, 1, 5906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$announcementText*/ 1) set_data_dev(t, /*$announcementText*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(195:0) {#if isTopLevelRouter && manageFocus && a11yConfig.announcements}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let if_block_anchor;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[20].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
    	let if_block = /*isTopLevelRouter*/ ctx[2] && /*manageFocus*/ ctx[4] && /*a11yConfig*/ ctx[1].announcements && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			set_style(div, "display", "none");
    			attr_dev(div, "aria-hidden", "true");
    			attr_dev(div, "data-svnav-router", /*routerId*/ ctx[3]);
    			add_location(div, file$z, 190, 0, 5750);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 524288)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[19],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*isTopLevelRouter*/ ctx[2] && /*manageFocus*/ ctx[4] && /*a11yConfig*/ ctx[1].announcements) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const createId$1 = createCounter();
    const defaultBasepath = "/";

    function instance$B($$self, $$props, $$invalidate) {
    	let $location;
    	let $activeRoute;
    	let $prevLocation;
    	let $routes;
    	let $announcementText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, ['default']);
    	let { basepath = defaultBasepath } = $$props;
    	let { url = null } = $$props;
    	let { history = globalHistory } = $$props;
    	let { primary = true } = $$props;
    	let { a11y = {} } = $$props;

    	const a11yConfig = {
    		createAnnouncement: route => `Navigated to ${route.uri}`,
    		announcements: true,
    		...a11y
    	};

    	// Remember the initial `basepath`, so we can fire a warning
    	// when the user changes it later
    	const initialBasepath = basepath;

    	const normalizedBasepath = normalizePath(basepath);
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const isTopLevelRouter = !locationContext;
    	const routerId = createId$1();
    	const manageFocus = primary && !(routerContext && !routerContext.manageFocus);
    	const announcementText = writable("");
    	validate_store(announcementText, 'announcementText');
    	component_subscribe($$self, announcementText, value => $$invalidate(0, $announcementText = value));
    	const routes = writable([]);
    	validate_store(routes, 'routes');
    	component_subscribe($$self, routes, value => $$invalidate(18, $routes = value));
    	const activeRoute = writable(null);
    	validate_store(activeRoute, 'activeRoute');
    	component_subscribe($$self, activeRoute, value => $$invalidate(16, $activeRoute = value));

    	// Used in SSR to synchronously set that a Route is active.
    	let hasActiveRoute = false;

    	// Nesting level of router.
    	// We will need this to identify sibling routers, when moving
    	// focus on navigation, so we can focus the first possible router
    	const level = isTopLevelRouter ? 0 : routerContext.level + 1;

    	// If we're running an SSR we force the location to the `url` prop
    	const getInitialLocation = () => normalizeLocation(isSSR ? createLocation$1(url) : history.location, normalizedBasepath);

    	const location = isTopLevelRouter
    	? writable(getInitialLocation())
    	: locationContext;

    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(15, $location = value));
    	const prevLocation = writable($location);
    	validate_store(prevLocation, 'prevLocation');
    	component_subscribe($$self, prevLocation, value => $$invalidate(17, $prevLocation = value));
    	const triggerFocus = createTriggerFocus(a11yConfig, announcementText, location);
    	const createRouteFilter = routeId => routeList => routeList.filter(routeItem => routeItem.id !== routeId);

    	function registerRoute(route) {
    		if (isSSR) {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match(route, $location.pathname);

    			if (matchingRoute) {
    				hasActiveRoute = true;

    				// Return the match in SSR mode, so the matched Route can use it immediatly.
    				// Waiting for activeRoute to update does not work, because it updates
    				// after the Route is initialized
    				return matchingRoute; // eslint-disable-line consistent-return
    			}
    		} else {
    			routes.update(prevRoutes => {
    				// Remove an old version of the updated route,
    				// before pushing the new version
    				const nextRoutes = createRouteFilter(route.id)(prevRoutes);

    				nextRoutes.push(route);
    				return nextRoutes;
    			});
    		}
    	}

    	function unregisterRoute(routeId) {
    		routes.update(createRouteFilter(routeId));
    	}

    	if (!isTopLevelRouter && basepath !== defaultBasepath) {
    		warn(ROUTER_ID, 'Only top-level Routers can have a "basepath" prop. It is ignored.', { basepath });
    	}

    	if (isTopLevelRouter) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = history.listen(changedHistory => {
    				const normalizedLocation = normalizeLocation(changedHistory.location, normalizedBasepath);
    				prevLocation.set($location);
    				location.set(normalizedLocation);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		registerRoute,
    		unregisterRoute,
    		manageFocus,
    		level,
    		id: routerId,
    		history: isTopLevelRouter ? history : routerContext.history,
    		basepath: isTopLevelRouter
    		? normalizedBasepath
    		: routerContext.basepath
    	});

    	const writable_props = ['basepath', 'url', 'history', 'primary', 'a11y'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('basepath' in $$props) $$invalidate(10, basepath = $$props.basepath);
    		if ('url' in $$props) $$invalidate(11, url = $$props.url);
    		if ('history' in $$props) $$invalidate(12, history = $$props.history);
    		if ('primary' in $$props) $$invalidate(13, primary = $$props.primary);
    		if ('a11y' in $$props) $$invalidate(14, a11y = $$props.a11y);
    		if ('$$scope' in $$props) $$invalidate(19, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createCounter,
    		createId: createId$1,
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		normalizePath,
    		pick,
    		match,
    		normalizeLocation,
    		createLocation: createLocation$1,
    		isSSR,
    		warn,
    		ROUTER_ID,
    		pushFocusCandidate,
    		visuallyHiddenStyle,
    		createTriggerFocus,
    		defaultBasepath,
    		basepath,
    		url,
    		history,
    		primary,
    		a11y,
    		a11yConfig,
    		initialBasepath,
    		normalizedBasepath,
    		locationContext,
    		routerContext,
    		isTopLevelRouter,
    		routerId,
    		manageFocus,
    		announcementText,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		level,
    		getInitialLocation,
    		location,
    		prevLocation,
    		triggerFocus,
    		createRouteFilter,
    		registerRoute,
    		unregisterRoute,
    		$location,
    		$activeRoute,
    		$prevLocation,
    		$routes,
    		$announcementText
    	});

    	$$self.$inject_state = $$props => {
    		if ('basepath' in $$props) $$invalidate(10, basepath = $$props.basepath);
    		if ('url' in $$props) $$invalidate(11, url = $$props.url);
    		if ('history' in $$props) $$invalidate(12, history = $$props.history);
    		if ('primary' in $$props) $$invalidate(13, primary = $$props.primary);
    		if ('a11y' in $$props) $$invalidate(14, a11y = $$props.a11y);
    		if ('hasActiveRoute' in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*basepath*/ 1024) {
    			if (basepath !== initialBasepath) {
    				warn(ROUTER_ID, 'You cannot change the "basepath" prop. It is ignored.');
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$routes, $location*/ 294912) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			{
    				const bestMatch = pick($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$location, $prevLocation*/ 163840) {
    			// Manage focus and announce navigation to screen reader users
    			{
    				if (isTopLevelRouter) {
    					const hasHash = !!$location.hash;

    					// When a hash is present in the url, we skip focus management, because
    					// focusing a different element will prevent in-page jumps (See #3)
    					const shouldManageFocus = !hasHash && manageFocus;

    					// We don't want to make an announcement, when the hash changes,
    					// but the active route stays the same
    					const announceNavigation = !hasHash || $location.pathname !== $prevLocation.pathname;

    					triggerFocus(shouldManageFocus, announceNavigation);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$activeRoute*/ 65536) {
    			// Queue matched Route, so top level Router can decide which Route to focus.
    			// Non primary Routers should just be ignored
    			if (manageFocus && $activeRoute && $activeRoute.primary) {
    				pushFocusCandidate({ level, routerId, route: $activeRoute });
    			}
    		}
    	};

    	return [
    		$announcementText,
    		a11yConfig,
    		isTopLevelRouter,
    		routerId,
    		manageFocus,
    		announcementText,
    		routes,
    		activeRoute,
    		location,
    		prevLocation,
    		basepath,
    		url,
    		history,
    		primary,
    		a11y,
    		$location,
    		$activeRoute,
    		$prevLocation,
    		$routes,
    		$$scope,
    		slots
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$B,
    			create_fragment$B,
    			safe_not_equal,
    			{
    				basepath: 10,
    				url: 11,
    				history: 12,
    				primary: 13,
    				a11y: 14
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get history() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set history(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primary() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primary(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get a11y() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set a11y(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Router$1 = Router;

    /**
     * Check if a component or hook have been created outside of a
     * context providing component
     * @param {number} componentId
     * @param {*} props
     * @param {string?} ctxKey
     * @param {number?} ctxProviderId
     */
    function usePreflightCheck(
    	componentId,
    	props,
    	ctxKey = ROUTER,
    	ctxProviderId = ROUTER_ID,
    ) {
    	const ctx = getContext(ctxKey);
    	if (!ctx) {
    		fail(
    			componentId,
    			label =>
    				`You cannot use ${label} outside of a ${createLabel(ctxProviderId)}.`,
    			props,
    		);
    	}
    }

    const toReadonly = ctx => {
    	const { subscribe } = getContext(ctx);
    	return { subscribe };
    };

    /**
     * Access the current location via a readable store.
     * @returns {import("svelte/store").Readable<{
        pathname: string;
        search: string;
        hash: string;
        state: {};
      }>}
     *
     * @example
      ```html
      <script>
        import { useLocation } from "svelte-navigator";

        const location = useLocation();

        $: console.log($location);
        // {
        //   pathname: "/blog",
        //   search: "?id=123",
        //   hash: "#comments",
        //   state: {}
        // }
      </script>
      ```
     */
    function useLocation() {
    	usePreflightCheck(USE_LOCATION_ID);
    	return toReadonly(LOCATION);
    }

    /**
     * @typedef {{
        path: string;
        fullPath: string;
        uri: string;
        params: {};
      }} RouteMatch
     */

    /**
     * @typedef {import("svelte/store").Readable<RouteMatch|null>} RouteMatchStore
     */

    /**
     * Access the history of top level Router.
     */
    function useHistory() {
    	const { history } = getContext(ROUTER);
    	return history;
    }

    /**
     * Access the base of the parent Route.
     */
    function useRouteBase() {
    	const route = getContext(ROUTE);
    	return route ? derived(route, _route => _route.base) : writable("/");
    }

    /**
     * Resolve a given link relative to the current `Route` and the `Router`s `basepath`.
     * It is used under the hood in `Link` and `useNavigate`.
     * You can use it to manually resolve links, when using the `link` or `links` actions.
     *
     * @returns {(path: string) => string}
     *
     * @example
      ```html
      <script>
        import { link, useResolve } from "svelte-navigator";

        const resolve = useResolve();
        // `resolvedLink` will be resolved relative to its parent Route
        // and the Routers `basepath`
        const resolvedLink = resolve("relativePath");
      </script>

      <a href={resolvedLink} use:link>Relative link</a>
      ```
     */
    function useResolve() {
    	usePreflightCheck(USE_RESOLVE_ID);
    	const routeBase = useRouteBase();
    	const { basepath: appBase } = getContext(ROUTER);
    	/**
    	 * Resolves the path relative to the current route and basepath.
    	 *
    	 * @param {string} path The path to resolve
    	 * @returns {string} The resolved path
    	 */
    	const resolve = path => resolveLink(path, get_store_value(routeBase), appBase);
    	return resolve;
    }

    /**
     * A hook, that returns a context-aware version of `navigate`.
     * It will automatically resolve the given link relative to the current Route.
     * It will also resolve a link against the `basepath` of the Router.
     *
     * @example
      ```html
      <!-- App.svelte -->
      <script>
        import { link, Route } from "svelte-navigator";
        import RouteComponent from "./RouteComponent.svelte";
      </script>

      <Router>
        <Route path="route1">
          <RouteComponent />
        </Route>
        <!-- ... -->
      </Router>

      <!-- RouteComponent.svelte -->
      <script>
        import { useNavigate } from "svelte-navigator";

        const navigate = useNavigate();
      </script>

      <button on:click="{() => navigate('relativePath')}">
        go to /route1/relativePath
      </button>
      <button on:click="{() => navigate('/absolutePath')}">
        go to /absolutePath
      </button>
      ```
      *
      * @example
      ```html
      <!-- App.svelte -->
      <script>
        import { link, Route } from "svelte-navigator";
        import RouteComponent from "./RouteComponent.svelte";
      </script>

      <Router basepath="/base">
        <Route path="route1">
          <RouteComponent />
        </Route>
        <!-- ... -->
      </Router>

      <!-- RouteComponent.svelte -->
      <script>
        import { useNavigate } from "svelte-navigator";

        const navigate = useNavigate();
      </script>

      <button on:click="{() => navigate('relativePath')}">
        go to /base/route1/relativePath
      </button>
      <button on:click="{() => navigate('/absolutePath')}">
        go to /base/absolutePath
      </button>
      ```
     */
    function useNavigate() {
    	usePreflightCheck(USE_NAVIGATE_ID);
    	const resolve = useResolve();
    	const { navigate } = useHistory();
    	/**
    	 * Navigate to a new route.
    	 * Resolves the link relative to the current route and basepath.
    	 *
    	 * @param {string|number} to The path to navigate to.
    	 *
    	 * If `to` is a number we will navigate to the stack entry index + `to`
    	 * (-> `navigate(-1)`, is equivalent to hitting the back button of the browser)
    	 * @param {Object} options
    	 * @param {*} [options.state]
    	 * @param {boolean} [options.replace=false]
    	 */
    	const navigateRelative = (to, options) => {
    		// If to is a number, we navigate to the target stack entry via `history.go`.
    		// Otherwise resolve the link
    		const target = isNumber(to) ? to : resolve(to);
    		return navigate(target, options);
    	};
    	return navigateRelative;
    }

    /* node_modules/svelte-navigator/src/Route.svelte generated by Svelte v3.44.0 */
    const file$y = "node_modules/svelte-navigator/src/Route.svelte";

    const get_default_slot_changes = dirty => ({
    	params: dirty & /*$params*/ 16,
    	location: dirty & /*$location*/ 8
    });

    const get_default_slot_context = ctx => ({
    	params: isSSR ? get_store_value(/*params*/ ctx[9]) : /*$params*/ ctx[4],
    	location: /*$location*/ ctx[3],
    	navigate: /*navigate*/ ctx[10]
    });

    // (97:0) {#if isActive}
    function create_if_block$9(ctx) {
    	let router;
    	let current;

    	router = new Router$1({
    			props: {
    				primary: /*primary*/ ctx[1],
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const router_changes = {};
    			if (dirty & /*primary*/ 2) router_changes.primary = /*primary*/ ctx[1];

    			if (dirty & /*$$scope, component, $location, $params, $$restProps*/ 264217) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(97:0) {#if isActive}",
    		ctx
    	});

    	return block;
    }

    // (113:2) {:else}
    function create_else_block$7(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, $params, $location*/ 262168)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(113:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (105:2) {#if component !== null}
    function create_if_block_1$6(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[3] },
    		{ navigate: /*navigate*/ ctx[10] },
    		isSSR ? get_store_value(/*params*/ ctx[9]) : /*$params*/ ctx[4],
    		/*$$restProps*/ ctx[11]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, navigate, isSSR, get, params, $params, $$restProps*/ 3608)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 8 && { location: /*$location*/ ctx[3] },
    					dirty & /*navigate*/ 1024 && { navigate: /*navigate*/ ctx[10] },
    					dirty & /*isSSR, get, params, $params*/ 528 && get_spread_object(isSSR ? get_store_value(/*params*/ ctx[9]) : /*$params*/ ctx[4]),
    					dirty & /*$$restProps*/ 2048 && get_spread_object(/*$$restProps*/ ctx[11])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(105:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    // (98:1) <Router {primary}>
    function create_default_slot$j(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$6, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(98:1) <Router {primary}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	let if_block = /*isActive*/ ctx[2] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			set_style(div0, "display", "none");
    			attr_dev(div0, "aria-hidden", "true");
    			attr_dev(div0, "data-svnav-route-start", /*id*/ ctx[5]);
    			add_location(div0, file$y, 95, 0, 2622);
    			set_style(div1, "display", "none");
    			attr_dev(div1, "aria-hidden", "true");
    			attr_dev(div1, "data-svnav-route-end", /*id*/ ctx[5]);
    			add_location(div1, file$y, 121, 0, 3295);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isActive*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isActive*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const createId = createCounter();

    function instance$A($$self, $$props, $$invalidate) {
    	let isActive;
    	const omit_props_names = ["path","component","meta","primary"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $activeRoute;
    	let $location;
    	let $parentBase;
    	let $params;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Route', slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	let { meta = {} } = $$props;
    	let { primary = true } = $$props;
    	usePreflightCheck(ROUTE_ID, $$props);
    	const id = createId();
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, 'activeRoute');
    	component_subscribe($$self, activeRoute, value => $$invalidate(15, $activeRoute = value));
    	const parentBase = useRouteBase();
    	validate_store(parentBase, 'parentBase');
    	component_subscribe($$self, parentBase, value => $$invalidate(16, $parentBase = value));
    	const location = useLocation();
    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(3, $location = value));
    	const focusElement = writable(null);

    	// In SSR we cannot wait for $activeRoute to update,
    	// so we use the match returned from `registerRoute` instead
    	let ssrMatch;

    	const route = writable();
    	const params = writable({});
    	validate_store(params, 'params');
    	component_subscribe($$self, params, value => $$invalidate(4, $params = value));
    	setContext(ROUTE, route);
    	setContext(ROUTE_PARAMS, params);
    	setContext(FOCUS_ELEM, focusElement);

    	// We need to call useNavigate after the route is set,
    	// so we can use the routes path for link resolution
    	const navigate = useNavigate();

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway
    	if (!isSSR) {
    		onDestroy(() => unregisterRoute(id));
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('path' in $$new_props) $$invalidate(12, path = $$new_props.path);
    		if ('component' in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ('meta' in $$new_props) $$invalidate(13, meta = $$new_props.meta);
    		if ('primary' in $$new_props) $$invalidate(1, primary = $$new_props.primary);
    		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createCounter,
    		createId,
    		getContext,
    		onDestroy,
    		setContext,
    		writable,
    		get: get_store_value,
    		Router: Router$1,
    		ROUTER,
    		ROUTE,
    		ROUTE_PARAMS,
    		FOCUS_ELEM,
    		useLocation,
    		useNavigate,
    		useRouteBase,
    		usePreflightCheck,
    		isSSR,
    		extractBaseUri,
    		join,
    		ROUTE_ID,
    		path,
    		component,
    		meta,
    		primary,
    		id,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		parentBase,
    		location,
    		focusElement,
    		ssrMatch,
    		route,
    		params,
    		navigate,
    		isActive,
    		$activeRoute,
    		$location,
    		$parentBase,
    		$params
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    		if ('path' in $$props) $$invalidate(12, path = $$new_props.path);
    		if ('component' in $$props) $$invalidate(0, component = $$new_props.component);
    		if ('meta' in $$props) $$invalidate(13, meta = $$new_props.meta);
    		if ('primary' in $$props) $$invalidate(1, primary = $$new_props.primary);
    		if ('ssrMatch' in $$props) $$invalidate(14, ssrMatch = $$new_props.ssrMatch);
    		if ('isActive' in $$props) $$invalidate(2, isActive = $$new_props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*path, $parentBase, meta, $location, primary*/ 77834) {
    			{
    				// The route store will be re-computed whenever props, location or parentBase change
    				const isDefault = path === "";

    				const rawBase = join($parentBase, path);

    				const updatedRoute = {
    					id,
    					path,
    					meta,
    					// If no path prop is given, this Route will act as the default Route
    					// that is rendered if no other Route in the Router is a match
    					default: isDefault,
    					fullPath: isDefault ? "" : rawBase,
    					base: isDefault
    					? $parentBase
    					: extractBaseUri(rawBase, $location.pathname),
    					primary,
    					focusElement
    				};

    				route.set(updatedRoute);

    				// If we're in SSR mode and the Route matches,
    				// `registerRoute` will return the match
    				$$invalidate(14, ssrMatch = registerRoute(updatedRoute));
    			}
    		}

    		if ($$self.$$.dirty & /*ssrMatch, $activeRoute*/ 49152) {
    			$$invalidate(2, isActive = !!(ssrMatch || $activeRoute && $activeRoute.id === id));
    		}

    		if ($$self.$$.dirty & /*isActive, ssrMatch, $activeRoute*/ 49156) {
    			if (isActive) {
    				const { params: activeParams } = ssrMatch || $activeRoute;
    				params.set(activeParams);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		primary,
    		isActive,
    		$location,
    		$params,
    		id,
    		activeRoute,
    		parentBase,
    		location,
    		params,
    		navigate,
    		$$restProps,
    		path,
    		meta,
    		ssrMatch,
    		$activeRoute,
    		$parentBase,
    		slots,
    		$$scope
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
    			path: 12,
    			component: 0,
    			meta: 13,
    			primary: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get meta() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set meta(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get primary() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set primary(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Route$1 = Route;

    /* node_modules/svelte-navigator/src/Link.svelte generated by Svelte v3.44.0 */
    const file$x = "node_modules/svelte-navigator/src/Link.svelte";

    function create_fragment$z(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	let a_levels = [{ href: /*href*/ ctx[0] }, /*ariaCurrent*/ ctx[2], /*props*/ ctx[1]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file$x, 63, 0, 1735);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				dirty & /*ariaCurrent*/ 4 && /*ariaCurrent*/ ctx[2],
    				dirty & /*props*/ 2 && /*props*/ ctx[1]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let href;
    	let isPartiallyCurrent;
    	let isCurrent;
    	let ariaCurrent;
    	let props;
    	const omit_props_names = ["to","replace","state","getProps"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	let { to } = $$props;
    	let { replace = false } = $$props;
    	let { state = {} } = $$props;
    	let { getProps = null } = $$props;
    	usePreflightCheck(LINK_ID, $$props);
    	const location = useLocation();
    	validate_store(location, 'location');
    	component_subscribe($$self, location, value => $$invalidate(11, $location = value));
    	const dispatch = createEventDispatcher();
    	const resolve = useResolve();
    	const { navigate } = useHistory();

    	function onClick(event) {
    		dispatch("click", event);

    		if (shouldNavigate(event)) {
    			event.preventDefault();

    			// Don't push another entry to the history stack when the user
    			// clicks on a Link to the page they are currently on.
    			const shouldReplace = isCurrent || replace;

    			navigate(href, { state, replace: shouldReplace });
    		}
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('to' in $$new_props) $$invalidate(5, to = $$new_props.to);
    		if ('replace' in $$new_props) $$invalidate(6, replace = $$new_props.replace);
    		if ('state' in $$new_props) $$invalidate(7, state = $$new_props.state);
    		if ('getProps' in $$new_props) $$invalidate(8, getProps = $$new_props.getProps);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		useLocation,
    		useResolve,
    		useHistory,
    		usePreflightCheck,
    		shouldNavigate,
    		isFunction,
    		startsWith: startsWith$1,
    		LINK_ID,
    		to,
    		replace,
    		state,
    		getProps,
    		location,
    		dispatch,
    		resolve,
    		navigate,
    		onClick,
    		href,
    		isCurrent,
    		isPartiallyCurrent,
    		props,
    		ariaCurrent,
    		$location
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ('to' in $$props) $$invalidate(5, to = $$new_props.to);
    		if ('replace' in $$props) $$invalidate(6, replace = $$new_props.replace);
    		if ('state' in $$props) $$invalidate(7, state = $$new_props.state);
    		if ('getProps' in $$props) $$invalidate(8, getProps = $$new_props.getProps);
    		if ('href' in $$props) $$invalidate(0, href = $$new_props.href);
    		if ('isCurrent' in $$props) $$invalidate(9, isCurrent = $$new_props.isCurrent);
    		if ('isPartiallyCurrent' in $$props) $$invalidate(10, isPartiallyCurrent = $$new_props.isPartiallyCurrent);
    		if ('props' in $$props) $$invalidate(1, props = $$new_props.props);
    		if ('ariaCurrent' in $$props) $$invalidate(2, ariaCurrent = $$new_props.ariaCurrent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*to, $location*/ 2080) {
    			// We need to pass location here to force re-resolution of the link,
    			// when the pathname changes. Otherwise we could end up with stale path params,
    			// when for example an :id changes in the parent Routes path
    			$$invalidate(0, href = resolve(to, $location));
    		}

    		if ($$self.$$.dirty & /*$location, href*/ 2049) {
    			$$invalidate(10, isPartiallyCurrent = startsWith$1($location.pathname, href));
    		}

    		if ($$self.$$.dirty & /*href, $location*/ 2049) {
    			$$invalidate(9, isCurrent = href === $location.pathname);
    		}

    		if ($$self.$$.dirty & /*isCurrent*/ 512) {
    			$$invalidate(2, ariaCurrent = isCurrent ? { "aria-current": "page" } : {});
    		}

    		$$invalidate(1, props = (() => {
    			if (isFunction(getProps)) {
    				const dynamicProps = getProps({
    					location: $location,
    					href,
    					isPartiallyCurrent,
    					isCurrent
    				});

    				return { ...$$restProps, ...dynamicProps };
    			}

    			return $$restProps;
    		})());
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		href,
    		props,
    		ariaCurrent,
    		location,
    		onClick,
    		to,
    		replace,
    		state,
    		getProps,
    		isCurrent,
    		isPartiallyCurrent,
    		$location,
    		$$scope,
    		slots
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { to: 5, replace: 6, state: 7, getProps: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*to*/ ctx[5] === undefined && !('to' in props)) {
    			console.warn("<Link> was created without expected prop 'to'");
    		}
    	}

    	get to() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Link$1 = Link;

    function getOriginalBodyPadding() {
      const style = window ? window.getComputedStyle(document.body, null) : {};

      return parseInt((style && style.getPropertyValue('padding-right')) || 0, 10);
    }

    function getScrollbarWidth() {
      let scrollDiv = document.createElement('div');
      // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113
      scrollDiv.style.position = 'absolute';
      scrollDiv.style.top = '-9999px';
      scrollDiv.style.width = '50px';
      scrollDiv.style.height = '50px';
      scrollDiv.style.overflow = 'scroll';
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    }

    function setScrollbarWidth(padding) {
      document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
    }

    function isBodyOverflowing() {
      return window ? document.body.clientWidth < window.innerWidth : false;
    }

    function isObject(value) {
      const type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    function conditionallyUpdateScrollbar() {
      const scrollbarWidth = getScrollbarWidth();
      // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.6/js/src/modal.js#L433
      const fixedContent = document.querySelectorAll(
        '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top'
      )[0];
      const bodyPadding = fixedContent
        ? parseInt(fixedContent.style.paddingRight || 0, 10)
        : 0;

      if (isBodyOverflowing()) {
        setScrollbarWidth(bodyPadding + scrollbarWidth);
      }
    }

    function getColumnSizeClass(isXs, colWidth, colSize) {
      if (colSize === true || colSize === '') {
        return isXs ? 'col' : `col-${colWidth}`;
      } else if (colSize === 'auto') {
        return isXs ? 'col-auto' : `col-${colWidth}-auto`;
      }

      return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
    }

    function browserEvent(target, ...args) {
      target.addEventListener(...args);

      return () => target.removeEventListener(...args);
    }

    function toClassName(value) {
      let result = '';

      if (typeof value === 'string' || typeof value === 'number') {
        result += value;
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          result = value.map(toClassName).filter(Boolean).join(' ');
        } else {
          for (let key in value) {
            if (value[key]) {
              result && (result += ' ');
              result += key;
            }
          }
        }
      }

      return result;
    }

    function classnames(...args) {
      return args.map(toClassName).filter(Boolean).join(' ');
    }

    function getTransitionDuration(element) {
      if (!element) return 0;

      // Get transition-duration of the element
      let { transitionDuration, transitionDelay } =
        window.getComputedStyle(element);

      const floatTransitionDuration = Number.parseFloat(transitionDuration);
      const floatTransitionDelay = Number.parseFloat(transitionDelay);

      // Return 0 if element or transition duration is not found
      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      }

      // If multiple durations are defined, take the first
      transitionDuration = transitionDuration.split(',')[0];
      transitionDelay = transitionDelay.split(',')[0];

      return (
        (Number.parseFloat(transitionDuration) +
          Number.parseFloat(transitionDelay)) *
        1000
      );
    }

    function backdropIn(node) {
      node.style.display = 'block';

      const duration = getTransitionDuration(node);

      return {
        duration,
        tick: (t) => {
          if (t === 0) {
            node.classList.add('show');
          }
        }
      };
    }

    function backdropOut(node) {
      node.classList.remove('show');
      const duration = getTransitionDuration(node);

      return {
        duration,
        tick: (t) => {
          if (t === 0) {
            node.style.display = 'none';
          }
        }
      };
    }

    function modalIn(node) {
      node.style.display = 'block';
      const duration = getTransitionDuration(node);

      return {
        duration,
        tick: (t) => {
          if (t > 0) {
            node.classList.add('show');
          }
        }
      };
    }

    function modalOut(node) {
      node.classList.remove('show');
      const duration = getTransitionDuration(node);

      return {
        duration,
        tick: (t) => {
          if (t === 1) {
            node.style.display = 'none';
          }
        }
      };
    }

    /* node_modules/sveltestrap/src/Button.svelte generated by Svelte v3.44.0 */
    const file$w = "node_modules/sveltestrap/src/Button.svelte";

    // (50:0) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let button_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	let button_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ value: /*value*/ ctx[5] },
    		{
    			"aria-label": button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			button = element("button");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(button, button_data);
    			add_location(button, file$w, 50, 2, 1044);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(button, null);
    			}

    			if (button.autofocus) button.focus();
    			/*button_binding*/ ctx[22](button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*children, $$scope*/ 131074)) {
    					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*value*/ 32) && { value: /*value*/ ctx[5] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && button_aria_label_value !== (button_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6])) && { "aria-label": button_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*button_binding*/ ctx[22](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(50:0) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (33:0) {#if href}
    function create_if_block$8(ctx) {
    	let a;
    	let current_block_type_index;
    	let if_block;
    	let a_aria_label_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$5, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*children*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let a_levels = [
    		/*$$restProps*/ ctx[9],
    		{ class: /*classes*/ ctx[7] },
    		{ disabled: /*disabled*/ ctx[2] },
    		{ href: /*href*/ ctx[3] },
    		{
    			"aria-label": a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6]
    		},
    		{ style: /*style*/ ctx[4] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block_1 = {
    		c: function create() {
    			a = element("a");
    			if_block.c();
    			set_attributes(a, a_data);
    			add_location(a, file$w, 33, 2, 786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if_blocks[current_block_type_index].m(a, null);
    			/*a_binding*/ ctx[21](a);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(a, null);
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9],
    				(!current || dirty & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
    				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
    				(!current || dirty & /*href*/ 8) && { href: /*href*/ ctx[3] },
    				(!current || dirty & /*ariaLabel, defaultAriaLabel*/ 320 && a_aria_label_value !== (a_aria_label_value = /*ariaLabel*/ ctx[8] || /*defaultAriaLabel*/ ctx[6])) && { "aria-label": a_aria_label_value },
    				(!current || dirty & /*style*/ 16) && { style: /*style*/ ctx[4] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_blocks[current_block_type_index].d();
    			/*a_binding*/ ctx[21](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(33:0) {#if href}",
    		ctx
    	});

    	return block_1;
    }

    // (64:6) {:else}
    function create_else_block_2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(64:6) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (62:6) {#if children}
    function create_if_block_2$4(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(62:6) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    // (61:10)        
    function fallback_block$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$4, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*children*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(61:10)        ",
    		ctx
    	});

    	return block_1;
    }

    // (46:4) {:else}
    function create_else_block$6(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block_1 = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[17],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(46:4) {:else}",
    		ctx
    	});

    	return block_1;
    }

    // (44:4) {#if children}
    function create_if_block_1$5(ctx) {
    	let t;

    	const block_1 = {
    		c: function create() {
    			t = text(/*children*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 2) set_data_dev(t, /*children*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(44:4) {#if children}",
    		ctx
    	});

    	return block_1;
    }

    function create_fragment$y(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block_1 = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block: block_1,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block_1;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let ariaLabel;
    	let classes;
    	let defaultAriaLabel;

    	const omit_props_names = [
    		"class","active","block","children","close","color","disabled","href","inner","outline","size","style","value"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { active = false } = $$props;
    	let { block = false } = $$props;
    	let { children = undefined } = $$props;
    	let { close = false } = $$props;
    	let { color = 'secondary' } = $$props;
    	let { disabled = false } = $$props;
    	let { href = '' } = $$props;
    	let { inner = undefined } = $$props;
    	let { outline = false } = $$props;
    	let { size = null } = $$props;
    	let { style = '' } = $$props;
    	let { value = '' } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function click_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(0, inner);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(10, className = $$new_props.class);
    		if ('active' in $$new_props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$new_props) $$invalidate(12, block = $$new_props.block);
    		if ('children' in $$new_props) $$invalidate(1, children = $$new_props.children);
    		if ('close' in $$new_props) $$invalidate(13, close = $$new_props.close);
    		if ('color' in $$new_props) $$invalidate(14, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('href' in $$new_props) $$invalidate(3, href = $$new_props.href);
    		if ('inner' in $$new_props) $$invalidate(0, inner = $$new_props.inner);
    		if ('outline' in $$new_props) $$invalidate(15, outline = $$new_props.outline);
    		if ('size' in $$new_props) $$invalidate(16, size = $$new_props.size);
    		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ('value' in $$new_props) $$invalidate(5, value = $$new_props.value);
    		if ('$$scope' in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		active,
    		block,
    		children,
    		close,
    		color,
    		disabled,
    		href,
    		inner,
    		outline,
    		size,
    		style,
    		value,
    		defaultAriaLabel,
    		classes,
    		ariaLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(10, className = $$new_props.className);
    		if ('active' in $$props) $$invalidate(11, active = $$new_props.active);
    		if ('block' in $$props) $$invalidate(12, block = $$new_props.block);
    		if ('children' in $$props) $$invalidate(1, children = $$new_props.children);
    		if ('close' in $$props) $$invalidate(13, close = $$new_props.close);
    		if ('color' in $$props) $$invalidate(14, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ('href' in $$props) $$invalidate(3, href = $$new_props.href);
    		if ('inner' in $$props) $$invalidate(0, inner = $$new_props.inner);
    		if ('outline' in $$props) $$invalidate(15, outline = $$new_props.outline);
    		if ('size' in $$props) $$invalidate(16, size = $$new_props.size);
    		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
    		if ('value' in $$props) $$invalidate(5, value = $$new_props.value);
    		if ('defaultAriaLabel' in $$props) $$invalidate(6, defaultAriaLabel = $$new_props.defaultAriaLabel);
    		if ('classes' in $$props) $$invalidate(7, classes = $$new_props.classes);
    		if ('ariaLabel' in $$props) $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		$$invalidate(8, ariaLabel = $$props['aria-label']);

    		if ($$self.$$.dirty & /*className, close, outline, color, size, block, active*/ 130048) {
    			$$invalidate(7, classes = classnames(className, close ? 'btn-close' : 'btn', close || `btn${outline ? '-outline' : ''}-${color}`, size ? `btn-${size}` : false, block ? 'd-block w-100' : false, { active }));
    		}

    		if ($$self.$$.dirty & /*close*/ 8192) {
    			$$invalidate(6, defaultAriaLabel = close ? 'Close' : null);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		inner,
    		children,
    		disabled,
    		href,
    		style,
    		value,
    		defaultAriaLabel,
    		classes,
    		ariaLabel,
    		$$restProps,
    		className,
    		active,
    		block,
    		close,
    		color,
    		outline,
    		size,
    		$$scope,
    		slots,
    		click_handler,
    		click_handler_1,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			class: 10,
    			active: 11,
    			block: 12,
    			children: 1,
    			close: 13,
    			color: 14,
    			disabled: 2,
    			href: 3,
    			inner: 0,
    			outline: 15,
    			size: 16,
    			style: 4,
    			value: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get block() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set block(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get close() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set close(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get outline() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set outline(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Col.svelte generated by Svelte v3.44.0 */
    const file$v = "node_modules/sveltestrap/src/Col.svelte";

    function create_fragment$x(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	let div_levels = [
    		/*$$restProps*/ ctx[1],
    		{
    			class: div_class_value = /*colClasses*/ ctx[0].join(' ')
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$v, 60, 0, 1427);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				{ class: div_class_value }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class","xs","sm","md","lg","xl","xxl"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Col', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { xs = undefined } = $$props;
    	let { sm = undefined } = $$props;
    	let { md = undefined } = $$props;
    	let { lg = undefined } = $$props;
    	let { xl = undefined } = $$props;
    	let { xxl = undefined } = $$props;
    	const colClasses = [];
    	const lookup = { xs, sm, md, lg, xl, xxl };

    	Object.keys(lookup).forEach(colWidth => {
    		const columnProp = lookup[colWidth];

    		if (!columnProp && columnProp !== '') {
    			return; //no value for this width
    		}

    		const isXs = colWidth === 'xs';

    		if (isObject(columnProp)) {
    			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
    			const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

    			if (columnProp.size || columnProp.size === '') {
    				colClasses.push(colClass);
    			}

    			if (columnProp.push) {
    				colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
    			}

    			if (columnProp.pull) {
    				colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
    			}

    			if (columnProp.offset) {
    				colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
    			}
    		} else {
    			colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
    		}
    	});

    	if (!colClasses.length) {
    		colClasses.push('col');
    	}

    	if (className) {
    		colClasses.push(className);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('xs' in $$new_props) $$invalidate(3, xs = $$new_props.xs);
    		if ('sm' in $$new_props) $$invalidate(4, sm = $$new_props.sm);
    		if ('md' in $$new_props) $$invalidate(5, md = $$new_props.md);
    		if ('lg' in $$new_props) $$invalidate(6, lg = $$new_props.lg);
    		if ('xl' in $$new_props) $$invalidate(7, xl = $$new_props.xl);
    		if ('xxl' in $$new_props) $$invalidate(8, xxl = $$new_props.xxl);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getColumnSizeClass,
    		isObject,
    		className,
    		xs,
    		sm,
    		md,
    		lg,
    		xl,
    		xxl,
    		colClasses,
    		lookup
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('xs' in $$props) $$invalidate(3, xs = $$new_props.xs);
    		if ('sm' in $$props) $$invalidate(4, sm = $$new_props.sm);
    		if ('md' in $$props) $$invalidate(5, md = $$new_props.md);
    		if ('lg' in $$props) $$invalidate(6, lg = $$new_props.lg);
    		if ('xl' in $$props) $$invalidate(7, xl = $$new_props.xl);
    		if ('xxl' in $$props) $$invalidate(8, xxl = $$new_props.xxl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [colClasses, $$restProps, className, xs, sm, md, lg, xl, xxl, $$scope, slots];
    }

    class Col extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			class: 2,
    			xs: 3,
    			sm: 4,
    			md: 5,
    			lg: 6,
    			xl: 7,
    			xxl: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Col",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get class() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xs() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xs(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sm() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sm(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lg() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lg(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xl() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xl(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xxl() {
    		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xxl(value) {
    		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Container.svelte generated by Svelte v3.44.0 */
    const file$u = "node_modules/sveltestrap/src/Container.svelte";

    function create_fragment$w(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$u, 23, 0, 542);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[9],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","sm","md","lg","xl","xxl","fluid"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Container', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { sm = undefined } = $$props;
    	let { md = undefined } = $$props;
    	let { lg = undefined } = $$props;
    	let { xl = undefined } = $$props;
    	let { xxl = undefined } = $$props;
    	let { fluid = false } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('sm' in $$new_props) $$invalidate(3, sm = $$new_props.sm);
    		if ('md' in $$new_props) $$invalidate(4, md = $$new_props.md);
    		if ('lg' in $$new_props) $$invalidate(5, lg = $$new_props.lg);
    		if ('xl' in $$new_props) $$invalidate(6, xl = $$new_props.xl);
    		if ('xxl' in $$new_props) $$invalidate(7, xxl = $$new_props.xxl);
    		if ('fluid' in $$new_props) $$invalidate(8, fluid = $$new_props.fluid);
    		if ('$$scope' in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		sm,
    		md,
    		lg,
    		xl,
    		xxl,
    		fluid,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('sm' in $$props) $$invalidate(3, sm = $$new_props.sm);
    		if ('md' in $$props) $$invalidate(4, md = $$new_props.md);
    		if ('lg' in $$props) $$invalidate(5, lg = $$new_props.lg);
    		if ('xl' in $$props) $$invalidate(6, xl = $$new_props.xl);
    		if ('xxl' in $$props) $$invalidate(7, xxl = $$new_props.xxl);
    		if ('fluid' in $$props) $$invalidate(8, fluid = $$new_props.fluid);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, sm, md, lg, xl, xxl, fluid*/ 508) {
    			$$invalidate(0, classes = classnames(className, {
    				'container-sm': sm,
    				'container-md': md,
    				'container-lg': lg,
    				'container-xl': xl,
    				'container-xxl': xxl,
    				'container-fluid': fluid,
    				container: !sm && !md && !lg && !xl && !xxl && !fluid
    			}));
    		}
    	};

    	return [classes, $$restProps, className, sm, md, lg, xl, xxl, fluid, $$scope, slots];
    }

    class Container extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			class: 2,
    			sm: 3,
    			md: 4,
    			lg: 5,
    			xl: 6,
    			xxl: 7,
    			fluid: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Container",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get class() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sm() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sm(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lg() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lg(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xl() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xl(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xxl() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xxl(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fluid() {
    		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fluid(value) {
    		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/FormCheck.svelte generated by Svelte v3.44.0 */
    const file$t = "node_modules/sveltestrap/src/FormCheck.svelte";
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});

    // (66:2) {:else}
    function create_else_block$5(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[11],
    		{ class: /*inputClasses*/ ctx[9] },
    		{ id: /*idFor*/ ctx[8] },
    		{ type: "checkbox" },
    		{ disabled: /*disabled*/ ctx[3] },
    		{ name: /*name*/ ctx[5] },
    		{ __value: /*value*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$t, 66, 4, 1386);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			input.checked = /*checked*/ ctx[0];
    			/*input_binding_2*/ ctx[38](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_2*/ ctx[28], false, false, false),
    					listen_dev(input, "change", /*change_handler_2*/ ctx[29], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_2*/ ctx[30], false, false, false),
    					listen_dev(input, "input", /*input_handler_2*/ ctx[31], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_2*/ ctx[37])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2048 && /*$$restProps*/ ctx[11],
    				dirty[0] & /*inputClasses*/ 512 && { class: /*inputClasses*/ ctx[9] },
    				dirty[0] & /*idFor*/ 256 && { id: /*idFor*/ ctx[8] },
    				{ type: "checkbox" },
    				dirty[0] & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
    				dirty[0] & /*name*/ 32 && { name: /*name*/ ctx[5] },
    				dirty[0] & /*value*/ 128 && { __value: /*value*/ ctx[7] }
    			]));

    			if (dirty[0] & /*checked*/ 1) {
    				input.checked = /*checked*/ ctx[0];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_2*/ ctx[38](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(66:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (50:30) 
    function create_if_block_2$3(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[11],
    		{ class: /*inputClasses*/ ctx[9] },
    		{ id: /*idFor*/ ctx[8] },
    		{ type: "checkbox" },
    		{ disabled: /*disabled*/ ctx[3] },
    		{ name: /*name*/ ctx[5] },
    		{ __value: /*value*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$t, 50, 4, 1122);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			input.checked = /*checked*/ ctx[0];
    			/*input_binding_1*/ ctx[36](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_1*/ ctx[24], false, false, false),
    					listen_dev(input, "change", /*change_handler_1*/ ctx[25], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_1*/ ctx[26], false, false, false),
    					listen_dev(input, "input", /*input_handler_1*/ ctx[27], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_1*/ ctx[35])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2048 && /*$$restProps*/ ctx[11],
    				dirty[0] & /*inputClasses*/ 512 && { class: /*inputClasses*/ ctx[9] },
    				dirty[0] & /*idFor*/ 256 && { id: /*idFor*/ ctx[8] },
    				{ type: "checkbox" },
    				dirty[0] & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
    				dirty[0] & /*name*/ 32 && { name: /*name*/ ctx[5] },
    				dirty[0] & /*value*/ 128 && { __value: /*value*/ ctx[7] }
    			]));

    			if (dirty[0] & /*checked*/ 1) {
    				input.checked = /*checked*/ ctx[0];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_1*/ ctx[36](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(50:30) ",
    		ctx
    	});

    	return block;
    }

    // (34:2) {#if type === 'radio'}
    function create_if_block_1$4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[11],
    		{ class: /*inputClasses*/ ctx[9] },
    		{ id: /*idFor*/ ctx[8] },
    		{ type: "radio" },
    		{ disabled: /*disabled*/ ctx[3] },
    		{ name: /*name*/ ctx[5] },
    		{ __value: /*value*/ ctx[7] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			/*$$binding_groups*/ ctx[33][0].push(input);
    			add_location(input, file$t, 34, 4, 842);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			input.checked = input.__value === /*group*/ ctx[1];
    			/*input_binding*/ ctx[34](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler*/ ctx[20], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[21], false, false, false),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[22], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[23], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[32])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2048 && /*$$restProps*/ ctx[11],
    				dirty[0] & /*inputClasses*/ 512 && { class: /*inputClasses*/ ctx[9] },
    				dirty[0] & /*idFor*/ 256 && { id: /*idFor*/ ctx[8] },
    				{ type: "radio" },
    				dirty[0] & /*disabled*/ 8 && { disabled: /*disabled*/ ctx[3] },
    				dirty[0] & /*name*/ 32 && { name: /*name*/ ctx[5] },
    				dirty[0] & /*value*/ 128 && { __value: /*value*/ ctx[7] }
    			]));

    			if (dirty[0] & /*group*/ 2) {
    				input.checked = input.__value === /*group*/ ctx[1];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[33][0].splice(/*$$binding_groups*/ ctx[33][0].indexOf(input), 1);
    			/*input_binding*/ ctx[34](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(34:2) {#if type === 'radio'}",
    		ctx
    	});

    	return block;
    }

    // (83:2) {#if label}
    function create_if_block$7(ctx) {
    	let label_1;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[19].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[18], get_label_slot_context);
    	const label_slot_or_fallback = label_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			if (label_slot_or_fallback) label_slot_or_fallback.c();
    			attr_dev(label_1, "class", "form-check-label");
    			attr_dev(label_1, "for", /*idFor*/ ctx[8]);
    			add_location(label_1, file$t, 83, 4, 1662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);

    			if (label_slot_or_fallback) {
    				label_slot_or_fallback.m(label_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[0] & /*$$scope*/ 262144)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[18],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[18], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			} else {
    				if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & /*label*/ 16)) {
    					label_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
    				}
    			}

    			if (!current || dirty[0] & /*idFor*/ 256) {
    				attr_dev(label_1, "for", /*idFor*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (label_slot_or_fallback) label_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(83:2) {#if label}",
    		ctx
    	});

    	return block;
    }

    // (85:25) {label}
    function fallback_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*label*/ 16) set_data_dev(t, /*label*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(85:25) {label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div;
    	let t;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[6] === 'radio') return create_if_block_1$4;
    		if (/*type*/ ctx[6] === 'switch') return create_if_block_2$3;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*label*/ ctx[4] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", /*classes*/ ctx[10]);
    			add_location(div, file$t, 32, 0, 791);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			}

    			if (/*label*/ ctx[4]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*label*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*classes*/ 1024) {
    				attr_dev(div, "class", /*classes*/ ctx[10]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let classes;
    	let inputClasses;
    	let idFor;

    	const omit_props_names = [
    		"class","checked","disabled","group","id","inline","inner","invalid","label","name","size","type","valid","value"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormCheck', slots, ['label']);
    	let { class: className = '' } = $$props;
    	let { checked = false } = $$props;
    	let { disabled = false } = $$props;
    	let { group = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { inline = false } = $$props;
    	let { inner = undefined } = $$props;
    	let { invalid = false } = $$props;
    	let { label = '' } = $$props;
    	let { name = '' } = $$props;
    	let { size = '' } = $$props;
    	let { type = 'checkbox' } = $$props;
    	let { valid = false } = $$props;
    	let { value = undefined } = $$props;
    	const $$binding_groups = [[]];

    	function blur_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_change_handler() {
    		group = this.__value;
    		$$invalidate(1, group);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(2, inner);
    		});
    	}

    	function input_change_handler_1() {
    		checked = this.checked;
    		$$invalidate(0, checked);
    	}

    	function input_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(2, inner);
    		});
    	}

    	function input_change_handler_2() {
    		checked = this.checked;
    		$$invalidate(0, checked);
    	}

    	function input_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(2, inner);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(12, className = $$new_props.class);
    		if ('checked' in $$new_props) $$invalidate(0, checked = $$new_props.checked);
    		if ('disabled' in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('group' in $$new_props) $$invalidate(1, group = $$new_props.group);
    		if ('id' in $$new_props) $$invalidate(13, id = $$new_props.id);
    		if ('inline' in $$new_props) $$invalidate(14, inline = $$new_props.inline);
    		if ('inner' in $$new_props) $$invalidate(2, inner = $$new_props.inner);
    		if ('invalid' in $$new_props) $$invalidate(15, invalid = $$new_props.invalid);
    		if ('label' in $$new_props) $$invalidate(4, label = $$new_props.label);
    		if ('name' in $$new_props) $$invalidate(5, name = $$new_props.name);
    		if ('size' in $$new_props) $$invalidate(16, size = $$new_props.size);
    		if ('type' in $$new_props) $$invalidate(6, type = $$new_props.type);
    		if ('valid' in $$new_props) $$invalidate(17, valid = $$new_props.valid);
    		if ('value' in $$new_props) $$invalidate(7, value = $$new_props.value);
    		if ('$$scope' in $$new_props) $$invalidate(18, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		checked,
    		disabled,
    		group,
    		id,
    		inline,
    		inner,
    		invalid,
    		label,
    		name,
    		size,
    		type,
    		valid,
    		value,
    		idFor,
    		inputClasses,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(12, className = $$new_props.className);
    		if ('checked' in $$props) $$invalidate(0, checked = $$new_props.checked);
    		if ('disabled' in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ('group' in $$props) $$invalidate(1, group = $$new_props.group);
    		if ('id' in $$props) $$invalidate(13, id = $$new_props.id);
    		if ('inline' in $$props) $$invalidate(14, inline = $$new_props.inline);
    		if ('inner' in $$props) $$invalidate(2, inner = $$new_props.inner);
    		if ('invalid' in $$props) $$invalidate(15, invalid = $$new_props.invalid);
    		if ('label' in $$props) $$invalidate(4, label = $$new_props.label);
    		if ('name' in $$props) $$invalidate(5, name = $$new_props.name);
    		if ('size' in $$props) $$invalidate(16, size = $$new_props.size);
    		if ('type' in $$props) $$invalidate(6, type = $$new_props.type);
    		if ('valid' in $$props) $$invalidate(17, valid = $$new_props.valid);
    		if ('value' in $$props) $$invalidate(7, value = $$new_props.value);
    		if ('idFor' in $$props) $$invalidate(8, idFor = $$new_props.idFor);
    		if ('inputClasses' in $$props) $$invalidate(9, inputClasses = $$new_props.inputClasses);
    		if ('classes' in $$props) $$invalidate(10, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*className, type, inline, size*/ 86080) {
    			$$invalidate(10, classes = classnames(className, 'form-check', {
    				'form-switch': type === 'switch',
    				'form-check-inline': inline,
    				[`form-control-${size}`]: size
    			}));
    		}

    		if ($$self.$$.dirty[0] & /*invalid, valid*/ 163840) {
    			$$invalidate(9, inputClasses = classnames('form-check-input', { 'is-invalid': invalid, 'is-valid': valid }));
    		}

    		if ($$self.$$.dirty[0] & /*id, label*/ 8208) {
    			$$invalidate(8, idFor = id || label);
    		}
    	};

    	return [
    		checked,
    		group,
    		inner,
    		disabled,
    		label,
    		name,
    		type,
    		value,
    		idFor,
    		inputClasses,
    		classes,
    		$$restProps,
    		className,
    		id,
    		inline,
    		invalid,
    		size,
    		valid,
    		$$scope,
    		slots,
    		blur_handler,
    		change_handler,
    		focus_handler,
    		input_handler,
    		blur_handler_1,
    		change_handler_1,
    		focus_handler_1,
    		input_handler_1,
    		blur_handler_2,
    		change_handler_2,
    		focus_handler_2,
    		input_handler_2,
    		input_change_handler,
    		$$binding_groups,
    		input_binding,
    		input_change_handler_1,
    		input_binding_1,
    		input_change_handler_2,
    		input_binding_2
    	];
    }

    class FormCheck extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$v,
    			create_fragment$v,
    			safe_not_equal,
    			{
    				class: 12,
    				checked: 0,
    				disabled: 3,
    				group: 1,
    				id: 13,
    				inline: 14,
    				inner: 2,
    				invalid: 15,
    				label: 4,
    				name: 5,
    				size: 16,
    				type: 6,
    				valid: 17,
    				value: 7
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormCheck",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get class() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valid() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valid(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/FormFeedback.svelte generated by Svelte v3.44.0 */
    const file$s = "node_modules/sveltestrap/src/FormFeedback.svelte";

    function create_fragment$u(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$s, 19, 0, 368);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class","valid","tooltip"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormFeedback', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { valid = undefined } = $$props;
    	let { tooltip = false } = $$props;
    	let classes;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('valid' in $$new_props) $$invalidate(3, valid = $$new_props.valid);
    		if ('tooltip' in $$new_props) $$invalidate(4, tooltip = $$new_props.tooltip);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		valid,
    		tooltip,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('valid' in $$props) $$invalidate(3, valid = $$new_props.valid);
    		if ('tooltip' in $$props) $$invalidate(4, tooltip = $$new_props.tooltip);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*tooltip, className, valid*/ 28) {
    			{
    				const validMode = tooltip ? 'tooltip' : 'feedback';
    				$$invalidate(0, classes = classnames(className, valid ? `valid-${validMode}` : `invalid-${validMode}`));
    			}
    		}
    	};

    	return [classes, $$restProps, className, valid, tooltip, $$scope, slots];
    }

    class FormFeedback extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { class: 2, valid: 3, tooltip: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormFeedback",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get class() {
    		throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valid() {
    		throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valid(value) {
    		throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltip() {
    		throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltip(value) {
    		throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/FormGroup.svelte generated by Svelte v3.44.0 */
    const file$r = "node_modules/sveltestrap/src/FormGroup.svelte";

    // (24:0) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
    	let div_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$r, 24, 2, 528);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(24:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:0) {#if tag === 'fieldset'}
    function create_if_block$6(ctx) {
    	let fieldset;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
    	let fieldset_levels = [/*$$restProps*/ ctx[2], { class: /*classes*/ ctx[1] }];
    	let fieldset_data = {};

    	for (let i = 0; i < fieldset_levels.length; i += 1) {
    		fieldset_data = assign(fieldset_data, fieldset_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			fieldset = element("fieldset");
    			if (default_slot) default_slot.c();
    			set_attributes(fieldset, fieldset_data);
    			add_location(fieldset, file$r, 20, 2, 447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fieldset, anchor);

    			if (default_slot) {
    				default_slot.m(fieldset, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fieldset);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(20:0) {#if tag === 'fieldset'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[0] === 'fieldset') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","check","disabled","inline","row","tag"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FormGroup', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { check = false } = $$props;
    	let { disabled = false } = $$props;
    	let { inline = false } = $$props;
    	let { row = false } = $$props;
    	let { tag = null } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('check' in $$new_props) $$invalidate(4, check = $$new_props.check);
    		if ('disabled' in $$new_props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('inline' in $$new_props) $$invalidate(6, inline = $$new_props.inline);
    		if ('row' in $$new_props) $$invalidate(7, row = $$new_props.row);
    		if ('tag' in $$new_props) $$invalidate(0, tag = $$new_props.tag);
    		if ('$$scope' in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		check,
    		disabled,
    		inline,
    		row,
    		tag,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('check' in $$props) $$invalidate(4, check = $$new_props.check);
    		if ('disabled' in $$props) $$invalidate(5, disabled = $$new_props.disabled);
    		if ('inline' in $$props) $$invalidate(6, inline = $$new_props.inline);
    		if ('row' in $$props) $$invalidate(7, row = $$new_props.row);
    		if ('tag' in $$props) $$invalidate(0, tag = $$new_props.tag);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, row, check, inline, disabled*/ 248) {
    			$$invalidate(1, classes = classnames(className, 'mb-3', {
    				row,
    				'form-check': check,
    				'form-check-inline': check && inline,
    				disabled: check && disabled
    			}));
    		}
    	};

    	return [
    		tag,
    		classes,
    		$$restProps,
    		className,
    		check,
    		disabled,
    		inline,
    		row,
    		$$scope,
    		slots
    	];
    }

    class FormGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			class: 3,
    			check: 4,
    			disabled: 5,
    			inline: 6,
    			row: 7,
    			tag: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormGroup",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get class() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get check() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set check(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get row() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tag() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/InlineContainer.svelte generated by Svelte v3.44.0 */

    const file$q = "node_modules/sveltestrap/src/InlineContainer.svelte";

    function create_fragment$s(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div, file$q, 3, 0, 67);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InlineContainer', slots, ['default']);
    	let x = 'wtf svelte?'; // eslint-disable-line
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InlineContainer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ x });

    	$$self.$inject_state = $$props => {
    		if ('x' in $$props) x = $$props.x;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$$scope, slots];
    }

    class InlineContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InlineContainer",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* node_modules/sveltestrap/src/Input.svelte generated by Svelte v3.44.0 */
    const file$p = "node_modules/sveltestrap/src/Input.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[210] = list[i];
    	return child_ctx;
    }

    // (490:40) 
    function create_if_block_22(ctx) {
    	let select;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[24].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[209], null);

    	let select_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ name: /*name*/ ctx[13] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ readonly: /*readonly*/ ctx[15] }
    	];

    	let select_data = {};

    	for (let i = 0; i < select_levels.length; i += 1) {
    		select_data = assign(select_data, select_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			if (default_slot) default_slot.c();
    			set_attributes(select, select_data);
    			if (/*value*/ ctx[6] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[207].call(select));
    			add_location(select, file$p, 490, 2, 9190);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			(select_data.multiple ? select_options : select_option)(select, select_data.value);
    			if (select.autofocus) select.focus();
    			select_option(select, /*value*/ ctx[6]);
    			/*select_binding*/ ctx[208](select);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "blur", /*blur_handler_20*/ ctx[156], false, false, false),
    					listen_dev(select, "change", /*change_handler_19*/ ctx[157], false, false, false),
    					listen_dev(select, "focus", /*focus_handler_20*/ ctx[158], false, false, false),
    					listen_dev(select, "input", /*input_handler_19*/ ctx[159], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[207])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[6] & /*$$scope*/ 8388608)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[209],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[209])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[209], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(select, select_data = get_spread_update(select_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				(!current || dirty[0] & /*classes*/ 262144) && { class: /*classes*/ ctx[18] },
    				(!current || dirty[0] & /*name*/ 8192) && { name: /*name*/ ctx[13] },
    				(!current || dirty[0] & /*disabled*/ 256) && { disabled: /*disabled*/ ctx[8] },
    				(!current || dirty[0] & /*readonly*/ 32768) && { readonly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*$$restProps, classes, name, disabled, readonly*/ 2400512 && 'value' in select_data) (select_data.multiple ? select_options : select_option)(select, select_data.value);
    			

    			if (dirty[0] & /*value*/ 64) {
    				select_option(select, /*value*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding*/ ctx[208](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_22.name,
    		type: "if",
    		source: "(490:40) ",
    		ctx
    	});

    	return block;
    }

    // (472:29) 
    function create_if_block_21(ctx) {
    	let textarea;
    	let mounted;
    	let dispose;

    	let textarea_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let textarea_data = {};

    	for (let i = 0; i < textarea_levels.length; i += 1) {
    		textarea_data = assign(textarea_data, textarea_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			set_attributes(textarea, textarea_data);
    			add_location(textarea, file$p, 472, 2, 8899);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			if (textarea.autofocus) textarea.focus();
    			set_input_value(textarea, /*value*/ ctx[6]);
    			/*textarea_binding*/ ctx[206](textarea);

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "blur", /*blur_handler_19*/ ctx[149], false, false, false),
    					listen_dev(textarea, "change", /*change_handler_18*/ ctx[150], false, false, false),
    					listen_dev(textarea, "focus", /*focus_handler_19*/ ctx[151], false, false, false),
    					listen_dev(textarea, "input", /*input_handler_18*/ ctx[152], false, false, false),
    					listen_dev(textarea, "keydown", /*keydown_handler_19*/ ctx[153], false, false, false),
    					listen_dev(textarea, "keypress", /*keypress_handler_19*/ ctx[154], false, false, false),
    					listen_dev(textarea, "keyup", /*keyup_handler_19*/ ctx[155], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[205])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(textarea, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding*/ ctx[206](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_21.name,
    		type: "if",
    		source: "(472:29) ",
    		ctx
    	});

    	return block;
    }

    // (93:0) {#if tag === 'input'}
    function create_if_block_2$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block_3$1,
    		create_if_block_4$1,
    		create_if_block_5,
    		create_if_block_6,
    		create_if_block_7,
    		create_if_block_8,
    		create_if_block_9,
    		create_if_block_10,
    		create_if_block_11,
    		create_if_block_12,
    		create_if_block_13,
    		create_if_block_14,
    		create_if_block_15,
    		create_if_block_16,
    		create_if_block_17,
    		create_if_block_18,
    		create_if_block_19,
    		create_if_block_20,
    		create_else_block_1
    	];

    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*type*/ ctx[16] === 'text') return 0;
    		if (/*type*/ ctx[16] === 'password') return 1;
    		if (/*type*/ ctx[16] === 'color') return 2;
    		if (/*type*/ ctx[16] === 'email') return 3;
    		if (/*type*/ ctx[16] === 'file') return 4;
    		if (/*type*/ ctx[16] === 'checkbox' || /*type*/ ctx[16] === 'radio' || /*type*/ ctx[16] === 'switch') return 5;
    		if (/*type*/ ctx[16] === 'url') return 6;
    		if (/*type*/ ctx[16] === 'number') return 7;
    		if (/*type*/ ctx[16] === 'date') return 8;
    		if (/*type*/ ctx[16] === 'time') return 9;
    		if (/*type*/ ctx[16] === 'datetime') return 10;
    		if (/*type*/ ctx[16] === 'datetime-local') return 11;
    		if (/*type*/ ctx[16] === 'month') return 12;
    		if (/*type*/ ctx[16] === 'color') return 13;
    		if (/*type*/ ctx[16] === 'range') return 14;
    		if (/*type*/ ctx[16] === 'search') return 15;
    		if (/*type*/ ctx[16] === 'tel') return 16;
    		if (/*type*/ ctx[16] === 'week') return 17;
    		return 18;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(93:0) {#if tag === 'input'}",
    		ctx
    	});

    	return block;
    }

    // (453:2) {:else}
    function create_else_block_1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ type: /*type*/ ctx[16] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ class: /*classes*/ ctx[18] },
    		{ name: /*name*/ ctx[13] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ value: /*value*/ ctx[6] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 453, 4, 8568);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.value = input_data.value;
    			if (input.autofocus) input.focus();

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_18*/ ctx[144], false, false, false),
    					listen_dev(input, "change", /*handleInput*/ ctx[20], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_18*/ ctx[145], false, false, false),
    					listen_dev(input, "input", /*handleInput*/ ctx[20], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_18*/ ctx[146], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_18*/ ctx[147], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_18*/ ctx[148], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*type*/ 65536 && { type: /*type*/ ctx[16] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6] && { value: /*value*/ ctx[6] }
    			]));

    			if ('value' in input_data) {
    				input.value = input_data.value;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(453:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (434:28) 
    function create_if_block_20(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "week" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 434, 4, 8259);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_16*/ ctx[204](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_17*/ ctx[137], false, false, false),
    					listen_dev(input, "change", /*change_handler_17*/ ctx[138], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_17*/ ctx[139], false, false, false),
    					listen_dev(input, "input", /*input_handler_17*/ ctx[140], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_17*/ ctx[141], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_17*/ ctx[142], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_17*/ ctx[143], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_14*/ ctx[203])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "week" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_16*/ ctx[204](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_20.name,
    		type: "if",
    		source: "(434:28) ",
    		ctx
    	});

    	return block;
    }

    // (414:27) 
    function create_if_block_19(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "tel" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ size: /*size*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 414, 4, 7919);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_15*/ ctx[202](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_16*/ ctx[130], false, false, false),
    					listen_dev(input, "change", /*change_handler_16*/ ctx[131], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_16*/ ctx[132], false, false, false),
    					listen_dev(input, "input", /*input_handler_16*/ ctx[133], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_16*/ ctx[134], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_16*/ ctx[135], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_16*/ ctx[136], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_13*/ ctx[201])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "tel" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_15*/ ctx[202](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_19.name,
    		type: "if",
    		source: "(414:27) ",
    		ctx
    	});

    	return block;
    }

    // (394:30) 
    function create_if_block_18(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "search" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ size: /*size*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 394, 4, 7577);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_14*/ ctx[200](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_15*/ ctx[123], false, false, false),
    					listen_dev(input, "change", /*change_handler_15*/ ctx[124], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_15*/ ctx[125], false, false, false),
    					listen_dev(input, "input", /*input_handler_15*/ ctx[126], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_15*/ ctx[127], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_15*/ ctx[128], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_15*/ ctx[129], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_12*/ ctx[199])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "search" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_14*/ ctx[200](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_18.name,
    		type: "if",
    		source: "(394:30) ",
    		ctx
    	});

    	return block;
    }

    // (375:29) 
    function create_if_block_17(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ type: "range" },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ class: /*classes*/ ctx[18] },
    		{ name: /*name*/ ctx[13] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[14] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 375, 4, 7246);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_13*/ ctx[198](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_14*/ ctx[116], false, false, false),
    					listen_dev(input, "change", /*change_handler_14*/ ctx[117], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_14*/ ctx[118], false, false, false),
    					listen_dev(input, "input", /*input_handler_14*/ ctx[119], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_14*/ ctx[120], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_14*/ ctx[121], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_14*/ ctx[122], false, false, false),
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[197]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[197])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				{ type: "range" },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_13*/ ctx[198](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(375:29) ",
    		ctx
    	});

    	return block;
    }

    // (356:29) 
    function create_if_block_16(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ type: "color" },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ class: /*classes*/ ctx[18] },
    		{ name: /*name*/ ctx[13] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[14] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 356, 4, 6916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_12*/ ctx[196](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_13*/ ctx[109], false, false, false),
    					listen_dev(input, "change", /*change_handler_13*/ ctx[110], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_13*/ ctx[111], false, false, false),
    					listen_dev(input, "input", /*input_handler_13*/ ctx[112], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_13*/ ctx[113], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_13*/ ctx[114], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_13*/ ctx[115], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_11*/ ctx[195])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				{ type: "color" },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_12*/ ctx[196](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(356:29) ",
    		ctx
    	});

    	return block;
    }

    // (337:29) 
    function create_if_block_15(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "month" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 337, 4, 6586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_11*/ ctx[194](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_12*/ ctx[102], false, false, false),
    					listen_dev(input, "change", /*change_handler_12*/ ctx[103], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_12*/ ctx[104], false, false, false),
    					listen_dev(input, "input", /*input_handler_12*/ ctx[105], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_12*/ ctx[106], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_12*/ ctx[107], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_12*/ ctx[108], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_10*/ ctx[193])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "month" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_11*/ ctx[194](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(337:29) ",
    		ctx
    	});

    	return block;
    }

    // (318:38) 
    function create_if_block_14(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "datetime-local" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 318, 4, 6247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_10*/ ctx[192](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_11*/ ctx[95], false, false, false),
    					listen_dev(input, "change", /*change_handler_11*/ ctx[96], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_11*/ ctx[97], false, false, false),
    					listen_dev(input, "input", /*input_handler_11*/ ctx[98], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_11*/ ctx[99], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_11*/ ctx[100], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_11*/ ctx[101], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_9*/ ctx[191])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "datetime-local" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_10*/ ctx[192](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(318:38) ",
    		ctx
    	});

    	return block;
    }

    // (299:32) 
    function create_if_block_13(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ type: "datetime" },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ class: /*classes*/ ctx[18] },
    		{ name: /*name*/ ctx[13] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[14] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 299, 4, 5905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_9*/ ctx[190](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_10*/ ctx[88], false, false, false),
    					listen_dev(input, "change", /*change_handler_10*/ ctx[89], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_10*/ ctx[90], false, false, false),
    					listen_dev(input, "input", /*input_handler_10*/ ctx[91], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_10*/ ctx[92], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_10*/ ctx[93], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_10*/ ctx[94], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_8*/ ctx[189])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				{ type: "datetime" },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_9*/ ctx[190](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(299:32) ",
    		ctx
    	});

    	return block;
    }

    // (280:28) 
    function create_if_block_12(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "time" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 280, 4, 5573);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_8*/ ctx[188](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_9*/ ctx[81], false, false, false),
    					listen_dev(input, "change", /*change_handler_9*/ ctx[82], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_9*/ ctx[83], false, false, false),
    					listen_dev(input, "input", /*input_handler_9*/ ctx[84], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_9*/ ctx[85], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_9*/ ctx[86], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_9*/ ctx[87], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_7*/ ctx[187])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "time" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_8*/ ctx[188](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(280:28) ",
    		ctx
    	});

    	return block;
    }

    // (261:28) 
    function create_if_block_11(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "date" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 261, 4, 5245);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_7*/ ctx[186](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_8*/ ctx[74], false, false, false),
    					listen_dev(input, "change", /*change_handler_8*/ ctx[75], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_8*/ ctx[76], false, false, false),
    					listen_dev(input, "input", /*input_handler_8*/ ctx[77], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_8*/ ctx[78], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_8*/ ctx[79], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_8*/ ctx[80], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_6*/ ctx[185])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "date" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_7*/ ctx[186](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(261:28) ",
    		ctx
    	});

    	return block;
    }

    // (242:30) 
    function create_if_block_10(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "number" },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ name: /*name*/ ctx[13] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ placeholder: /*placeholder*/ ctx[14] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 242, 4, 4915);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_6*/ ctx[184](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_7*/ ctx[67], false, false, false),
    					listen_dev(input, "change", /*change_handler_7*/ ctx[68], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_7*/ ctx[69], false, false, false),
    					listen_dev(input, "input", /*input_handler_7*/ ctx[70], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_7*/ ctx[71], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_7*/ ctx[72], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_7*/ ctx[73], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_5*/ ctx[183])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "number" },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] }
    			]));

    			if (dirty[0] & /*value*/ 64 && to_number(input.value) !== /*value*/ ctx[6]) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_6*/ ctx[184](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(242:30) ",
    		ctx
    	});

    	return block;
    }

    // (222:27) 
    function create_if_block_9(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "url" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ size: /*size*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 222, 4, 4573);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_5*/ ctx[182](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_6*/ ctx[60], false, false, false),
    					listen_dev(input, "change", /*change_handler_6*/ ctx[61], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_6*/ ctx[62], false, false, false),
    					listen_dev(input, "input", /*input_handler_6*/ ctx[63], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_6*/ ctx[64], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_6*/ ctx[65], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_6*/ ctx[66], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_4*/ ctx[181])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "url" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_5*/ ctx[182](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(222:27) ",
    		ctx
    	});

    	return block;
    }

    // (197:73) 
    function create_if_block_8(ctx) {
    	let formcheck;
    	let updating_checked;
    	let updating_inner;
    	let updating_group;
    	let updating_value;
    	let current;

    	const formcheck_spread_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*className*/ ctx[7] },
    		{ size: /*bsSize*/ ctx[0] },
    		{ type: /*type*/ ctx[16] },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ invalid: /*invalid*/ ctx[10] },
    		{ label: /*label*/ ctx[11] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readonly: /*readonly*/ ctx[15] },
    		{ valid: /*valid*/ ctx[17] }
    	];

    	function formcheck_checked_binding(value) {
    		/*formcheck_checked_binding*/ ctx[170](value);
    	}

    	function formcheck_inner_binding(value) {
    		/*formcheck_inner_binding*/ ctx[171](value);
    	}

    	function formcheck_group_binding(value) {
    		/*formcheck_group_binding*/ ctx[172](value);
    	}

    	function formcheck_value_binding(value) {
    		/*formcheck_value_binding*/ ctx[173](value);
    	}

    	let formcheck_props = {};

    	for (let i = 0; i < formcheck_spread_levels.length; i += 1) {
    		formcheck_props = assign(formcheck_props, formcheck_spread_levels[i]);
    	}

    	if (/*checked*/ ctx[2] !== void 0) {
    		formcheck_props.checked = /*checked*/ ctx[2];
    	}

    	if (/*inner*/ ctx[5] !== void 0) {
    		formcheck_props.inner = /*inner*/ ctx[5];
    	}

    	if (/*group*/ ctx[4] !== void 0) {
    		formcheck_props.group = /*group*/ ctx[4];
    	}

    	if (/*value*/ ctx[6] !== void 0) {
    		formcheck_props.value = /*value*/ ctx[6];
    	}

    	formcheck = new FormCheck({ props: formcheck_props, $$inline: true });
    	binding_callbacks.push(() => bind(formcheck, 'checked', formcheck_checked_binding));
    	binding_callbacks.push(() => bind(formcheck, 'inner', formcheck_inner_binding));
    	binding_callbacks.push(() => bind(formcheck, 'group', formcheck_group_binding));
    	binding_callbacks.push(() => bind(formcheck, 'value', formcheck_value_binding));
    	formcheck.$on("blur", /*blur_handler_5*/ ctx[174]);
    	formcheck.$on("change", /*change_handler_5*/ ctx[175]);
    	formcheck.$on("focus", /*focus_handler_5*/ ctx[176]);
    	formcheck.$on("input", /*input_handler_5*/ ctx[177]);
    	formcheck.$on("keydown", /*keydown_handler_5*/ ctx[178]);
    	formcheck.$on("keypress", /*keypress_handler_5*/ ctx[179]);
    	formcheck.$on("keyup", /*keyup_handler_5*/ ctx[180]);

    	const block = {
    		c: function create() {
    			create_component(formcheck.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(formcheck, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formcheck_changes = (dirty[0] & /*$$restProps, className, bsSize, type, disabled, invalid, label, name, placeholder, readonly, valid*/ 2354561)
    			? get_spread_update(formcheck_spread_levels, [
    					dirty[0] & /*$$restProps*/ 2097152 && get_spread_object(/*$$restProps*/ ctx[21]),
    					dirty[0] & /*className*/ 128 && { class: /*className*/ ctx[7] },
    					dirty[0] & /*bsSize*/ 1 && { size: /*bsSize*/ ctx[0] },
    					dirty[0] & /*type*/ 65536 && { type: /*type*/ ctx[16] },
    					dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    					dirty[0] & /*invalid*/ 1024 && { invalid: /*invalid*/ ctx[10] },
    					dirty[0] & /*label*/ 2048 && { label: /*label*/ ctx[11] },
    					dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    					dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    					dirty[0] & /*readonly*/ 32768 && { readonly: /*readonly*/ ctx[15] },
    					dirty[0] & /*valid*/ 131072 && { valid: /*valid*/ ctx[17] }
    				])
    			: {};

    			if (!updating_checked && dirty[0] & /*checked*/ 4) {
    				updating_checked = true;
    				formcheck_changes.checked = /*checked*/ ctx[2];
    				add_flush_callback(() => updating_checked = false);
    			}

    			if (!updating_inner && dirty[0] & /*inner*/ 32) {
    				updating_inner = true;
    				formcheck_changes.inner = /*inner*/ ctx[5];
    				add_flush_callback(() => updating_inner = false);
    			}

    			if (!updating_group && dirty[0] & /*group*/ 16) {
    				updating_group = true;
    				formcheck_changes.group = /*group*/ ctx[4];
    				add_flush_callback(() => updating_group = false);
    			}

    			if (!updating_value && dirty[0] & /*value*/ 64) {
    				updating_value = true;
    				formcheck_changes.value = /*value*/ ctx[6];
    				add_flush_callback(() => updating_value = false);
    			}

    			formcheck.$set(formcheck_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formcheck.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formcheck.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formcheck, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(197:73) ",
    		ctx
    	});

    	return block;
    }

    // (174:28) 
    function create_if_block_7(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "file" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ invalid: /*invalid*/ ctx[10] },
    		{ multiple: /*multiple*/ ctx[12] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ valid: /*valid*/ ctx[17] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 174, 4, 3715);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			/*input_binding_4*/ ctx[169](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_4*/ ctx[53], false, false, false),
    					listen_dev(input, "change", /*change_handler_4*/ ctx[54], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_4*/ ctx[55], false, false, false),
    					listen_dev(input, "input", /*input_handler_4*/ ctx[56], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_4*/ ctx[57], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_4*/ ctx[58], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_4*/ ctx[59], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[168])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "file" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*invalid*/ 1024 && { invalid: /*invalid*/ ctx[10] },
    				dirty[0] & /*multiple*/ 4096 && { multiple: /*multiple*/ ctx[12] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*valid*/ 131072 && { valid: /*valid*/ ctx[17] }
    			]));
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_4*/ ctx[169](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(174:28) ",
    		ctx
    	});

    	return block;
    }

    // (153:29) 
    function create_if_block_6(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "email" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ multiple: /*multiple*/ ctx[12] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ size: /*size*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 153, 4, 3356);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_3*/ ctx[167](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_3*/ ctx[46], false, false, false),
    					listen_dev(input, "change", /*change_handler_3*/ ctx[47], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_3*/ ctx[48], false, false, false),
    					listen_dev(input, "input", /*input_handler_3*/ ctx[49], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_3*/ ctx[50], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_3*/ ctx[51], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_3*/ ctx[52], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_3*/ ctx[166])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "email" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*multiple*/ 4096 && { multiple: /*multiple*/ ctx[12] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
    			]));

    			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_3*/ ctx[167](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(153:29) ",
    		ctx
    	});

    	return block;
    }

    // (134:29) 
    function create_if_block_5(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "color" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 134, 4, 3026);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_2*/ ctx[165](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_2*/ ctx[39], false, false, false),
    					listen_dev(input, "change", /*change_handler_2*/ ctx[40], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_2*/ ctx[41], false, false, false),
    					listen_dev(input, "input", /*input_handler_2*/ ctx[42], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_2*/ ctx[43], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_2*/ ctx[44], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_2*/ ctx[45], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_2*/ ctx[164])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "color" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] }
    			]));

    			if (dirty[0] & /*value*/ 64) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_2*/ ctx[165](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(134:29) ",
    		ctx
    	});

    	return block;
    }

    // (114:32) 
    function create_if_block_4$1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "password" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ size: /*size*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 114, 4, 2680);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding_1*/ ctx[163](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler_1*/ ctx[32], false, false, false),
    					listen_dev(input, "change", /*change_handler_1*/ ctx[33], false, false, false),
    					listen_dev(input, "focus", /*focus_handler_1*/ ctx[34], false, false, false),
    					listen_dev(input, "input", /*input_handler_1*/ ctx[35], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler_1*/ ctx[36], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler_1*/ ctx[37], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler_1*/ ctx[38], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[162])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "password" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
    			]));

    			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding_1*/ ctx[163](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(114:32) ",
    		ctx
    	});

    	return block;
    }

    // (94:2) {#if type === 'text'}
    function create_if_block_3$1(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		/*$$restProps*/ ctx[21],
    		{ class: /*classes*/ ctx[18] },
    		{ type: "text" },
    		{ disabled: /*disabled*/ ctx[8] },
    		{ name: /*name*/ ctx[13] },
    		{ placeholder: /*placeholder*/ ctx[14] },
    		{ readOnly: /*readonly*/ ctx[15] },
    		{ size: /*size*/ ctx[1] }
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$p, 94, 4, 2335);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			set_input_value(input, /*value*/ ctx[6]);
    			/*input_binding*/ ctx[161](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "blur", /*blur_handler*/ ctx[25], false, false, false),
    					listen_dev(input, "change", /*change_handler*/ ctx[26], false, false, false),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[27], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[28], false, false, false),
    					listen_dev(input, "keydown", /*keydown_handler*/ ctx[29], false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler*/ ctx[30], false, false, false),
    					listen_dev(input, "keyup", /*keyup_handler*/ ctx[31], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[160])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty[0] & /*$$restProps*/ 2097152 && /*$$restProps*/ ctx[21],
    				dirty[0] & /*classes*/ 262144 && { class: /*classes*/ ctx[18] },
    				{ type: "text" },
    				dirty[0] & /*disabled*/ 256 && { disabled: /*disabled*/ ctx[8] },
    				dirty[0] & /*name*/ 8192 && { name: /*name*/ ctx[13] },
    				dirty[0] & /*placeholder*/ 16384 && { placeholder: /*placeholder*/ ctx[14] },
    				dirty[0] & /*readonly*/ 32768 && { readOnly: /*readonly*/ ctx[15] },
    				dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] }
    			]));

    			if (dirty[0] & /*value*/ 64 && input.value !== /*value*/ ctx[6]) {
    				set_input_value(input, /*value*/ ctx[6]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[161](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(94:2) {#if type === 'text'}",
    		ctx
    	});

    	return block;
    }

    // (523:0) {#if feedback}
    function create_if_block$5(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$3, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (show_if == null || dirty[0] & /*feedback*/ 512) show_if = !!Array.isArray(/*feedback*/ ctx[9]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1, -1, -1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(523:0) {#if feedback}",
    		ctx
    	});

    	return block;
    }

    // (528:2) {:else}
    function create_else_block$3(ctx) {
    	let formfeedback;
    	let current;

    	formfeedback = new FormFeedback({
    			props: {
    				valid: /*valid*/ ctx[17],
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfeedback.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfeedback, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formfeedback_changes = {};
    			if (dirty[0] & /*valid*/ 131072) formfeedback_changes.valid = /*valid*/ ctx[17];

    			if (dirty[0] & /*feedback*/ 512 | dirty[6] & /*$$scope*/ 8388608) {
    				formfeedback_changes.$$scope = { dirty, ctx };
    			}

    			formfeedback.$set(formfeedback_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfeedback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfeedback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfeedback, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(528:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (524:2) {#if Array.isArray(feedback)}
    function create_if_block_1$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*feedback*/ ctx[9];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*valid, feedback*/ 131584) {
    				each_value = /*feedback*/ ctx[9];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(524:2) {#if Array.isArray(feedback)}",
    		ctx
    	});

    	return block;
    }

    // (529:4) <FormFeedback {valid}>
    function create_default_slot_1$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*feedback*/ ctx[9]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*feedback*/ 512) set_data_dev(t, /*feedback*/ ctx[9]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(529:4) <FormFeedback {valid}>",
    		ctx
    	});

    	return block;
    }

    // (526:6) <FormFeedback {valid}>
    function create_default_slot$i(ctx) {
    	let t_value = /*msg*/ ctx[210] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*feedback*/ 512 && t_value !== (t_value = /*msg*/ ctx[210] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(526:6) <FormFeedback {valid}>",
    		ctx
    	});

    	return block;
    }

    // (525:4) {#each feedback as msg}
    function create_each_block$1(ctx) {
    	let formfeedback;
    	let current;

    	formfeedback = new FormFeedback({
    			props: {
    				valid: /*valid*/ ctx[17],
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formfeedback.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(formfeedback, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formfeedback_changes = {};
    			if (dirty[0] & /*valid*/ 131072) formfeedback_changes.valid = /*valid*/ ctx[17];

    			if (dirty[0] & /*feedback*/ 512 | dirty[6] & /*$$scope*/ 8388608) {
    				formfeedback_changes.$$scope = { dirty, ctx };
    			}

    			formfeedback.$set(formfeedback_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formfeedback.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formfeedback.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formfeedback, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(525:4) {#each feedback as msg}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_if_block_21, create_if_block_22];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[19] === 'input') return 0;
    		if (/*tag*/ ctx[19] === 'textarea') return 1;
    		if (/*tag*/ ctx[19] === 'select' && !/*multiple*/ ctx[12]) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block1 = /*feedback*/ ctx[9] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (/*feedback*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*feedback*/ 512) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"class","bsSize","checked","color","disabled","feedback","files","group","inner","invalid","label","multiple","name","placeholder","plaintext","readonly","size","type","valid","value"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Input', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { bsSize = undefined } = $$props;
    	let { checked = false } = $$props;
    	let { color = undefined } = $$props;
    	let { disabled = undefined } = $$props;
    	let { feedback = undefined } = $$props;
    	let { files = undefined } = $$props;
    	let { group = undefined } = $$props;
    	let { inner = undefined } = $$props;
    	let { invalid = false } = $$props;
    	let { label = undefined } = $$props;
    	let { multiple = undefined } = $$props;
    	let { name = '' } = $$props;
    	let { placeholder = '' } = $$props;
    	let { plaintext = false } = $$props;
    	let { readonly = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { type = 'text' } = $$props;
    	let { valid = false } = $$props;
    	let { value = '' } = $$props;
    	let classes;
    	let tag;

    	const handleInput = event => {
    		$$invalidate(6, value = event.target.value);
    	};

    	function blur_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_2(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_3(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_4(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_6(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_7(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_8(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_9(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_10(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_11(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_12(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_13(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_14(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_15(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_16(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_17(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_18(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function blur_handler_20(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_20(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_19(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_1() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_2() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_3() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_3($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_change_handler() {
    		files = this.files;
    		value = this.value;
    		$$invalidate(3, files);
    		$$invalidate(6, value);
    	}

    	function input_binding_4($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function formcheck_checked_binding(value) {
    		checked = value;
    		$$invalidate(2, checked);
    	}

    	function formcheck_inner_binding(value) {
    		inner = value;
    		$$invalidate(5, inner);
    	}

    	function formcheck_group_binding(value) {
    		group = value;
    		$$invalidate(4, group);
    	}

    	function formcheck_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(6, value);
    	}

    	function blur_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function change_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keydown_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keypress_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function keyup_handler_5(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_input_handler_4() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_5($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_5() {
    		value = to_number(this.value);
    		$$invalidate(6, value);
    	}

    	function input_binding_6($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_6() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_7($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_7() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_8($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_8() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_9($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_9() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_10($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_10() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_11($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_11() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_12($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_change_input_handler() {
    		value = to_number(this.value);
    		$$invalidate(6, value);
    	}

    	function input_binding_13($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_12() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_14($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_13() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_15($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function input_input_handler_14() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function input_binding_16($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function textarea_input_handler() {
    		value = this.value;
    		$$invalidate(6, value);
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	function select_change_handler() {
    		value = select_value(this);
    		$$invalidate(6, value);
    	}

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			inner = $$value;
    			$$invalidate(5, inner);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(7, className = $$new_props.class);
    		if ('bsSize' in $$new_props) $$invalidate(0, bsSize = $$new_props.bsSize);
    		if ('checked' in $$new_props) $$invalidate(2, checked = $$new_props.checked);
    		if ('color' in $$new_props) $$invalidate(22, color = $$new_props.color);
    		if ('disabled' in $$new_props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ('feedback' in $$new_props) $$invalidate(9, feedback = $$new_props.feedback);
    		if ('files' in $$new_props) $$invalidate(3, files = $$new_props.files);
    		if ('group' in $$new_props) $$invalidate(4, group = $$new_props.group);
    		if ('inner' in $$new_props) $$invalidate(5, inner = $$new_props.inner);
    		if ('invalid' in $$new_props) $$invalidate(10, invalid = $$new_props.invalid);
    		if ('label' in $$new_props) $$invalidate(11, label = $$new_props.label);
    		if ('multiple' in $$new_props) $$invalidate(12, multiple = $$new_props.multiple);
    		if ('name' in $$new_props) $$invalidate(13, name = $$new_props.name);
    		if ('placeholder' in $$new_props) $$invalidate(14, placeholder = $$new_props.placeholder);
    		if ('plaintext' in $$new_props) $$invalidate(23, plaintext = $$new_props.plaintext);
    		if ('readonly' in $$new_props) $$invalidate(15, readonly = $$new_props.readonly);
    		if ('size' in $$new_props) $$invalidate(1, size = $$new_props.size);
    		if ('type' in $$new_props) $$invalidate(16, type = $$new_props.type);
    		if ('valid' in $$new_props) $$invalidate(17, valid = $$new_props.valid);
    		if ('value' in $$new_props) $$invalidate(6, value = $$new_props.value);
    		if ('$$scope' in $$new_props) $$invalidate(209, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		FormCheck,
    		FormFeedback,
    		classnames,
    		className,
    		bsSize,
    		checked,
    		color,
    		disabled,
    		feedback,
    		files,
    		group,
    		inner,
    		invalid,
    		label,
    		multiple,
    		name,
    		placeholder,
    		plaintext,
    		readonly,
    		size,
    		type,
    		valid,
    		value,
    		classes,
    		tag,
    		handleInput
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(7, className = $$new_props.className);
    		if ('bsSize' in $$props) $$invalidate(0, bsSize = $$new_props.bsSize);
    		if ('checked' in $$props) $$invalidate(2, checked = $$new_props.checked);
    		if ('color' in $$props) $$invalidate(22, color = $$new_props.color);
    		if ('disabled' in $$props) $$invalidate(8, disabled = $$new_props.disabled);
    		if ('feedback' in $$props) $$invalidate(9, feedback = $$new_props.feedback);
    		if ('files' in $$props) $$invalidate(3, files = $$new_props.files);
    		if ('group' in $$props) $$invalidate(4, group = $$new_props.group);
    		if ('inner' in $$props) $$invalidate(5, inner = $$new_props.inner);
    		if ('invalid' in $$props) $$invalidate(10, invalid = $$new_props.invalid);
    		if ('label' in $$props) $$invalidate(11, label = $$new_props.label);
    		if ('multiple' in $$props) $$invalidate(12, multiple = $$new_props.multiple);
    		if ('name' in $$props) $$invalidate(13, name = $$new_props.name);
    		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$new_props.placeholder);
    		if ('plaintext' in $$props) $$invalidate(23, plaintext = $$new_props.plaintext);
    		if ('readonly' in $$props) $$invalidate(15, readonly = $$new_props.readonly);
    		if ('size' in $$props) $$invalidate(1, size = $$new_props.size);
    		if ('type' in $$props) $$invalidate(16, type = $$new_props.type);
    		if ('valid' in $$props) $$invalidate(17, valid = $$new_props.valid);
    		if ('value' in $$props) $$invalidate(6, value = $$new_props.value);
    		if ('classes' in $$props) $$invalidate(18, classes = $$new_props.classes);
    		if ('tag' in $$props) $$invalidate(19, tag = $$new_props.tag);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*type, color, plaintext, size, className, invalid, valid, bsSize*/ 12780675) {
    			{
    				const isNotaNumber = new RegExp('\\D', 'g');
    				let isBtn = false;
    				let formControlClass = 'form-control';
    				$$invalidate(19, tag = 'input');

    				switch (type) {
    					case 'color':
    						formControlClass = `form-control form-control-color`;
    						break;
    					case 'range':
    						formControlClass = 'form-range';
    						break;
    					case 'select':
    						formControlClass = `form-select`;
    						$$invalidate(19, tag = 'select');
    						break;
    					case 'textarea':
    						$$invalidate(19, tag = 'textarea');
    						break;
    					case 'button':
    					case 'reset':
    					case 'submit':
    						formControlClass = `btn btn-${color || 'secondary'}`;
    						isBtn = true;
    						break;
    					case 'hidden':
    					case 'image':
    						formControlClass = undefined;
    						break;
    					default:
    						formControlClass = 'form-control';
    						$$invalidate(19, tag = 'input');
    				}

    				if (plaintext) {
    					formControlClass = `${formControlClass}-plaintext`;
    					$$invalidate(19, tag = 'input');
    				}

    				if (size && isNotaNumber.test(size)) {
    					console.warn('Please use the prop "bsSize" instead of the "size" to bootstrap\'s input sizing.');
    					$$invalidate(0, bsSize = size);
    					$$invalidate(1, size = undefined);
    				}

    				$$invalidate(18, classes = classnames(className, formControlClass, {
    					'is-invalid': invalid,
    					'is-valid': valid,
    					[`form-control-${bsSize}`]: bsSize && !isBtn,
    					[`btn-${bsSize}`]: bsSize && isBtn
    				}));
    			}
    		}
    	};

    	return [
    		bsSize,
    		size,
    		checked,
    		files,
    		group,
    		inner,
    		value,
    		className,
    		disabled,
    		feedback,
    		invalid,
    		label,
    		multiple,
    		name,
    		placeholder,
    		readonly,
    		type,
    		valid,
    		classes,
    		tag,
    		handleInput,
    		$$restProps,
    		color,
    		plaintext,
    		slots,
    		blur_handler,
    		change_handler,
    		focus_handler,
    		input_handler,
    		keydown_handler,
    		keypress_handler,
    		keyup_handler,
    		blur_handler_1,
    		change_handler_1,
    		focus_handler_1,
    		input_handler_1,
    		keydown_handler_1,
    		keypress_handler_1,
    		keyup_handler_1,
    		blur_handler_2,
    		change_handler_2,
    		focus_handler_2,
    		input_handler_2,
    		keydown_handler_2,
    		keypress_handler_2,
    		keyup_handler_2,
    		blur_handler_3,
    		change_handler_3,
    		focus_handler_3,
    		input_handler_3,
    		keydown_handler_3,
    		keypress_handler_3,
    		keyup_handler_3,
    		blur_handler_4,
    		change_handler_4,
    		focus_handler_4,
    		input_handler_4,
    		keydown_handler_4,
    		keypress_handler_4,
    		keyup_handler_4,
    		blur_handler_6,
    		change_handler_6,
    		focus_handler_6,
    		input_handler_6,
    		keydown_handler_6,
    		keypress_handler_6,
    		keyup_handler_6,
    		blur_handler_7,
    		change_handler_7,
    		focus_handler_7,
    		input_handler_7,
    		keydown_handler_7,
    		keypress_handler_7,
    		keyup_handler_7,
    		blur_handler_8,
    		change_handler_8,
    		focus_handler_8,
    		input_handler_8,
    		keydown_handler_8,
    		keypress_handler_8,
    		keyup_handler_8,
    		blur_handler_9,
    		change_handler_9,
    		focus_handler_9,
    		input_handler_9,
    		keydown_handler_9,
    		keypress_handler_9,
    		keyup_handler_9,
    		blur_handler_10,
    		change_handler_10,
    		focus_handler_10,
    		input_handler_10,
    		keydown_handler_10,
    		keypress_handler_10,
    		keyup_handler_10,
    		blur_handler_11,
    		change_handler_11,
    		focus_handler_11,
    		input_handler_11,
    		keydown_handler_11,
    		keypress_handler_11,
    		keyup_handler_11,
    		blur_handler_12,
    		change_handler_12,
    		focus_handler_12,
    		input_handler_12,
    		keydown_handler_12,
    		keypress_handler_12,
    		keyup_handler_12,
    		blur_handler_13,
    		change_handler_13,
    		focus_handler_13,
    		input_handler_13,
    		keydown_handler_13,
    		keypress_handler_13,
    		keyup_handler_13,
    		blur_handler_14,
    		change_handler_14,
    		focus_handler_14,
    		input_handler_14,
    		keydown_handler_14,
    		keypress_handler_14,
    		keyup_handler_14,
    		blur_handler_15,
    		change_handler_15,
    		focus_handler_15,
    		input_handler_15,
    		keydown_handler_15,
    		keypress_handler_15,
    		keyup_handler_15,
    		blur_handler_16,
    		change_handler_16,
    		focus_handler_16,
    		input_handler_16,
    		keydown_handler_16,
    		keypress_handler_16,
    		keyup_handler_16,
    		blur_handler_17,
    		change_handler_17,
    		focus_handler_17,
    		input_handler_17,
    		keydown_handler_17,
    		keypress_handler_17,
    		keyup_handler_17,
    		blur_handler_18,
    		focus_handler_18,
    		keydown_handler_18,
    		keypress_handler_18,
    		keyup_handler_18,
    		blur_handler_19,
    		change_handler_18,
    		focus_handler_19,
    		input_handler_18,
    		keydown_handler_19,
    		keypress_handler_19,
    		keyup_handler_19,
    		blur_handler_20,
    		change_handler_19,
    		focus_handler_20,
    		input_handler_19,
    		input_input_handler,
    		input_binding,
    		input_input_handler_1,
    		input_binding_1,
    		input_input_handler_2,
    		input_binding_2,
    		input_input_handler_3,
    		input_binding_3,
    		input_change_handler,
    		input_binding_4,
    		formcheck_checked_binding,
    		formcheck_inner_binding,
    		formcheck_group_binding,
    		formcheck_value_binding,
    		blur_handler_5,
    		change_handler_5,
    		focus_handler_5,
    		input_handler_5,
    		keydown_handler_5,
    		keypress_handler_5,
    		keyup_handler_5,
    		input_input_handler_4,
    		input_binding_5,
    		input_input_handler_5,
    		input_binding_6,
    		input_input_handler_6,
    		input_binding_7,
    		input_input_handler_7,
    		input_binding_8,
    		input_input_handler_8,
    		input_binding_9,
    		input_input_handler_9,
    		input_binding_10,
    		input_input_handler_10,
    		input_binding_11,
    		input_input_handler_11,
    		input_binding_12,
    		input_change_input_handler,
    		input_binding_13,
    		input_input_handler_12,
    		input_binding_14,
    		input_input_handler_13,
    		input_binding_15,
    		input_input_handler_14,
    		input_binding_16,
    		textarea_input_handler,
    		textarea_binding,
    		select_change_handler,
    		select_binding,
    		$$scope
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$r,
    			create_fragment$r,
    			safe_not_equal,
    			{
    				class: 7,
    				bsSize: 0,
    				checked: 2,
    				color: 22,
    				disabled: 8,
    				feedback: 9,
    				files: 3,
    				group: 4,
    				inner: 5,
    				invalid: 10,
    				label: 11,
    				multiple: 12,
    				name: 13,
    				placeholder: 14,
    				plaintext: 23,
    				readonly: 15,
    				size: 1,
    				type: 16,
    				valid: 17,
    				value: 6
    			},
    			null,
    			[-1, -1, -1, -1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get class() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bsSize() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bsSize(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get feedback() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set feedback(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get files() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set files(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inner() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inner(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get plaintext() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set plaintext(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get readonly() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set readonly(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Label.svelte generated by Svelte v3.44.0 */
    const file$o = "node_modules/sveltestrap/src/Label.svelte";

    function create_fragment$q(ctx) {
    	let label;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	let label_levels = [
    		/*$$restProps*/ ctx[2],
    		{ class: /*classes*/ ctx[1] },
    		{ for: /*fore*/ ctx[0] }
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (default_slot) default_slot.c();
    			set_attributes(label, label_data);
    			add_location(label, file$o, 71, 0, 1672);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (default_slot) {
    				default_slot.m(label, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[14],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2],
    				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
    				(!current || dirty & /*fore*/ 1) && { for: /*fore*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","hidden","check","size","for","xs","sm","md","lg","xl","xxl","widths"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Label', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { hidden = false } = $$props;
    	let { check = false } = $$props;
    	let { size = '' } = $$props;
    	let { for: fore = null } = $$props;
    	let { xs = '' } = $$props;
    	let { sm = '' } = $$props;
    	let { md = '' } = $$props;
    	let { lg = '' } = $$props;
    	let { xl = '' } = $$props;
    	let { xxl = '' } = $$props;
    	const colWidths = { xs, sm, md, lg, xl, xxl };
    	let { widths = Object.keys(colWidths) } = $$props;
    	const colClasses = [];

    	widths.forEach(colWidth => {
    		let columnProp = $$props[colWidth];

    		if (!columnProp && columnProp !== '') {
    			return;
    		}

    		const isXs = colWidth === 'xs';
    		let colClass;

    		if (isObject(columnProp)) {
    			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
    			colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

    			colClasses.push(classnames({
    				[colClass]: columnProp.size || columnProp.size === '',
    				[`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
    				[`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
    			}));
    		} else {
    			colClass = getColumnSizeClass(isXs, colWidth, columnProp);
    			colClasses.push(colClass);
    		}
    	});

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('hidden' in $$new_props) $$invalidate(4, hidden = $$new_props.hidden);
    		if ('check' in $$new_props) $$invalidate(5, check = $$new_props.check);
    		if ('size' in $$new_props) $$invalidate(6, size = $$new_props.size);
    		if ('for' in $$new_props) $$invalidate(0, fore = $$new_props.for);
    		if ('xs' in $$new_props) $$invalidate(7, xs = $$new_props.xs);
    		if ('sm' in $$new_props) $$invalidate(8, sm = $$new_props.sm);
    		if ('md' in $$new_props) $$invalidate(9, md = $$new_props.md);
    		if ('lg' in $$new_props) $$invalidate(10, lg = $$new_props.lg);
    		if ('xl' in $$new_props) $$invalidate(11, xl = $$new_props.xl);
    		if ('xxl' in $$new_props) $$invalidate(12, xxl = $$new_props.xxl);
    		if ('widths' in $$new_props) $$invalidate(13, widths = $$new_props.widths);
    		if ('$$scope' in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		getColumnSizeClass,
    		isObject,
    		className,
    		hidden,
    		check,
    		size,
    		fore,
    		xs,
    		sm,
    		md,
    		lg,
    		xl,
    		xxl,
    		colWidths,
    		widths,
    		colClasses,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('hidden' in $$props) $$invalidate(4, hidden = $$new_props.hidden);
    		if ('check' in $$props) $$invalidate(5, check = $$new_props.check);
    		if ('size' in $$props) $$invalidate(6, size = $$new_props.size);
    		if ('fore' in $$props) $$invalidate(0, fore = $$new_props.fore);
    		if ('xs' in $$props) $$invalidate(7, xs = $$new_props.xs);
    		if ('sm' in $$props) $$invalidate(8, sm = $$new_props.sm);
    		if ('md' in $$props) $$invalidate(9, md = $$new_props.md);
    		if ('lg' in $$props) $$invalidate(10, lg = $$new_props.lg);
    		if ('xl' in $$props) $$invalidate(11, xl = $$new_props.xl);
    		if ('xxl' in $$props) $$invalidate(12, xxl = $$new_props.xxl);
    		if ('widths' in $$props) $$invalidate(13, widths = $$new_props.widths);
    		if ('classes' in $$props) $$invalidate(1, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, hidden, check, size*/ 120) {
    			$$invalidate(1, classes = classnames(className, hidden ? 'visually-hidden' : false, check ? 'form-check-label' : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? 'col-form-label' : 'form-label'));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		fore,
    		classes,
    		$$restProps,
    		className,
    		hidden,
    		check,
    		size,
    		xs,
    		sm,
    		md,
    		lg,
    		xl,
    		xxl,
    		widths,
    		$$scope,
    		slots
    	];
    }

    class Label extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			class: 3,
    			hidden: 4,
    			check: 5,
    			size: 6,
    			for: 0,
    			xs: 7,
    			sm: 8,
    			md: 9,
    			lg: 10,
    			xl: 11,
    			xxl: 12,
    			widths: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Label",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get class() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get check() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set check(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get for() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set for(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xs() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xs(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sm() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sm(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get md() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set md(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lg() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lg(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xl() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xl(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get xxl() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set xxl(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get widths() {
    		throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set widths(value) {
    		throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/ModalBackdrop.svelte generated by Svelte v3.44.0 */
    const file$n = "node_modules/sveltestrap/src/ModalBackdrop.svelte";

    // (12:0) {#if isOpen}
    function create_if_block$4(ctx) {
    	let div;
    	let div_intro;
    	let div_outro;
    	let current;
    	let mounted;
    	let dispose;
    	let div_levels = [/*$$restProps*/ ctx[3], { class: /*classes*/ ctx[2] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_attributes(div, div_data);
    			toggle_class(div, "fade", /*fade*/ ctx[1]);
    			add_location(div, file$n, 12, 2, 350);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] }
    			]));

    			toggle_class(div, "fade", /*fade*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, backdropIn, {});
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, backdropOut, {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_outro) div_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(12:0) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*isOpen*/ ctx[0] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isOpen*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isOpen*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","isOpen","fade"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModalBackdrop', slots, []);
    	let { class: className = '' } = $$props;
    	let { isOpen = false } = $$props;
    	let { fade = true } = $$props;

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(4, className = $$new_props.class);
    		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('fade' in $$new_props) $$invalidate(1, fade = $$new_props.fade);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		backdropIn,
    		backdropOut,
    		className,
    		isOpen,
    		fade,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(4, className = $$new_props.className);
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ('fade' in $$props) $$invalidate(1, fade = $$new_props.fade);
    		if ('classes' in $$props) $$invalidate(2, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 16) {
    			$$invalidate(2, classes = classnames(className, 'modal-backdrop'));
    		}
    	};

    	return [isOpen, fade, classes, $$restProps, className, click_handler];
    }

    class ModalBackdrop extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { class: 4, isOpen: 0, fade: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalBackdrop",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get class() {
    		throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fade() {
    		throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fade(value) {
    		throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/ModalBody.svelte generated by Svelte v3.44.0 */
    const file$m = "node_modules/sveltestrap/src/ModalBody.svelte";

    function create_fragment$o(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$m, 9, 0, 165);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModalBody', slots, ['default']);
    	let { class: className = '' } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classnames, className, classes });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 4) {
    			$$invalidate(0, classes = classnames(className, 'modal-body'));
    		}
    	};

    	return [classes, $$restProps, className, $$scope, slots];
    }

    class ModalBody extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { class: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalBody",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get class() {
    		throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/ModalHeader.svelte generated by Svelte v3.44.0 */
    const file$l = "node_modules/sveltestrap/src/ModalHeader.svelte";
    const get_close_slot_changes = dirty => ({});
    const get_close_slot_context = ctx => ({});

    // (17:4) {:else}
    function create_else_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(17:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (15:4) {#if children}
    function create_if_block_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*children*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*children*/ 4) set_data_dev(t, /*children*/ ctx[2]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(15:4) {#if children}",
    		ctx
    	});

    	return block;
    }

    // (22:4) {#if typeof toggle === 'function'}
    function create_if_block$3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "btn-close");
    			attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
    			add_location(button, file$l, 22, 6, 488);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*toggle*/ ctx[0])) /*toggle*/ ctx[0].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*closeAriaLabel*/ 2) {
    				attr_dev(button, "aria-label", /*closeAriaLabel*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(22:4) {#if typeof toggle === 'function'}",
    		ctx
    	});

    	return block;
    }

    // (21:21)      
    function fallback_block(ctx) {
    	let if_block_anchor;
    	let if_block = typeof /*toggle*/ ctx[0] === 'function' && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (typeof /*toggle*/ ctx[0] === 'function') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(21:21)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div;
    	let h5;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block_1$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*children*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const close_slot_template = /*#slots*/ ctx[7].close;
    	const close_slot = create_slot(close_slot_template, ctx, /*$$scope*/ ctx[6], get_close_slot_context);
    	const close_slot_or_fallback = close_slot || fallback_block(ctx);
    	let div_levels = [/*$$restProps*/ ctx[4], { class: /*classes*/ ctx[3] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h5 = element("h5");
    			if_block.c();
    			t = space();
    			if (close_slot_or_fallback) close_slot_or_fallback.c();
    			attr_dev(h5, "class", "modal-title");
    			add_location(h5, file$l, 13, 2, 315);
    			set_attributes(div, div_data);
    			add_location(div, file$l, 12, 0, 274);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h5);
    			if_blocks[current_block_type_index].m(h5, null);
    			append_dev(div, t);

    			if (close_slot_or_fallback) {
    				close_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(h5, null);
    			}

    			if (close_slot) {
    				if (close_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						close_slot,
    						close_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(close_slot_template, /*$$scope*/ ctx[6], dirty, get_close_slot_changes),
    						get_close_slot_context
    					);
    				}
    			} else {
    				if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & /*closeAriaLabel, toggle*/ 3)) {
    					close_slot_or_fallback.p(ctx, !current ? -1 : dirty);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4],
    				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(close_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(close_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			if (close_slot_or_fallback) close_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","toggle","closeAriaLabel","children"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ModalHeader', slots, ['default','close']);
    	let { class: className = '' } = $$props;
    	let { toggle = undefined } = $$props;
    	let { closeAriaLabel = 'Close' } = $$props;
    	let { children = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(5, className = $$new_props.class);
    		if ('toggle' in $$new_props) $$invalidate(0, toggle = $$new_props.toggle);
    		if ('closeAriaLabel' in $$new_props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ('children' in $$new_props) $$invalidate(2, children = $$new_props.children);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		toggle,
    		closeAriaLabel,
    		children,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(5, className = $$new_props.className);
    		if ('toggle' in $$props) $$invalidate(0, toggle = $$new_props.toggle);
    		if ('closeAriaLabel' in $$props) $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    		if ('children' in $$props) $$invalidate(2, children = $$new_props.children);
    		if ('classes' in $$props) $$invalidate(3, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className*/ 32) {
    			$$invalidate(3, classes = classnames(className, 'modal-header'));
    		}
    	};

    	return [
    		toggle,
    		closeAriaLabel,
    		children,
    		classes,
    		$$restProps,
    		className,
    		$$scope,
    		slots
    	];
    }

    class ModalHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			class: 5,
    			toggle: 0,
    			closeAriaLabel: 1,
    			children: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalHeader",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get class() {
    		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeAriaLabel() {
    		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeAriaLabel(value) {
    		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get children() {
    		throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set children(value) {
    		throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Portal.svelte generated by Svelte v3.44.0 */
    const file$k = "node_modules/sveltestrap/src/Portal.svelte";

    function create_fragment$m(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	let div_levels = [/*$$restProps*/ ctx[1]];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$k, 18, 0, 346);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[4](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Portal', slots, ['default']);
    	let ref;
    	let portal;

    	onMount(() => {
    		portal = document.createElement('div');
    		document.body.appendChild(portal);
    		portal.appendChild(ref);
    	});

    	onDestroy(() => {
    		if (typeof document !== 'undefined') {
    			document.body.removeChild(portal);
    		}
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ onMount, onDestroy, ref, portal });

    	$$self.$inject_state = $$new_props => {
    		if ('ref' in $$props) $$invalidate(0, ref = $$new_props.ref);
    		if ('portal' in $$props) portal = $$new_props.portal;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ref, $$restProps, $$scope, slots, div_binding];
    }

    class Portal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Portal",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* node_modules/sveltestrap/src/Modal.svelte generated by Svelte v3.44.0 */

    const file$j = "node_modules/sveltestrap/src/Modal.svelte";
    const get_external_slot_changes = dirty => ({});
    const get_external_slot_context = ctx => ({});

    // (216:0) {#if _isMounted}
    function create_if_block_1$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*outer*/ ctx[13];

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty[0] & /*wrapClassName, $$restProps, labelledBy, modalClassName, fade, staticModal, classes, _dialog, contentClassName, body, toggle, header, isOpen*/ 1071039 | dirty[1] & /*$$scope*/ 8) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*outer*/ ctx[13])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(216:0) {#if _isMounted}",
    		ctx
    	});

    	return block;
    }

    // (219:6) {#if isOpen}
    function create_if_block_2$1(ctx) {
    	let div2;
    	let t0;
    	let div1;
    	let div0;
    	let t1;
    	let current_block_type_index;
    	let if_block1;
    	let div0_class_value;
    	let div2_class_value;
    	let div2_intro;
    	let div2_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const external_slot_template = /*#slots*/ ctx[30].external;
    	const external_slot = create_slot(external_slot_template, ctx, /*$$scope*/ ctx[34], get_external_slot_context);
    	let if_block0 = /*header*/ ctx[3] && create_if_block_4(ctx);
    	const if_block_creators = [create_if_block_3, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*body*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if (external_slot) external_slot.c();
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if_block1.c();
    			attr_dev(div0, "class", div0_class_value = classnames('modal-content', /*contentClassName*/ ctx[9]));
    			add_location(div0, file$j, 237, 12, 5557);
    			attr_dev(div1, "class", /*classes*/ ctx[14]);
    			attr_dev(div1, "role", "document");
    			add_location(div1, file$j, 236, 10, 5487);
    			attr_dev(div2, "arialabelledby", /*labelledBy*/ ctx[5]);

    			attr_dev(div2, "class", div2_class_value = classnames('modal', /*modalClassName*/ ctx[8], {
    				fade: /*fade*/ ctx[10],
    				'position-static': /*staticModal*/ ctx[0]
    			}));

    			attr_dev(div2, "role", "dialog");
    			add_location(div2, file$j, 219, 8, 4921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);

    			if (external_slot) {
    				external_slot.m(div2, null);
    			}

    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t1);
    			if_blocks[current_block_type_index].m(div0, null);
    			/*div1_binding*/ ctx[31](div1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "introstart", /*introstart_handler*/ ctx[32], false, false, false),
    					listen_dev(div2, "introend", /*onModalOpened*/ ctx[17], false, false, false),
    					listen_dev(div2, "outrostart", /*outrostart_handler*/ ctx[33], false, false, false),
    					listen_dev(div2, "outroend", /*onModalClosed*/ ctx[18], false, false, false),
    					listen_dev(div2, "click", /*handleBackdropClick*/ ctx[16], false, false, false),
    					listen_dev(div2, "mousedown", /*handleBackdropMouseDown*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (external_slot) {
    				if (external_slot.p && (!current || dirty[1] & /*$$scope*/ 8)) {
    					update_slot_base(
    						external_slot,
    						external_slot_template,
    						ctx,
    						/*$$scope*/ ctx[34],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
    						: get_slot_changes(external_slot_template, /*$$scope*/ ctx[34], dirty, get_external_slot_changes),
    						get_external_slot_context
    					);
    				}
    			}

    			if (/*header*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*header*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div0, null);
    			}

    			if (!current || dirty[0] & /*contentClassName*/ 512 && div0_class_value !== (div0_class_value = classnames('modal-content', /*contentClassName*/ ctx[9]))) {
    				attr_dev(div0, "class", div0_class_value);
    			}

    			if (!current || dirty[0] & /*classes*/ 16384) {
    				attr_dev(div1, "class", /*classes*/ ctx[14]);
    			}

    			if (!current || dirty[0] & /*labelledBy*/ 32) {
    				attr_dev(div2, "arialabelledby", /*labelledBy*/ ctx[5]);
    			}

    			if (!current || dirty[0] & /*modalClassName, fade, staticModal*/ 1281 && div2_class_value !== (div2_class_value = classnames('modal', /*modalClassName*/ ctx[8], {
    				fade: /*fade*/ ctx[10],
    				'position-static': /*staticModal*/ ctx[0]
    			}))) {
    				attr_dev(div2, "class", div2_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(external_slot, local);
    			transition_in(if_block0);
    			transition_in(if_block1);

    			add_render_callback(() => {
    				if (div2_outro) div2_outro.end(1);
    				div2_intro = create_in_transition(div2, modalIn, {});
    				div2_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(external_slot, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			if (div2_intro) div2_intro.invalidate();
    			div2_outro = create_out_transition(div2, modalOut, {});
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (external_slot) external_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			/*div1_binding*/ ctx[31](null);
    			if (detaching && div2_outro) div2_outro.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(219:6) {#if isOpen}",
    		ctx
    	});

    	return block;
    }

    // (239:14) {#if header}
    function create_if_block_4(ctx) {
    	let modalheader;
    	let current;

    	modalheader = new ModalHeader({
    			props: {
    				toggle: /*toggle*/ ctx[4],
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modalheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalheader_changes = {};
    			if (dirty[0] & /*toggle*/ 16) modalheader_changes.toggle = /*toggle*/ ctx[4];

    			if (dirty[0] & /*header*/ 8 | dirty[1] & /*$$scope*/ 8) {
    				modalheader_changes.$$scope = { dirty, ctx };
    			}

    			modalheader.$set(modalheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(239:14) {#if header}",
    		ctx
    	});

    	return block;
    }

    // (240:16) <ModalHeader {toggle}>
    function create_default_slot_3$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*header*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*header*/ 8) set_data_dev(t, /*header*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(240:16) <ModalHeader {toggle}>",
    		ctx
    	});

    	return block;
    }

    // (248:14) {:else}
    function create_else_block$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[30].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[34], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[34],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[34], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(248:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (244:14) {#if body}
    function create_if_block_3(ctx) {
    	let modalbody;
    	let current;

    	modalbody = new ModalBody({
    			props: {
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modalbody.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalbody, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalbody_changes = {};

    			if (dirty[1] & /*$$scope*/ 8) {
    				modalbody_changes.$$scope = { dirty, ctx };
    			}

    			modalbody.$set(modalbody_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalbody.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalbody.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalbody, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(244:14) {#if body}",
    		ctx
    	});

    	return block;
    }

    // (245:16) <ModalBody>
    function create_default_slot_2$f(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[30].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[34], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[34],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[34])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[34], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(245:16) <ModalBody>",
    		ctx
    	});

    	return block;
    }

    // (217:2) <svelte:component this={outer}>
    function create_default_slot_1$f(ctx) {
    	let div;
    	let current;
    	let if_block = /*isOpen*/ ctx[1] && create_if_block_2$1(ctx);

    	let div_levels = [
    		{ class: /*wrapClassName*/ ctx[7] },
    		{ tabindex: "-1" },
    		/*$$restProps*/ ctx[20]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$j, 217, 4, 4835);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*isOpen*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*isOpen*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*wrapClassName*/ 128) && { class: /*wrapClassName*/ ctx[7] },
    				{ tabindex: "-1" },
    				dirty[0] & /*$$restProps*/ 1048576 && /*$$restProps*/ ctx[20]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(217:2) <svelte:component this={outer}>",
    		ctx
    	});

    	return block;
    }

    // (258:0) {#if backdrop && !staticModal}
    function create_if_block$2(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*outer*/ ctx[13];

    	function switch_props(ctx) {
    		return {
    			props: {
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};

    			if (dirty[0] & /*fade, isOpen*/ 1026 | dirty[1] & /*$$scope*/ 8) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*outer*/ ctx[13])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(258:0) {#if backdrop && !staticModal}",
    		ctx
    	});

    	return block;
    }

    // (259:2) <svelte:component this={outer}>
    function create_default_slot$h(ctx) {
    	let modalbackdrop;
    	let current;

    	modalbackdrop = new ModalBackdrop({
    			props: {
    				fade: /*fade*/ ctx[10],
    				isOpen: /*isOpen*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modalbackdrop.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modalbackdrop, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modalbackdrop_changes = {};
    			if (dirty[0] & /*fade*/ 1024) modalbackdrop_changes.fade = /*fade*/ ctx[10];
    			if (dirty[0] & /*isOpen*/ 2) modalbackdrop_changes.isOpen = /*isOpen*/ ctx[1];
    			modalbackdrop.$set(modalbackdrop_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modalbackdrop.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modalbackdrop.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modalbackdrop, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(259:2) <svelte:component this={outer}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*_isMounted*/ ctx[11] && create_if_block_1$1(ctx);
    	let if_block1 = /*backdrop*/ ctx[6] && !/*staticModal*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*_isMounted*/ ctx[11]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*_isMounted*/ 2048) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*backdrop*/ ctx[6] && !/*staticModal*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*backdrop, staticModal*/ 65) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    let openCount = 0;
    const dialogBaseClass = 'modal-dialog';

    function instance$l($$self, $$props, $$invalidate) {
    	let classes;
    	let outer;

    	const omit_props_names = [
    		"class","static","isOpen","autoFocus","body","centered","container","fullscreen","header","scrollable","size","toggle","labelledBy","backdrop","wrapClassName","modalClassName","contentClassName","fade","unmountOnClose","returnFocusAfterClose"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['external','default']);
    	const dispatch = createEventDispatcher();
    	let { class: className = '' } = $$props;
    	let { static: staticModal = false } = $$props;
    	let { isOpen = false } = $$props;
    	let { autoFocus = true } = $$props;
    	let { body = false } = $$props;
    	let { centered = false } = $$props;
    	let { container = undefined } = $$props;
    	let { fullscreen = false } = $$props;
    	let { header = undefined } = $$props;
    	let { scrollable = false } = $$props;
    	let { size = '' } = $$props;
    	let { toggle = undefined } = $$props;
    	let { labelledBy = '' } = $$props;
    	let { backdrop = true } = $$props;
    	let { wrapClassName = '' } = $$props;
    	let { modalClassName = '' } = $$props;
    	let { contentClassName = '' } = $$props;
    	let { fade = true } = $$props;
    	let { unmountOnClose = true } = $$props;
    	let { returnFocusAfterClose = true } = $$props;
    	let hasOpened = false;
    	let _isMounted = false;
    	let _triggeringElement;
    	let _originalBodyPadding;
    	let _lastIsOpen = isOpen;
    	let _lastHasOpened = hasOpened;
    	let _dialog;
    	let _mouseDownElement;
    	let _removeEscListener;

    	onMount(() => {
    		if (isOpen) {
    			init();
    			hasOpened = true;
    		}

    		if (hasOpened && autoFocus) {
    			setFocus();
    		}
    	});

    	onDestroy(() => {
    		destroy();

    		if (hasOpened) {
    			close();
    		}
    	});

    	afterUpdate(() => {
    		if (isOpen && !_lastIsOpen) {
    			init();
    			hasOpened = true;
    		}

    		if (autoFocus && hasOpened && !_lastHasOpened) {
    			setFocus();
    		}

    		_lastIsOpen = isOpen;
    		_lastHasOpened = hasOpened;
    	});

    	function setFocus() {
    		if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === 'function') {
    			_dialog.parentNode.focus();
    		}
    	}

    	function init() {
    		try {
    			_triggeringElement = document.activeElement;
    		} catch(err) {
    			_triggeringElement = null;
    		}

    		if (!staticModal) {
    			_originalBodyPadding = getOriginalBodyPadding();
    			conditionallyUpdateScrollbar();

    			if (openCount === 0) {
    				document.body.className = classnames(document.body.className, 'modal-open');
    			}

    			++openCount;
    		}

    		$$invalidate(11, _isMounted = true);
    	}

    	function manageFocusAfterClose() {
    		if (_triggeringElement) {
    			if (typeof _triggeringElement.focus === 'function' && returnFocusAfterClose) {
    				_triggeringElement.focus();
    			}

    			_triggeringElement = null;
    		}
    	}

    	function destroy() {
    		manageFocusAfterClose();
    	}

    	function close() {
    		if (openCount <= 1) {
    			document.body.classList.remove('modal-open');
    		}

    		manageFocusAfterClose();
    		openCount = Math.max(0, openCount - 1);
    		setScrollbarWidth(_originalBodyPadding);
    	}

    	function handleBackdropClick(e) {
    		if (e.target === _mouseDownElement) {
    			e.stopPropagation();

    			if (!isOpen || !backdrop) {
    				return;
    			}

    			const backdropElem = _dialog ? _dialog.parentNode : null;

    			if (backdrop === true && backdropElem && e.target === backdropElem && toggle) {
    				toggle(e);
    			}
    		}
    	}

    	function onModalOpened() {
    		dispatch('open');

    		_removeEscListener = browserEvent(document, 'keydown', event => {
    			if (event.key && event.key === 'Escape') {
    				if (toggle && backdrop === true) toggle(event);
    			}
    		});
    	}

    	function onModalClosed() {
    		dispatch('close');

    		if (_removeEscListener) {
    			_removeEscListener();
    		}

    		if (unmountOnClose) {
    			destroy();
    		}

    		close();

    		if (_isMounted) {
    			hasOpened = false;
    		}

    		$$invalidate(11, _isMounted = false);
    	}

    	function handleBackdropMouseDown(e) {
    		_mouseDownElement = e.target;
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			_dialog = $$value;
    			$$invalidate(12, _dialog);
    		});
    	}

    	const introstart_handler = () => dispatch('opening');
    	const outrostart_handler = () => dispatch('closing');

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(21, className = $$new_props.class);
    		if ('static' in $$new_props) $$invalidate(0, staticModal = $$new_props.static);
    		if ('isOpen' in $$new_props) $$invalidate(1, isOpen = $$new_props.isOpen);
    		if ('autoFocus' in $$new_props) $$invalidate(22, autoFocus = $$new_props.autoFocus);
    		if ('body' in $$new_props) $$invalidate(2, body = $$new_props.body);
    		if ('centered' in $$new_props) $$invalidate(23, centered = $$new_props.centered);
    		if ('container' in $$new_props) $$invalidate(24, container = $$new_props.container);
    		if ('fullscreen' in $$new_props) $$invalidate(25, fullscreen = $$new_props.fullscreen);
    		if ('header' in $$new_props) $$invalidate(3, header = $$new_props.header);
    		if ('scrollable' in $$new_props) $$invalidate(26, scrollable = $$new_props.scrollable);
    		if ('size' in $$new_props) $$invalidate(27, size = $$new_props.size);
    		if ('toggle' in $$new_props) $$invalidate(4, toggle = $$new_props.toggle);
    		if ('labelledBy' in $$new_props) $$invalidate(5, labelledBy = $$new_props.labelledBy);
    		if ('backdrop' in $$new_props) $$invalidate(6, backdrop = $$new_props.backdrop);
    		if ('wrapClassName' in $$new_props) $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
    		if ('modalClassName' in $$new_props) $$invalidate(8, modalClassName = $$new_props.modalClassName);
    		if ('contentClassName' in $$new_props) $$invalidate(9, contentClassName = $$new_props.contentClassName);
    		if ('fade' in $$new_props) $$invalidate(10, fade = $$new_props.fade);
    		if ('unmountOnClose' in $$new_props) $$invalidate(28, unmountOnClose = $$new_props.unmountOnClose);
    		if ('returnFocusAfterClose' in $$new_props) $$invalidate(29, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    		if ('$$scope' in $$new_props) $$invalidate(34, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		openCount,
    		classnames,
    		browserEvent,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		afterUpdate,
    		modalIn,
    		modalOut,
    		InlineContainer,
    		ModalBackdrop,
    		ModalBody,
    		ModalHeader,
    		Portal,
    		conditionallyUpdateScrollbar,
    		getOriginalBodyPadding,
    		setScrollbarWidth,
    		dispatch,
    		className,
    		staticModal,
    		isOpen,
    		autoFocus,
    		body,
    		centered,
    		container,
    		fullscreen,
    		header,
    		scrollable,
    		size,
    		toggle,
    		labelledBy,
    		backdrop,
    		wrapClassName,
    		modalClassName,
    		contentClassName,
    		fade,
    		unmountOnClose,
    		returnFocusAfterClose,
    		hasOpened,
    		_isMounted,
    		_triggeringElement,
    		_originalBodyPadding,
    		_lastIsOpen,
    		_lastHasOpened,
    		_dialog,
    		_mouseDownElement,
    		_removeEscListener,
    		setFocus,
    		init,
    		manageFocusAfterClose,
    		destroy,
    		close,
    		handleBackdropClick,
    		onModalOpened,
    		onModalClosed,
    		handleBackdropMouseDown,
    		dialogBaseClass,
    		outer,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(21, className = $$new_props.className);
    		if ('staticModal' in $$props) $$invalidate(0, staticModal = $$new_props.staticModal);
    		if ('isOpen' in $$props) $$invalidate(1, isOpen = $$new_props.isOpen);
    		if ('autoFocus' in $$props) $$invalidate(22, autoFocus = $$new_props.autoFocus);
    		if ('body' in $$props) $$invalidate(2, body = $$new_props.body);
    		if ('centered' in $$props) $$invalidate(23, centered = $$new_props.centered);
    		if ('container' in $$props) $$invalidate(24, container = $$new_props.container);
    		if ('fullscreen' in $$props) $$invalidate(25, fullscreen = $$new_props.fullscreen);
    		if ('header' in $$props) $$invalidate(3, header = $$new_props.header);
    		if ('scrollable' in $$props) $$invalidate(26, scrollable = $$new_props.scrollable);
    		if ('size' in $$props) $$invalidate(27, size = $$new_props.size);
    		if ('toggle' in $$props) $$invalidate(4, toggle = $$new_props.toggle);
    		if ('labelledBy' in $$props) $$invalidate(5, labelledBy = $$new_props.labelledBy);
    		if ('backdrop' in $$props) $$invalidate(6, backdrop = $$new_props.backdrop);
    		if ('wrapClassName' in $$props) $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
    		if ('modalClassName' in $$props) $$invalidate(8, modalClassName = $$new_props.modalClassName);
    		if ('contentClassName' in $$props) $$invalidate(9, contentClassName = $$new_props.contentClassName);
    		if ('fade' in $$props) $$invalidate(10, fade = $$new_props.fade);
    		if ('unmountOnClose' in $$props) $$invalidate(28, unmountOnClose = $$new_props.unmountOnClose);
    		if ('returnFocusAfterClose' in $$props) $$invalidate(29, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    		if ('hasOpened' in $$props) hasOpened = $$new_props.hasOpened;
    		if ('_isMounted' in $$props) $$invalidate(11, _isMounted = $$new_props._isMounted);
    		if ('_triggeringElement' in $$props) _triggeringElement = $$new_props._triggeringElement;
    		if ('_originalBodyPadding' in $$props) _originalBodyPadding = $$new_props._originalBodyPadding;
    		if ('_lastIsOpen' in $$props) _lastIsOpen = $$new_props._lastIsOpen;
    		if ('_lastHasOpened' in $$props) _lastHasOpened = $$new_props._lastHasOpened;
    		if ('_dialog' in $$props) $$invalidate(12, _dialog = $$new_props._dialog);
    		if ('_mouseDownElement' in $$props) _mouseDownElement = $$new_props._mouseDownElement;
    		if ('_removeEscListener' in $$props) _removeEscListener = $$new_props._removeEscListener;
    		if ('outer' in $$props) $$invalidate(13, outer = $$new_props.outer);
    		if ('classes' in $$props) $$invalidate(14, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*className, size, fullscreen, centered, scrollable*/ 245366784) {
    			$$invalidate(14, classes = classnames(dialogBaseClass, className, {
    				[`modal-${size}`]: size,
    				'modal-fullscreen': fullscreen === true,
    				[`modal-fullscreen-${fullscreen}-down`]: fullscreen && typeof fullscreen === 'string',
    				[`${dialogBaseClass}-centered`]: centered,
    				[`${dialogBaseClass}-scrollable`]: scrollable
    			}));
    		}

    		if ($$self.$$.dirty[0] & /*container, staticModal*/ 16777217) {
    			$$invalidate(13, outer = container === 'inline' || staticModal
    			? InlineContainer
    			: Portal);
    		}
    	};

    	return [
    		staticModal,
    		isOpen,
    		body,
    		header,
    		toggle,
    		labelledBy,
    		backdrop,
    		wrapClassName,
    		modalClassName,
    		contentClassName,
    		fade,
    		_isMounted,
    		_dialog,
    		outer,
    		classes,
    		dispatch,
    		handleBackdropClick,
    		onModalOpened,
    		onModalClosed,
    		handleBackdropMouseDown,
    		$$restProps,
    		className,
    		autoFocus,
    		centered,
    		container,
    		fullscreen,
    		scrollable,
    		size,
    		unmountOnClose,
    		returnFocusAfterClose,
    		slots,
    		div1_binding,
    		introstart_handler,
    		outrostart_handler,
    		$$scope
    	];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$l,
    			create_fragment$l,
    			safe_not_equal,
    			{
    				class: 21,
    				static: 0,
    				isOpen: 1,
    				autoFocus: 22,
    				body: 2,
    				centered: 23,
    				container: 24,
    				fullscreen: 25,
    				header: 3,
    				scrollable: 26,
    				size: 27,
    				toggle: 4,
    				labelledBy: 5,
    				backdrop: 6,
    				wrapClassName: 7,
    				modalClassName: 8,
    				contentClassName: 9,
    				fade: 10,
    				unmountOnClose: 28,
    				returnFocusAfterClose: 29
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get class() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get static() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set static(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoFocus() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoFocus(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get body() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set body(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get centered() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set centered(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get container() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullscreen() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullscreen(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scrollable() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scrollable(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggle() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggle(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelledBy() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelledBy(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backdrop() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backdrop(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapClassName() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapClassName(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modalClassName() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modalClassName(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentClassName() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentClassName(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fade() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fade(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get unmountOnClose() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set unmountOnClose(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get returnFocusAfterClose() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set returnFocusAfterClose(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/sveltestrap/src/Row.svelte generated by Svelte v3.44.0 */
    const file$i = "node_modules/sveltestrap/src/Row.svelte";

    function create_fragment$k(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let div_levels = [/*$$restProps*/ ctx[1], { class: /*classes*/ ctx[0] }];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$i, 39, 0, 980);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] }
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getCols(cols) {
    	const colsValue = parseInt(cols);

    	if (!isNaN(colsValue)) {
    		if (colsValue > 0) {
    			return [`row-cols-${colsValue}`];
    		}
    	} else if (typeof cols === 'object') {
    		return ['xs', 'sm', 'md', 'lg', 'xl'].map(colWidth => {
    			const isXs = colWidth === 'xs';
    			const colSizeInterfix = isXs ? '-' : `-${colWidth}-`;
    			const value = cols[colWidth];

    			if (typeof value === 'number' && value > 0) {
    				return `row-cols${colSizeInterfix}${value}`;
    			}

    			return null;
    		}).filter(value => !!value);
    	}

    	return [];
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let classes;
    	const omit_props_names = ["class","noGutters","form","cols"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Row', slots, ['default']);
    	let { class: className = '' } = $$props;
    	let { noGutters = false } = $$props;
    	let { form = false } = $$props;
    	let { cols = 0 } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('noGutters' in $$new_props) $$invalidate(3, noGutters = $$new_props.noGutters);
    		if ('form' in $$new_props) $$invalidate(4, form = $$new_props.form);
    		if ('cols' in $$new_props) $$invalidate(5, cols = $$new_props.cols);
    		if ('$$scope' in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classnames,
    		className,
    		noGutters,
    		form,
    		cols,
    		getCols,
    		classes
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('noGutters' in $$props) $$invalidate(3, noGutters = $$new_props.noGutters);
    		if ('form' in $$props) $$invalidate(4, form = $$new_props.form);
    		if ('cols' in $$props) $$invalidate(5, cols = $$new_props.cols);
    		if ('classes' in $$props) $$invalidate(0, classes = $$new_props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*className, noGutters, form, cols*/ 60) {
    			$$invalidate(0, classes = classnames(className, noGutters ? 'gx-0' : null, form ? 'form-row' : 'row', ...getCols(cols)));
    		}
    	};

    	return [classes, $$restProps, className, noGutters, form, cols, $$scope, slots];
    }

    class Row extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { class: 2, noGutters: 3, form: 4, cols: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Row",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get class() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noGutters() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noGutters(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get form() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cols() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cols(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return target.propertyIsEnumerable(symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var ErrorKind;
    (function (ErrorKind) {
        /** Argument is unclosed (e.g. `{0`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
        /** Argument is empty (e.g. `{}`). */
        ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
        /** Argument is malformed (e.g. `{foo!}``) */
        ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
        /** Expect an argument type (e.g. `{foo,}`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
        /** Unsupported argument type (e.g. `{foo,foo}`) */
        ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
        /** Expect an argument style (e.g. `{foo, number, }`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
        /** The number skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
        /** The date time skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
        /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */
        ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
        /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */
        ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
        /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */
        ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
        /** Missing select argument options (e.g. `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
        /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Expecting a selector in `select` argument (e.g `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
        /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
        /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
        /**
         * Expecting a message fragment after the `plural` or `selectordinal` selector
         * (e.g. `{foo, plural, one}`)
         */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
        /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
        /**
         * Duplicate selectors in `plural` or `selectordinal` argument.
         * (e.g. {foo, plural, one {#} one {#}})
         */
        ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
        /** Duplicate selectors in `select` argument.
         * (e.g. {foo, select, apple {apple} apple {apple}})
         */
        ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
        /** Plural or select argument option must have `other` clause. */
        ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
        /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */
        ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
        /** The tag name is invalid. (e.g. `<123>foo</123>`) */
        ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
        /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */
        ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
        /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */
        ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
    })(ErrorKind || (ErrorKind = {}));

    var TYPE;
    (function (TYPE) {
        /**
         * Raw text
         */
        TYPE[TYPE["literal"] = 0] = "literal";
        /**
         * Variable w/o any format, e.g `var` in `this is a {var}`
         */
        TYPE[TYPE["argument"] = 1] = "argument";
        /**
         * Variable w/ number format
         */
        TYPE[TYPE["number"] = 2] = "number";
        /**
         * Variable w/ date format
         */
        TYPE[TYPE["date"] = 3] = "date";
        /**
         * Variable w/ time format
         */
        TYPE[TYPE["time"] = 4] = "time";
        /**
         * Variable w/ select format
         */
        TYPE[TYPE["select"] = 5] = "select";
        /**
         * Variable w/ plural format
         */
        TYPE[TYPE["plural"] = 6] = "plural";
        /**
         * Only possible within plural argument.
         * This is the `#` symbol that will be substituted with the count.
         */
        TYPE[TYPE["pound"] = 7] = "pound";
        /**
         * XML-like tag
         */
        TYPE[TYPE["tag"] = 8] = "tag";
    })(TYPE || (TYPE = {}));
    var SKELETON_TYPE;
    (function (SKELETON_TYPE) {
        SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
        SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
    })(SKELETON_TYPE || (SKELETON_TYPE = {}));
    /**
     * Type Guards
     */
    function isLiteralElement(el) {
        return el.type === TYPE.literal;
    }
    function isArgumentElement(el) {
        return el.type === TYPE.argument;
    }
    function isNumberElement(el) {
        return el.type === TYPE.number;
    }
    function isDateElement(el) {
        return el.type === TYPE.date;
    }
    function isTimeElement(el) {
        return el.type === TYPE.time;
    }
    function isSelectElement(el) {
        return el.type === TYPE.select;
    }
    function isPluralElement(el) {
        return el.type === TYPE.plural;
    }
    function isPoundElement(el) {
        return el.type === TYPE.pound;
    }
    function isTagElement(el) {
        return el.type === TYPE.tag;
    }
    function isNumberSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
    }
    function isDateTimeSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
    }

    // @generated from regex-gen.ts
    var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

    /**
     * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
     * with some tweaks
     */
    var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
    /**
     * Parse Date time skeleton into Intl.DateTimeFormatOptions
     * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * @public
     * @param skeleton skeleton string
     */
    function parseDateTimeSkeleton(skeleton) {
        var result = {};
        skeleton.replace(DATE_TIME_REGEX, function (match) {
            var len = match.length;
            switch (match[0]) {
                // Era
                case 'G':
                    result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                    break;
                // Year
                case 'y':
                    result.year = len === 2 ? '2-digit' : 'numeric';
                    break;
                case 'Y':
                case 'u':
                case 'U':
                case 'r':
                    throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
                // Quarter
                case 'q':
                case 'Q':
                    throw new RangeError('`q/Q` (quarter) patterns are not supported');
                // Month
                case 'M':
                case 'L':
                    result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
                    break;
                // Week
                case 'w':
                case 'W':
                    throw new RangeError('`w/W` (week) patterns are not supported');
                case 'd':
                    result.day = ['numeric', '2-digit'][len - 1];
                    break;
                case 'D':
                case 'F':
                case 'g':
                    throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
                // Weekday
                case 'E':
                    result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';
                    break;
                case 'e':
                    if (len < 4) {
                        throw new RangeError('`e..eee` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                case 'c':
                    if (len < 4) {
                        throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                // Period
                case 'a': // AM, PM
                    result.hour12 = true;
                    break;
                case 'b': // am, pm, noon, midnight
                case 'B': // flexible day periods
                    throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
                // Hour
                case 'h':
                    result.hourCycle = 'h12';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'H':
                    result.hourCycle = 'h23';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'K':
                    result.hourCycle = 'h11';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'k':
                    result.hourCycle = 'h24';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'j':
                case 'J':
                case 'C':
                    throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
                // Minute
                case 'm':
                    result.minute = ['numeric', '2-digit'][len - 1];
                    break;
                // Second
                case 's':
                    result.second = ['numeric', '2-digit'][len - 1];
                    break;
                case 'S':
                case 'A':
                    throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
                // Zone
                case 'z': // 1..3, 4: specific non-location format
                    result.timeZoneName = len < 4 ? 'short' : 'long';
                    break;
                case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
                case 'O': // 1, 4: miliseconds in day short, long
                case 'v': // 1, 4: generic non-location format
                case 'V': // 1, 2, 3, 4: time zone ID or city
                case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
                case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
                    throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
            }
            return '';
        });
        return result;
    }

    // @generated from regex-gen.ts
    var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

    function parseNumberSkeletonFromString(skeleton) {
        if (skeleton.length === 0) {
            throw new Error('Number skeleton cannot be empty');
        }
        // Parse the skeleton
        var stringTokens = skeleton
            .split(WHITE_SPACE_REGEX)
            .filter(function (x) { return x.length > 0; });
        var tokens = [];
        for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
            var stringToken = stringTokens_1[_i];
            var stemAndOptions = stringToken.split('/');
            if (stemAndOptions.length === 0) {
                throw new Error('Invalid number skeleton');
            }
            var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
            for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
                var option = options_1[_a];
                if (option.length === 0) {
                    throw new Error('Invalid number skeleton');
                }
            }
            tokens.push({ stem: stem, options: options });
        }
        return tokens;
    }
    function icuUnitToEcma(unit) {
        return unit.replace(/^(.*?)-/, '');
    }
    var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
    var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
    var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
    var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
    function parseSignificantPrecision(str) {
        var result = {};
        if (str[str.length - 1] === 'r') {
            result.roundingPriority = 'morePrecision';
        }
        else if (str[str.length - 1] === 's') {
            result.roundingPriority = 'lessPrecision';
        }
        str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
            // @@@ case
            if (typeof g2 !== 'string') {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits = g1.length;
            }
            // @@@+ case
            else if (g2 === '+') {
                result.minimumSignificantDigits = g1.length;
            }
            // .### case
            else if (g1[0] === '#') {
                result.maximumSignificantDigits = g1.length;
            }
            // .@@## or .@@@ case
            else {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits =
                    g1.length + (typeof g2 === 'string' ? g2.length : 0);
            }
            return '';
        });
        return result;
    }
    function parseSign(str) {
        switch (str) {
            case 'sign-auto':
                return {
                    signDisplay: 'auto',
                };
            case 'sign-accounting':
            case '()':
                return {
                    currencySign: 'accounting',
                };
            case 'sign-always':
            case '+!':
                return {
                    signDisplay: 'always',
                };
            case 'sign-accounting-always':
            case '()!':
                return {
                    signDisplay: 'always',
                    currencySign: 'accounting',
                };
            case 'sign-except-zero':
            case '+?':
                return {
                    signDisplay: 'exceptZero',
                };
            case 'sign-accounting-except-zero':
            case '()?':
                return {
                    signDisplay: 'exceptZero',
                    currencySign: 'accounting',
                };
            case 'sign-never':
            case '+_':
                return {
                    signDisplay: 'never',
                };
        }
    }
    function parseConciseScientificAndEngineeringStem(stem) {
        // Engineering
        var result;
        if (stem[0] === 'E' && stem[1] === 'E') {
            result = {
                notation: 'engineering',
            };
            stem = stem.slice(2);
        }
        else if (stem[0] === 'E') {
            result = {
                notation: 'scientific',
            };
            stem = stem.slice(1);
        }
        if (result) {
            var signDisplay = stem.slice(0, 2);
            if (signDisplay === '+!') {
                result.signDisplay = 'always';
                stem = stem.slice(2);
            }
            else if (signDisplay === '+?') {
                result.signDisplay = 'exceptZero';
                stem = stem.slice(2);
            }
            if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
                throw new Error('Malformed concise eng/scientific notation');
            }
            result.minimumIntegerDigits = stem.length;
        }
        return result;
    }
    function parseNotationOptions(opt) {
        var result = {};
        var signOpts = parseSign(opt);
        if (signOpts) {
            return signOpts;
        }
        return result;
    }
    /**
     * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
     */
    function parseNumberSkeleton(tokens) {
        var result = {};
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            switch (token.stem) {
                case 'percent':
                case '%':
                    result.style = 'percent';
                    continue;
                case '%x100':
                    result.style = 'percent';
                    result.scale = 100;
                    continue;
                case 'currency':
                    result.style = 'currency';
                    result.currency = token.options[0];
                    continue;
                case 'group-off':
                case ',_':
                    result.useGrouping = false;
                    continue;
                case 'precision-integer':
                case '.':
                    result.maximumFractionDigits = 0;
                    continue;
                case 'measure-unit':
                case 'unit':
                    result.style = 'unit';
                    result.unit = icuUnitToEcma(token.options[0]);
                    continue;
                case 'compact-short':
                case 'K':
                    result.notation = 'compact';
                    result.compactDisplay = 'short';
                    continue;
                case 'compact-long':
                case 'KK':
                    result.notation = 'compact';
                    result.compactDisplay = 'long';
                    continue;
                case 'scientific':
                    result = __assign(__assign(__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'engineering':
                    result = __assign(__assign(__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'notation-simple':
                    result.notation = 'standard';
                    continue;
                // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
                case 'unit-width-narrow':
                    result.currencyDisplay = 'narrowSymbol';
                    result.unitDisplay = 'narrow';
                    continue;
                case 'unit-width-short':
                    result.currencyDisplay = 'code';
                    result.unitDisplay = 'short';
                    continue;
                case 'unit-width-full-name':
                    result.currencyDisplay = 'name';
                    result.unitDisplay = 'long';
                    continue;
                case 'unit-width-iso-code':
                    result.currencyDisplay = 'symbol';
                    continue;
                case 'scale':
                    result.scale = parseFloat(token.options[0]);
                    continue;
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
                case 'integer-width':
                    if (token.options.length > 1) {
                        throw new RangeError('integer-width stems only accept a single optional option');
                    }
                    token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {
                        if (g1) {
                            result.minimumIntegerDigits = g2.length;
                        }
                        else if (g3 && g4) {
                            throw new Error('We currently do not support maximum integer digits');
                        }
                        else if (g5) {
                            throw new Error('We currently do not support exact integer digits');
                        }
                        return '';
                    });
                    continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
                result.minimumIntegerDigits = token.stem.length;
                continue;
            }
            if (FRACTION_PRECISION_REGEX.test(token.stem)) {
                // Precision
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
                // precision-integer case
                if (token.options.length > 1) {
                    throw new RangeError('Fraction-precision stems only accept a single optional option');
                }
                token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
                    // .000* case (before ICU67 it was .000+)
                    if (g2 === '*') {
                        result.minimumFractionDigits = g1.length;
                    }
                    // .### case
                    else if (g3 && g3[0] === '#') {
                        result.maximumFractionDigits = g3.length;
                    }
                    // .00## case
                    else if (g4 && g5) {
                        result.minimumFractionDigits = g4.length;
                        result.maximumFractionDigits = g4.length + g5.length;
                    }
                    else {
                        result.minimumFractionDigits = g1.length;
                        result.maximumFractionDigits = g1.length;
                    }
                    return '';
                });
                var opt = token.options[0];
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
                if (opt === 'w') {
                    result = __assign(__assign({}, result), { trailingZeroDisplay: 'stripIfInteger' });
                }
                else if (opt) {
                    result = __assign(__assign({}, result), parseSignificantPrecision(opt));
                }
                continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
            if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
                result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
                continue;
            }
            var signOpts = parseSign(token.stem);
            if (signOpts) {
                result = __assign(__assign({}, result), signOpts);
            }
            var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
            if (conciseScientificAndEngineeringOpts) {
                result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);
            }
        }
        return result;
    }

    var _a;
    var SPACE_SEPARATOR_START_REGEX = new RegExp("^" + SPACE_SEPARATOR_REGEX.source + "*");
    var SPACE_SEPARATOR_END_REGEX = new RegExp(SPACE_SEPARATOR_REGEX.source + "*$");
    function createLocation(start, end) {
        return { start: start, end: end };
    }
    // #region Ponyfills
    // Consolidate these variables up top for easier toggling during debugging
    var hasNativeStartsWith = !!String.prototype.startsWith;
    var hasNativeFromCodePoint = !!String.fromCodePoint;
    var hasNativeFromEntries = !!Object.fromEntries;
    var hasNativeCodePointAt = !!String.prototype.codePointAt;
    var hasTrimStart = !!String.prototype.trimStart;
    var hasTrimEnd = !!String.prototype.trimEnd;
    var hasNativeIsSafeInteger = !!Number.isSafeInteger;
    var isSafeInteger = hasNativeIsSafeInteger
        ? Number.isSafeInteger
        : function (n) {
            return (typeof n === 'number' &&
                isFinite(n) &&
                Math.floor(n) === n &&
                Math.abs(n) <= 0x1fffffffffffff);
        };
    // IE11 does not support y and u.
    var REGEX_SUPPORTS_U_AND_Y = true;
    try {
        var re = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        /**
         * legacy Edge or Xbox One browser
         * Unicode flag support: supported
         * Pattern_Syntax support: not supported
         * See https://github.com/formatjs/formatjs/issues/2822
         */
        REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';
    }
    catch (_) {
        REGEX_SUPPORTS_U_AND_Y = false;
    }
    var startsWith = hasNativeStartsWith
        ? // Native
            function startsWith(s, search, position) {
                return s.startsWith(search, position);
            }
        : // For IE11
            function startsWith(s, search, position) {
                return s.slice(position, position + search.length) === search;
            };
    var fromCodePoint = hasNativeFromCodePoint
        ? String.fromCodePoint
        : // IE11
            function fromCodePoint() {
                var codePoints = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    codePoints[_i] = arguments[_i];
                }
                var elements = '';
                var length = codePoints.length;
                var i = 0;
                var code;
                while (length > i) {
                    code = codePoints[i++];
                    if (code > 0x10ffff)
                        throw RangeError(code + ' is not a valid code point');
                    elements +=
                        code < 0x10000
                            ? String.fromCharCode(code)
                            : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);
                }
                return elements;
            };
    var fromEntries = 
    // native
    hasNativeFromEntries
        ? Object.fromEntries
        : // Ponyfill
            function fromEntries(entries) {
                var obj = {};
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var _a = entries_1[_i], k = _a[0], v = _a[1];
                    obj[k] = v;
                }
                return obj;
            };
    var codePointAt = hasNativeCodePointAt
        ? // Native
            function codePointAt(s, index) {
                return s.codePointAt(index);
            }
        : // IE 11
            function codePointAt(s, index) {
                var size = s.length;
                if (index < 0 || index >= size) {
                    return undefined;
                }
                var first = s.charCodeAt(index);
                var second;
                return first < 0xd800 ||
                    first > 0xdbff ||
                    index + 1 === size ||
                    (second = s.charCodeAt(index + 1)) < 0xdc00 ||
                    second > 0xdfff
                    ? first
                    : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
            };
    var trimStart = hasTrimStart
        ? // Native
            function trimStart(s) {
                return s.trimStart();
            }
        : // Ponyfill
            function trimStart(s) {
                return s.replace(SPACE_SEPARATOR_START_REGEX, '');
            };
    var trimEnd = hasTrimEnd
        ? // Native
            function trimEnd(s) {
                return s.trimEnd();
            }
        : // Ponyfill
            function trimEnd(s) {
                return s.replace(SPACE_SEPARATOR_END_REGEX, '');
            };
    // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
    function RE(s, flag) {
        return new RegExp(s, flag);
    }
    // #endregion
    var matchIdentifierAtIndex;
    if (REGEX_SUPPORTS_U_AND_Y) {
        // Native
        var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var _a;
            IDENTIFIER_PREFIX_RE_1.lastIndex = index;
            var match = IDENTIFIER_PREFIX_RE_1.exec(s);
            return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
        };
    }
    else {
        // IE11
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var match = [];
            while (true) {
                var c = codePointAt(s, index);
                if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                    break;
                }
                match.push(c);
                index += c >= 0x10000 ? 2 : 1;
            }
            return fromCodePoint.apply(void 0, match);
        };
    }
    var Parser = /** @class */ (function () {
        function Parser(message, options) {
            if (options === void 0) { options = {}; }
            this.message = message;
            this.position = { offset: 0, line: 1, column: 1 };
            this.ignoreTag = !!options.ignoreTag;
            this.requiresOtherClause = !!options.requiresOtherClause;
            this.shouldParseSkeletons = !!options.shouldParseSkeletons;
        }
        Parser.prototype.parse = function () {
            if (this.offset() !== 0) {
                throw Error('parser can only be used once');
            }
            return this.parseMessage(0, '', false);
        };
        Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {
            var elements = [];
            while (!this.isEOF()) {
                var char = this.char();
                if (char === 123 /* `{` */) {
                    var result = this.parseArgument(nestingLevel, expectingCloseTag);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else if (char === 125 /* `}` */ && nestingLevel > 0) {
                    break;
                }
                else if (char === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                    var position = this.clonePosition();
                    this.bump();
                    elements.push({
                        type: TYPE.pound,
                        location: createLocation(position, this.clonePosition()),
                    });
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    this.peek() === 47 // char code for '/'
                ) {
                    if (expectingCloseTag) {
                        break;
                    }
                    else {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    _isAlpha(this.peek() || 0)) {
                    var result = this.parseTag(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else {
                    var result = this.parseLiteral(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
            }
            return { val: elements, err: null };
        };
        /**
         * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
         * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
         * are accepted:
         *
         * ```
         * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
         * tagName ::= [a-z] (PENChar)*
         * PENChar ::=
         *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
         *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
         *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
         * ```
         *
         * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
         * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
         * since other tag-based engines like React allow it
         */
        Parser.prototype.parseTag = function (nestingLevel, parentArgType) {
            var startPosition = this.clonePosition();
            this.bump(); // `<`
            var tagName = this.parseTagName();
            this.bumpSpace();
            if (this.bumpIf('/>')) {
                // Self closing tag
                return {
                    val: {
                        type: TYPE.literal,
                        value: "<" + tagName + "/>",
                        location: createLocation(startPosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            else if (this.bumpIf('>')) {
                var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
                if (childrenResult.err) {
                    return childrenResult;
                }
                var children = childrenResult.val;
                // Expecting a close tag
                var endTagStartPosition = this.clonePosition();
                if (this.bumpIf('</')) {
                    if (this.isEOF() || !_isAlpha(this.char())) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    var closingTagNameStartPosition = this.clonePosition();
                    var closingTagName = this.parseTagName();
                    if (tagName !== closingTagName) {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                    }
                    this.bumpSpace();
                    if (!this.bumpIf('>')) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    return {
                        val: {
                            type: TYPE.tag,
                            value: tagName,
                            children: children,
                            location: createLocation(startPosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                else {
                    return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
                }
            }
            else {
                return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
            }
        };
        /**
         * This method assumes that the caller has peeked ahead for the first tag character.
         */
        Parser.prototype.parseTagName = function () {
            var startOffset = this.offset();
            this.bump(); // the first tag name character
            while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
                this.bump();
            }
            return this.message.slice(startOffset, this.offset());
        };
        Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {
            var start = this.clonePosition();
            var value = '';
            while (true) {
                var parseQuoteResult = this.tryParseQuote(parentArgType);
                if (parseQuoteResult) {
                    value += parseQuoteResult;
                    continue;
                }
                var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
                if (parseUnquotedResult) {
                    value += parseUnquotedResult;
                    continue;
                }
                var parseLeftAngleResult = this.tryParseLeftAngleBracket();
                if (parseLeftAngleResult) {
                    value += parseLeftAngleResult;
                    continue;
                }
                break;
            }
            var location = createLocation(start, this.clonePosition());
            return {
                val: { type: TYPE.literal, value: value, location: location },
                err: null,
            };
        };
        Parser.prototype.tryParseLeftAngleBracket = function () {
            if (!this.isEOF() &&
                this.char() === 60 /* `<` */ &&
                (this.ignoreTag ||
                    // If at the opening tag or closing tag position, bail.
                    !_isAlphaOrSlash(this.peek() || 0))) {
                this.bump(); // `<`
                return '<';
            }
            return null;
        };
        /**
         * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
         * a character that requires quoting (that is, "only where needed"), and works the same in
         * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
         */
        Parser.prototype.tryParseQuote = function (parentArgType) {
            if (this.isEOF() || this.char() !== 39 /* `'` */) {
                return null;
            }
            // Parse escaped char following the apostrophe, or early return if there is no escaped char.
            // Check if is valid escaped character
            switch (this.peek()) {
                case 39 /* `'` */:
                    // double quote, should return as a single quote.
                    this.bump();
                    this.bump();
                    return "'";
                // '{', '<', '>', '}'
                case 123:
                case 60:
                case 62:
                case 125:
                    break;
                case 35: // '#'
                    if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                        break;
                    }
                    return null;
                default:
                    return null;
            }
            this.bump(); // apostrophe
            var codePoints = [this.char()]; // escaped char
            this.bump();
            // read chars until the optional closing apostrophe is found
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch === 39 /* `'` */) {
                    if (this.peek() === 39 /* `'` */) {
                        codePoints.push(39);
                        // Bump one more time because we need to skip 2 characters.
                        this.bump();
                    }
                    else {
                        // Optional closing apostrophe.
                        this.bump();
                        break;
                    }
                }
                else {
                    codePoints.push(ch);
                }
                this.bump();
            }
            return fromCodePoint.apply(void 0, codePoints);
        };
        Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {
            if (this.isEOF()) {
                return null;
            }
            var ch = this.char();
            if (ch === 60 /* `<` */ ||
                ch === 123 /* `{` */ ||
                (ch === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||
                (ch === 125 /* `}` */ && nestingLevel > 0)) {
                return null;
            }
            else {
                this.bump();
                return fromCodePoint(ch);
            }
        };
        Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {
            var openingBracePosition = this.clonePosition();
            this.bump(); // `{`
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            if (this.char() === 125 /* `}` */) {
                this.bump();
                return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            // argument name
            var value = this.parseIdentifierIfPossible().value;
            if (!value) {
                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            switch (this.char()) {
                // Simple argument: `{name}`
                case 125 /* `}` */: {
                    this.bump(); // `}`
                    return {
                        val: {
                            type: TYPE.argument,
                            // value does not include the opening and closing braces.
                            value: value,
                            location: createLocation(openingBracePosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                // Argument with options: `{name, format, ...}`
                case 44 /* `,` */: {
                    this.bump(); // `,`
                    this.bumpSpace();
                    if (this.isEOF()) {
                        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                    }
                    return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
                }
                default:
                    return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
        };
        /**
         * Advance the parser until the end of the identifier, if it is currently on
         * an identifier character. Return an empty string otherwise.
         */
        Parser.prototype.parseIdentifierIfPossible = function () {
            var startingPosition = this.clonePosition();
            var startOffset = this.offset();
            var value = matchIdentifierAtIndex(this.message, startOffset);
            var endOffset = startOffset + value.length;
            this.bumpTo(endOffset);
            var endPosition = this.clonePosition();
            var location = createLocation(startingPosition, endPosition);
            return { value: value, location: location };
        };
        Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {
            var _a;
            // Parse this range:
            // {name, type, style}
            //        ^---^
            var typeStartPosition = this.clonePosition();
            var argType = this.parseIdentifierIfPossible().value;
            var typeEndPosition = this.clonePosition();
            switch (argType) {
                case '':
                    // Expecting a style string number, date, time, plural, selectordinal, or select.
                    return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
                case 'number':
                case 'date':
                case 'time': {
                    // Parse this range:
                    // {name, number, style}
                    //              ^-------^
                    this.bumpSpace();
                    var styleAndLocation = null;
                    if (this.bumpIf(',')) {
                        this.bumpSpace();
                        var styleStartPosition = this.clonePosition();
                        var result = this.parseSimpleArgStyleIfPossible();
                        if (result.err) {
                            return result;
                        }
                        var style = trimEnd(result.val);
                        if (style.length === 0) {
                            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                        styleAndLocation = { style: style, styleLocation: styleLocation };
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_1 = createLocation(openingBracePosition, this.clonePosition());
                    // Extract style or skeleton
                    if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                        // Skeleton starts with `::`.
                        var skeleton = trimStart(styleAndLocation.style.slice(2));
                        if (argType === 'number') {
                            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                            if (result.err) {
                                return result;
                            }
                            return {
                                val: { type: TYPE.number, value: value, location: location_1, style: result.val },
                                err: null,
                            };
                        }
                        else {
                            if (skeleton.length === 0) {
                                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
                            }
                            var style = {
                                type: SKELETON_TYPE.dateTime,
                                pattern: skeleton,
                                location: styleAndLocation.styleLocation,
                                parsedOptions: this.shouldParseSkeletons
                                    ? parseDateTimeSkeleton(skeleton)
                                    : {},
                            };
                            var type = argType === 'date' ? TYPE.date : TYPE.time;
                            return {
                                val: { type: type, value: value, location: location_1, style: style },
                                err: null,
                            };
                        }
                    }
                    // Regular style or no style.
                    return {
                        val: {
                            type: argType === 'number'
                                ? TYPE.number
                                : argType === 'date'
                                    ? TYPE.date
                                    : TYPE.time,
                            value: value,
                            location: location_1,
                            style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,
                        },
                        err: null,
                    };
                }
                case 'plural':
                case 'selectordinal':
                case 'select': {
                    // Parse this range:
                    // {name, plural, options}
                    //              ^---------^
                    var typeEndPosition_1 = this.clonePosition();
                    this.bumpSpace();
                    if (!this.bumpIf(',')) {
                        return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));
                    }
                    this.bumpSpace();
                    // Parse offset:
                    // {name, plural, offset:1, options}
                    //                ^-----^
                    //
                    // or the first option:
                    //
                    // {name, plural, one {...} other {...}}
                    //                ^--^
                    var identifierAndLocation = this.parseIdentifierIfPossible();
                    var pluralOffset = 0;
                    if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                        if (!this.bumpIf(':')) {
                            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        this.bumpSpace();
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                        if (result.err) {
                            return result;
                        }
                        // Parse another identifier for option parsing
                        this.bumpSpace();
                        identifierAndLocation = this.parseIdentifierIfPossible();
                        pluralOffset = result.val;
                    }
                    var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                    if (optionsResult.err) {
                        return optionsResult;
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_2 = createLocation(openingBracePosition, this.clonePosition());
                    if (argType === 'select') {
                        return {
                            val: {
                                type: TYPE.select,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                    else {
                        return {
                            val: {
                                type: TYPE.plural,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                offset: pluralOffset,
                                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                }
                default:
                    return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            }
        };
        Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {
            // Parse: {value, number, ::currency/GBP }
            //
            if (this.isEOF() || this.char() !== 125 /* `}` */) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bump(); // `}`
            return { val: true, err: null };
        };
        /**
         * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
         */
        Parser.prototype.parseSimpleArgStyleIfPossible = function () {
            var nestedBraces = 0;
            var startPosition = this.clonePosition();
            while (!this.isEOF()) {
                var ch = this.char();
                switch (ch) {
                    case 39 /* `'` */: {
                        // Treat apostrophe as quoting but include it in the style part.
                        // Find the end of the quoted literal text.
                        this.bump();
                        var apostrophePosition = this.clonePosition();
                        if (!this.bumpUntil("'")) {
                            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                        }
                        this.bump();
                        break;
                    }
                    case 123 /* `{` */: {
                        nestedBraces += 1;
                        this.bump();
                        break;
                    }
                    case 125 /* `}` */: {
                        if (nestedBraces > 0) {
                            nestedBraces -= 1;
                        }
                        else {
                            return {
                                val: this.message.slice(startPosition.offset, this.offset()),
                                err: null,
                            };
                        }
                        break;
                    }
                    default:
                        this.bump();
                        break;
                }
            }
            return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null,
            };
        };
        Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {
            var tokens = [];
            try {
                tokens = parseNumberSkeletonFromString(skeleton);
            }
            catch (e) {
                return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
            }
            return {
                val: {
                    type: SKELETON_TYPE.number,
                    tokens: tokens,
                    location: location,
                    parsedOptions: this.shouldParseSkeletons
                        ? parseNumberSkeleton(tokens)
                        : {},
                },
                err: null,
            };
        };
        /**
         * @param nesting_level The current nesting level of messages.
         *     This can be positive when parsing message fragment in select or plural argument options.
         * @param parent_arg_type The parent argument's type.
         * @param parsed_first_identifier If provided, this is the first identifier-like selector of
         *     the argument. It is a by-product of a previous parsing attempt.
         * @param expecting_close_tag If true, this message is directly or indirectly nested inside
         *     between a pair of opening and closing tags. The nested message will not parse beyond
         *     the closing tag boundary.
         */
        Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
            var _a;
            var hasOtherClause = false;
            var options = [];
            var parsedSelectors = new Set();
            var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
            // Parse:
            // one {one apple}
            // ^--^
            while (true) {
                if (selector.length === 0) {
                    var startPosition = this.clonePosition();
                    if (parentArgType !== 'select' && this.bumpIf('=')) {
                        // Try parse `={number}` selector
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
                        if (result.err) {
                            return result;
                        }
                        selectorLocation = createLocation(startPosition, this.clonePosition());
                        selector = this.message.slice(startPosition.offset, this.offset());
                    }
                    else {
                        break;
                    }
                }
                // Duplicate selector clauses
                if (parsedSelectors.has(selector)) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR
                        : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
                }
                if (selector === 'other') {
                    hasOtherClause = true;
                }
                // Parse:
                // one {one apple}
                //     ^----------^
                this.bumpSpace();
                var openingBracePosition = this.clonePosition();
                if (!this.bumpIf('{')) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
                        : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
                }
                var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
                if (fragmentResult.err) {
                    return fragmentResult;
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                options.push([
                    selector,
                    {
                        value: fragmentResult.val,
                        location: createLocation(openingBracePosition, this.clonePosition()),
                    },
                ]);
                // Keep track of the existing selectors
                parsedSelectors.add(selector);
                // Prep next selector clause.
                this.bumpSpace();
                (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);
            }
            if (options.length === 0) {
                return this.error(parentArgType === 'select'
                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR
                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
            }
            if (this.requiresOtherClause && !hasOtherClause) {
                return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            return { val: options, err: null };
        };
        Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {
            var sign = 1;
            var startingPosition = this.clonePosition();
            if (this.bumpIf('+')) ;
            else if (this.bumpIf('-')) {
                sign = -1;
            }
            var hasDigits = false;
            var decimal = 0;
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {
                    hasDigits = true;
                    decimal = decimal * 10 + (ch - 48);
                    this.bump();
                }
                else {
                    break;
                }
            }
            var location = createLocation(startingPosition, this.clonePosition());
            if (!hasDigits) {
                return this.error(expectNumberError, location);
            }
            decimal *= sign;
            if (!isSafeInteger(decimal)) {
                return this.error(invalidNumberError, location);
            }
            return { val: decimal, err: null };
        };
        Parser.prototype.offset = function () {
            return this.position.offset;
        };
        Parser.prototype.isEOF = function () {
            return this.offset() === this.message.length;
        };
        Parser.prototype.clonePosition = function () {
            // This is much faster than `Object.assign` or spread.
            return {
                offset: this.position.offset,
                line: this.position.line,
                column: this.position.column,
            };
        };
        /**
         * Return the code point at the current position of the parser.
         * Throws if the index is out of bound.
         */
        Parser.prototype.char = function () {
            var offset = this.position.offset;
            if (offset >= this.message.length) {
                throw Error('out of bound');
            }
            var code = codePointAt(this.message, offset);
            if (code === undefined) {
                throw Error("Offset " + offset + " is at invalid UTF-16 code unit boundary");
            }
            return code;
        };
        Parser.prototype.error = function (kind, location) {
            return {
                val: null,
                err: {
                    kind: kind,
                    message: this.message,
                    location: location,
                },
            };
        };
        /** Bump the parser to the next UTF-16 code unit. */
        Parser.prototype.bump = function () {
            if (this.isEOF()) {
                return;
            }
            var code = this.char();
            if (code === 10 /* '\n' */) {
                this.position.line += 1;
                this.position.column = 1;
                this.position.offset += 1;
            }
            else {
                this.position.column += 1;
                // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
                this.position.offset += code < 0x10000 ? 1 : 2;
            }
        };
        /**
         * If the substring starting at the current position of the parser has
         * the given prefix, then bump the parser to the character immediately
         * following the prefix and return true. Otherwise, don't bump the parser
         * and return false.
         */
        Parser.prototype.bumpIf = function (prefix) {
            if (startsWith(this.message, prefix, this.offset())) {
                for (var i = 0; i < prefix.length; i++) {
                    this.bump();
                }
                return true;
            }
            return false;
        };
        /**
         * Bump the parser until the pattern character is found and return `true`.
         * Otherwise bump to the end of the file and return `false`.
         */
        Parser.prototype.bumpUntil = function (pattern) {
            var currentOffset = this.offset();
            var index = this.message.indexOf(pattern, currentOffset);
            if (index >= 0) {
                this.bumpTo(index);
                return true;
            }
            else {
                this.bumpTo(this.message.length);
                return false;
            }
        };
        /**
         * Bump the parser to the target offset.
         * If target offset is beyond the end of the input, bump the parser to the end of the input.
         */
        Parser.prototype.bumpTo = function (targetOffset) {
            if (this.offset() > targetOffset) {
                throw Error("targetOffset " + targetOffset + " must be greater than or equal to the current offset " + this.offset());
            }
            targetOffset = Math.min(targetOffset, this.message.length);
            while (true) {
                var offset = this.offset();
                if (offset === targetOffset) {
                    break;
                }
                if (offset > targetOffset) {
                    throw Error("targetOffset " + targetOffset + " is at invalid UTF-16 code unit boundary");
                }
                this.bump();
                if (this.isEOF()) {
                    break;
                }
            }
        };
        /** advance the parser through all whitespace to the next non-whitespace code unit. */
        Parser.prototype.bumpSpace = function () {
            while (!this.isEOF() && _isWhiteSpace(this.char())) {
                this.bump();
            }
        };
        /**
         * Peek at the *next* Unicode codepoint in the input without advancing the parser.
         * If the input has been exhausted, then this returns null.
         */
        Parser.prototype.peek = function () {
            if (this.isEOF()) {
                return null;
            }
            var code = this.char();
            var offset = this.offset();
            var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
            return nextCode !== null && nextCode !== void 0 ? nextCode : null;
        };
        return Parser;
    }());
    /**
     * This check if codepoint is alphabet (lower & uppercase)
     * @param codepoint
     * @returns
     */
    function _isAlpha(codepoint) {
        return ((codepoint >= 97 && codepoint <= 122) ||
            (codepoint >= 65 && codepoint <= 90));
    }
    function _isAlphaOrSlash(codepoint) {
        return _isAlpha(codepoint) || codepoint === 47; /* '/' */
    }
    /** See `parseTag` function docs. */
    function _isPotentialElementNameChar(c) {
        return (c === 45 /* '-' */ ||
            c === 46 /* '.' */ ||
            (c >= 48 && c <= 57) /* 0..9 */ ||
            c === 95 /* '_' */ ||
            (c >= 97 && c <= 122) /** a..z */ ||
            (c >= 65 && c <= 90) /* A..Z */ ||
            c == 0xb7 ||
            (c >= 0xc0 && c <= 0xd6) ||
            (c >= 0xd8 && c <= 0xf6) ||
            (c >= 0xf8 && c <= 0x37d) ||
            (c >= 0x37f && c <= 0x1fff) ||
            (c >= 0x200c && c <= 0x200d) ||
            (c >= 0x203f && c <= 0x2040) ||
            (c >= 0x2070 && c <= 0x218f) ||
            (c >= 0x2c00 && c <= 0x2fef) ||
            (c >= 0x3001 && c <= 0xd7ff) ||
            (c >= 0xf900 && c <= 0xfdcf) ||
            (c >= 0xfdf0 && c <= 0xfffd) ||
            (c >= 0x10000 && c <= 0xeffff));
    }
    /**
     * Code point equivalent of regex `\p{White_Space}`.
     * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isWhiteSpace(c) {
        return ((c >= 0x0009 && c <= 0x000d) ||
            c === 0x0020 ||
            c === 0x0085 ||
            (c >= 0x200e && c <= 0x200f) ||
            c === 0x2028 ||
            c === 0x2029);
    }
    /**
     * Code point equivalent of regex `\p{Pattern_Syntax}`.
     * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isPatternSyntax(c) {
        return ((c >= 0x0021 && c <= 0x0023) ||
            c === 0x0024 ||
            (c >= 0x0025 && c <= 0x0027) ||
            c === 0x0028 ||
            c === 0x0029 ||
            c === 0x002a ||
            c === 0x002b ||
            c === 0x002c ||
            c === 0x002d ||
            (c >= 0x002e && c <= 0x002f) ||
            (c >= 0x003a && c <= 0x003b) ||
            (c >= 0x003c && c <= 0x003e) ||
            (c >= 0x003f && c <= 0x0040) ||
            c === 0x005b ||
            c === 0x005c ||
            c === 0x005d ||
            c === 0x005e ||
            c === 0x0060 ||
            c === 0x007b ||
            c === 0x007c ||
            c === 0x007d ||
            c === 0x007e ||
            c === 0x00a1 ||
            (c >= 0x00a2 && c <= 0x00a5) ||
            c === 0x00a6 ||
            c === 0x00a7 ||
            c === 0x00a9 ||
            c === 0x00ab ||
            c === 0x00ac ||
            c === 0x00ae ||
            c === 0x00b0 ||
            c === 0x00b1 ||
            c === 0x00b6 ||
            c === 0x00bb ||
            c === 0x00bf ||
            c === 0x00d7 ||
            c === 0x00f7 ||
            (c >= 0x2010 && c <= 0x2015) ||
            (c >= 0x2016 && c <= 0x2017) ||
            c === 0x2018 ||
            c === 0x2019 ||
            c === 0x201a ||
            (c >= 0x201b && c <= 0x201c) ||
            c === 0x201d ||
            c === 0x201e ||
            c === 0x201f ||
            (c >= 0x2020 && c <= 0x2027) ||
            (c >= 0x2030 && c <= 0x2038) ||
            c === 0x2039 ||
            c === 0x203a ||
            (c >= 0x203b && c <= 0x203e) ||
            (c >= 0x2041 && c <= 0x2043) ||
            c === 0x2044 ||
            c === 0x2045 ||
            c === 0x2046 ||
            (c >= 0x2047 && c <= 0x2051) ||
            c === 0x2052 ||
            c === 0x2053 ||
            (c >= 0x2055 && c <= 0x205e) ||
            (c >= 0x2190 && c <= 0x2194) ||
            (c >= 0x2195 && c <= 0x2199) ||
            (c >= 0x219a && c <= 0x219b) ||
            (c >= 0x219c && c <= 0x219f) ||
            c === 0x21a0 ||
            (c >= 0x21a1 && c <= 0x21a2) ||
            c === 0x21a3 ||
            (c >= 0x21a4 && c <= 0x21a5) ||
            c === 0x21a6 ||
            (c >= 0x21a7 && c <= 0x21ad) ||
            c === 0x21ae ||
            (c >= 0x21af && c <= 0x21cd) ||
            (c >= 0x21ce && c <= 0x21cf) ||
            (c >= 0x21d0 && c <= 0x21d1) ||
            c === 0x21d2 ||
            c === 0x21d3 ||
            c === 0x21d4 ||
            (c >= 0x21d5 && c <= 0x21f3) ||
            (c >= 0x21f4 && c <= 0x22ff) ||
            (c >= 0x2300 && c <= 0x2307) ||
            c === 0x2308 ||
            c === 0x2309 ||
            c === 0x230a ||
            c === 0x230b ||
            (c >= 0x230c && c <= 0x231f) ||
            (c >= 0x2320 && c <= 0x2321) ||
            (c >= 0x2322 && c <= 0x2328) ||
            c === 0x2329 ||
            c === 0x232a ||
            (c >= 0x232b && c <= 0x237b) ||
            c === 0x237c ||
            (c >= 0x237d && c <= 0x239a) ||
            (c >= 0x239b && c <= 0x23b3) ||
            (c >= 0x23b4 && c <= 0x23db) ||
            (c >= 0x23dc && c <= 0x23e1) ||
            (c >= 0x23e2 && c <= 0x2426) ||
            (c >= 0x2427 && c <= 0x243f) ||
            (c >= 0x2440 && c <= 0x244a) ||
            (c >= 0x244b && c <= 0x245f) ||
            (c >= 0x2500 && c <= 0x25b6) ||
            c === 0x25b7 ||
            (c >= 0x25b8 && c <= 0x25c0) ||
            c === 0x25c1 ||
            (c >= 0x25c2 && c <= 0x25f7) ||
            (c >= 0x25f8 && c <= 0x25ff) ||
            (c >= 0x2600 && c <= 0x266e) ||
            c === 0x266f ||
            (c >= 0x2670 && c <= 0x2767) ||
            c === 0x2768 ||
            c === 0x2769 ||
            c === 0x276a ||
            c === 0x276b ||
            c === 0x276c ||
            c === 0x276d ||
            c === 0x276e ||
            c === 0x276f ||
            c === 0x2770 ||
            c === 0x2771 ||
            c === 0x2772 ||
            c === 0x2773 ||
            c === 0x2774 ||
            c === 0x2775 ||
            (c >= 0x2794 && c <= 0x27bf) ||
            (c >= 0x27c0 && c <= 0x27c4) ||
            c === 0x27c5 ||
            c === 0x27c6 ||
            (c >= 0x27c7 && c <= 0x27e5) ||
            c === 0x27e6 ||
            c === 0x27e7 ||
            c === 0x27e8 ||
            c === 0x27e9 ||
            c === 0x27ea ||
            c === 0x27eb ||
            c === 0x27ec ||
            c === 0x27ed ||
            c === 0x27ee ||
            c === 0x27ef ||
            (c >= 0x27f0 && c <= 0x27ff) ||
            (c >= 0x2800 && c <= 0x28ff) ||
            (c >= 0x2900 && c <= 0x2982) ||
            c === 0x2983 ||
            c === 0x2984 ||
            c === 0x2985 ||
            c === 0x2986 ||
            c === 0x2987 ||
            c === 0x2988 ||
            c === 0x2989 ||
            c === 0x298a ||
            c === 0x298b ||
            c === 0x298c ||
            c === 0x298d ||
            c === 0x298e ||
            c === 0x298f ||
            c === 0x2990 ||
            c === 0x2991 ||
            c === 0x2992 ||
            c === 0x2993 ||
            c === 0x2994 ||
            c === 0x2995 ||
            c === 0x2996 ||
            c === 0x2997 ||
            c === 0x2998 ||
            (c >= 0x2999 && c <= 0x29d7) ||
            c === 0x29d8 ||
            c === 0x29d9 ||
            c === 0x29da ||
            c === 0x29db ||
            (c >= 0x29dc && c <= 0x29fb) ||
            c === 0x29fc ||
            c === 0x29fd ||
            (c >= 0x29fe && c <= 0x2aff) ||
            (c >= 0x2b00 && c <= 0x2b2f) ||
            (c >= 0x2b30 && c <= 0x2b44) ||
            (c >= 0x2b45 && c <= 0x2b46) ||
            (c >= 0x2b47 && c <= 0x2b4c) ||
            (c >= 0x2b4d && c <= 0x2b73) ||
            (c >= 0x2b74 && c <= 0x2b75) ||
            (c >= 0x2b76 && c <= 0x2b95) ||
            c === 0x2b96 ||
            (c >= 0x2b97 && c <= 0x2bff) ||
            (c >= 0x2e00 && c <= 0x2e01) ||
            c === 0x2e02 ||
            c === 0x2e03 ||
            c === 0x2e04 ||
            c === 0x2e05 ||
            (c >= 0x2e06 && c <= 0x2e08) ||
            c === 0x2e09 ||
            c === 0x2e0a ||
            c === 0x2e0b ||
            c === 0x2e0c ||
            c === 0x2e0d ||
            (c >= 0x2e0e && c <= 0x2e16) ||
            c === 0x2e17 ||
            (c >= 0x2e18 && c <= 0x2e19) ||
            c === 0x2e1a ||
            c === 0x2e1b ||
            c === 0x2e1c ||
            c === 0x2e1d ||
            (c >= 0x2e1e && c <= 0x2e1f) ||
            c === 0x2e20 ||
            c === 0x2e21 ||
            c === 0x2e22 ||
            c === 0x2e23 ||
            c === 0x2e24 ||
            c === 0x2e25 ||
            c === 0x2e26 ||
            c === 0x2e27 ||
            c === 0x2e28 ||
            c === 0x2e29 ||
            (c >= 0x2e2a && c <= 0x2e2e) ||
            c === 0x2e2f ||
            (c >= 0x2e30 && c <= 0x2e39) ||
            (c >= 0x2e3a && c <= 0x2e3b) ||
            (c >= 0x2e3c && c <= 0x2e3f) ||
            c === 0x2e40 ||
            c === 0x2e41 ||
            c === 0x2e42 ||
            (c >= 0x2e43 && c <= 0x2e4f) ||
            (c >= 0x2e50 && c <= 0x2e51) ||
            c === 0x2e52 ||
            (c >= 0x2e53 && c <= 0x2e7f) ||
            (c >= 0x3001 && c <= 0x3003) ||
            c === 0x3008 ||
            c === 0x3009 ||
            c === 0x300a ||
            c === 0x300b ||
            c === 0x300c ||
            c === 0x300d ||
            c === 0x300e ||
            c === 0x300f ||
            c === 0x3010 ||
            c === 0x3011 ||
            (c >= 0x3012 && c <= 0x3013) ||
            c === 0x3014 ||
            c === 0x3015 ||
            c === 0x3016 ||
            c === 0x3017 ||
            c === 0x3018 ||
            c === 0x3019 ||
            c === 0x301a ||
            c === 0x301b ||
            c === 0x301c ||
            c === 0x301d ||
            (c >= 0x301e && c <= 0x301f) ||
            c === 0x3020 ||
            c === 0x3030 ||
            c === 0xfd3e ||
            c === 0xfd3f ||
            (c >= 0xfe45 && c <= 0xfe46));
    }

    function pruneLocation(els) {
        els.forEach(function (el) {
            delete el.location;
            if (isSelectElement(el) || isPluralElement(el)) {
                for (var k in el.options) {
                    delete el.options[k].location;
                    pruneLocation(el.options[k].value);
                }
            }
            else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
                delete el.style.location;
            }
            else if ((isDateElement(el) || isTimeElement(el)) &&
                isDateTimeSkeleton(el.style)) {
                delete el.style.location;
            }
            else if (isTagElement(el)) {
                pruneLocation(el.children);
            }
        });
    }
    function parse(message, opts) {
        if (opts === void 0) { opts = {}; }
        opts = __assign({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
        var result = new Parser(message, opts).parse();
        if (result.err) {
            var error = SyntaxError(ErrorKind[result.err.kind]);
            // @ts-expect-error Assign to error object
            error.location = result.err.location;
            // @ts-expect-error Assign to error object
            error.originalMessage = result.err.message;
            throw error;
        }
        if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
            pruneLocation(result.val);
        }
        return result.val;
    }

    //
    // Main
    //
    function memoize(fn, options) {
        var cache = options && options.cache ? options.cache : cacheDefault;
        var serializer = options && options.serializer ? options.serializer : serializerDefault;
        var strategy = options && options.strategy ? options.strategy : strategyDefault;
        return strategy(fn, {
            cache: cache,
            serializer: serializer,
        });
    }
    //
    // Strategy
    //
    function isPrimitive(value) {
        return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
    }
    function monadic(fn, cache, serializer, arg) {
        var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.call(this, arg);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function variadic(fn, cache, serializer) {
        var args = Array.prototype.slice.call(arguments, 3);
        var cacheKey = serializer(args);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.apply(this, args);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function assemble(fn, context, strategy, cache, serialize) {
        return strategy.bind(context, fn, cache, serialize);
    }
    function strategyDefault(fn, options) {
        var strategy = fn.length === 1 ? monadic : variadic;
        return assemble(fn, this, strategy, options.cache.create(), options.serializer);
    }
    function strategyVariadic(fn, options) {
        return assemble(fn, this, variadic, options.cache.create(), options.serializer);
    }
    function strategyMonadic(fn, options) {
        return assemble(fn, this, monadic, options.cache.create(), options.serializer);
    }
    //
    // Serializer
    //
    var serializerDefault = function () {
        return JSON.stringify(arguments);
    };
    //
    // Cache
    //
    function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.get = function (key) {
        return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
        this.cache[key] = value;
    };
    var cacheDefault = {
        create: function create() {
            // @ts-ignore
            return new ObjectWithoutPrototypeCache();
        },
    };
    var strategies = {
        variadic: strategyVariadic,
        monadic: strategyMonadic,
    };

    var ErrorCode;
    (function (ErrorCode) {
        // When we have a placeholder but no value to format
        ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
        // When value supplied is invalid
        ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
        // When we need specific Intl API but it's not available
        ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
    })(ErrorCode || (ErrorCode = {}));
    var FormatError = /** @class */ (function (_super) {
        __extends(FormatError, _super);
        function FormatError(msg, code, originalMessage) {
            var _this = _super.call(this, msg) || this;
            _this.code = code;
            _this.originalMessage = originalMessage;
            return _this;
        }
        FormatError.prototype.toString = function () {
            return "[formatjs Error: " + this.code + "] " + this.message;
        };
        return FormatError;
    }(Error));
    var InvalidValueError = /** @class */ (function (_super) {
        __extends(InvalidValueError, _super);
        function InvalidValueError(variableId, value, options, originalMessage) {
            return _super.call(this, "Invalid values for \"" + variableId + "\": \"" + value + "\". Options are \"" + Object.keys(options).join('", "') + "\"", ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueError;
    }(FormatError));
    var InvalidValueTypeError = /** @class */ (function (_super) {
        __extends(InvalidValueTypeError, _super);
        function InvalidValueTypeError(value, type, originalMessage) {
            return _super.call(this, "Value for \"" + value + "\" must be of type " + type, ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueTypeError;
    }(FormatError));
    var MissingValueError = /** @class */ (function (_super) {
        __extends(MissingValueError, _super);
        function MissingValueError(variableId, originalMessage) {
            return _super.call(this, "The intl string context variable \"" + variableId + "\" was not provided to the string \"" + originalMessage + "\"", ErrorCode.MISSING_VALUE, originalMessage) || this;
        }
        return MissingValueError;
    }(FormatError));

    var PART_TYPE;
    (function (PART_TYPE) {
        PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
        PART_TYPE[PART_TYPE["object"] = 1] = "object";
    })(PART_TYPE || (PART_TYPE = {}));
    function mergeLiteral(parts) {
        if (parts.length < 2) {
            return parts;
        }
        return parts.reduce(function (all, part) {
            var lastPart = all[all.length - 1];
            if (!lastPart ||
                lastPart.type !== PART_TYPE.literal ||
                part.type !== PART_TYPE.literal) {
                all.push(part);
            }
            else {
                lastPart.value += part.value;
            }
            return all;
        }, []);
    }
    function isFormatXMLElementFn(el) {
        return typeof el === 'function';
    }
    // TODO(skeleton): add skeleton support
    function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
    // For debugging
    originalMessage) {
        // Hot path for straight simple msg translations
        if (els.length === 1 && isLiteralElement(els[0])) {
            return [
                {
                    type: PART_TYPE.literal,
                    value: els[0].value,
                },
            ];
        }
        var result = [];
        for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
            var el = els_1[_i];
            // Exit early for string parts.
            if (isLiteralElement(el)) {
                result.push({
                    type: PART_TYPE.literal,
                    value: el.value,
                });
                continue;
            }
            // TODO: should this part be literal type?
            // Replace `#` in plural rules with the actual numeric value.
            if (isPoundElement(el)) {
                if (typeof currentPluralValue === 'number') {
                    result.push({
                        type: PART_TYPE.literal,
                        value: formatters.getNumberFormat(locales).format(currentPluralValue),
                    });
                }
                continue;
            }
            var varName = el.value;
            // Enforce that all required values are provided by the caller.
            if (!(values && varName in values)) {
                throw new MissingValueError(varName, originalMessage);
            }
            var value = values[varName];
            if (isArgumentElement(el)) {
                if (!value || typeof value === 'string' || typeof value === 'number') {
                    value =
                        typeof value === 'string' || typeof value === 'number'
                            ? String(value)
                            : '';
                }
                result.push({
                    type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: value,
                });
                continue;
            }
            // Recursively format plural and select parts' option — which can be a
            // nested pattern structure. The choosing of the option to use is
            // abstracted-by and delegated-to the part helper object.
            if (isDateElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.date[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTimeElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.time[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isNumberElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.number[el.style]
                    : isNumberSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                if (style && style.scale) {
                    value =
                        value *
                            (style.scale || 1);
                }
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getNumberFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTagElement(el)) {
                var children = el.children, value_1 = el.value;
                var formatFn = values[value_1];
                if (!isFormatXMLElementFn(formatFn)) {
                    throw new InvalidValueTypeError(value_1, 'function', originalMessage);
                }
                var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
                var chunks = formatFn(parts.map(function (p) { return p.value; }));
                if (!Array.isArray(chunks)) {
                    chunks = [chunks];
                }
                result.push.apply(result, chunks.map(function (c) {
                    return {
                        type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                        value: c,
                    };
                }));
            }
            if (isSelectElement(el)) {
                var opt = el.options[value] || el.options.other;
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
                continue;
            }
            if (isPluralElement(el)) {
                var opt = el.options["=" + value];
                if (!opt) {
                    if (!Intl.PluralRules) {
                        throw new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", ErrorCode.MISSING_INTL_API, originalMessage);
                    }
                    var rule = formatters
                        .getPluralRules(locales, { type: el.pluralType })
                        .select(value - (el.offset || 0));
                    opt = el.options[rule] || el.options.other;
                }
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
                continue;
            }
        }
        return mergeLiteral(result);
    }

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    // -- MessageFormat --------------------------------------------------------
    function mergeConfig(c1, c2) {
        if (!c2) {
            return c1;
        }
        return __assign(__assign(__assign({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
            all[k] = __assign(__assign({}, c1[k]), (c2[k] || {}));
            return all;
        }, {}));
    }
    function mergeConfigs(defaultConfig, configs) {
        if (!configs) {
            return defaultConfig;
        }
        return Object.keys(defaultConfig).reduce(function (all, k) {
            all[k] = mergeConfig(defaultConfig[k], configs[k]);
            return all;
        }, __assign({}, defaultConfig));
    }
    function createFastMemoizeCache(store) {
        return {
            create: function () {
                return {
                    get: function (key) {
                        return store[key];
                    },
                    set: function (key, value) {
                        store[key] = value;
                    },
                };
            },
        };
    }
    function createDefaultFormatters(cache) {
        if (cache === void 0) { cache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        }; }
        return {
            getNumberFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.number),
                strategy: strategies.variadic,
            }),
            getDateTimeFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.dateTime),
                strategy: strategies.variadic,
            }),
            getPluralRules: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.pluralRules),
                strategy: strategies.variadic,
            }),
        };
    }
    var IntlMessageFormat = /** @class */ (function () {
        function IntlMessageFormat(message, locales, overrideFormats, opts) {
            var _this = this;
            if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
            this.formatterCache = {
                number: {},
                dateTime: {},
                pluralRules: {},
            };
            this.format = function (values) {
                var parts = _this.formatToParts(values);
                // Hot path for straight simple msg translations
                if (parts.length === 1) {
                    return parts[0].value;
                }
                var result = parts.reduce(function (all, part) {
                    if (!all.length ||
                        part.type !== PART_TYPE.literal ||
                        typeof all[all.length - 1] !== 'string') {
                        all.push(part.value);
                    }
                    else {
                        all[all.length - 1] += part.value;
                    }
                    return all;
                }, []);
                if (result.length <= 1) {
                    return result[0] || '';
                }
                return result;
            };
            this.formatToParts = function (values) {
                return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
            };
            this.resolvedOptions = function () { return ({
                locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
            }); };
            this.getAst = function () { return _this.ast; };
            if (typeof message === 'string') {
                this.message = message;
                if (!IntlMessageFormat.__parse) {
                    throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
                }
                // Parse string messages into an AST.
                this.ast = IntlMessageFormat.__parse(message, {
                    ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
                });
            }
            else {
                this.ast = message;
            }
            if (!Array.isArray(this.ast)) {
                throw new TypeError('A message must be provided as a String or AST.');
            }
            // Creates a new object with the specified `formats` merged with the default
            // formats.
            this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
            // Defined first because it's used to build the format pattern.
            this.locales = locales;
            this.formatters =
                (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
        }
        Object.defineProperty(IntlMessageFormat, "defaultLocale", {
            get: function () {
                if (!IntlMessageFormat.memoizedDefaultLocale) {
                    IntlMessageFormat.memoizedDefaultLocale =
                        new Intl.NumberFormat().resolvedOptions().locale;
                }
                return IntlMessageFormat.memoizedDefaultLocale;
            },
            enumerable: false,
            configurable: true
        });
        IntlMessageFormat.memoizedDefaultLocale = null;
        IntlMessageFormat.__parse = parse;
        // Default format options used as the prototype of the `formats` provided to the
        // constructor. These are used when constructing the internal Intl.NumberFormat
        // and Intl.DateTimeFormat instances.
        IntlMessageFormat.formats = {
            number: {
                integer: {
                    maximumFractionDigits: 0,
                },
                currency: {
                    style: 'currency',
                },
                percent: {
                    style: 'percent',
                },
            },
            date: {
                short: {
                    month: 'numeric',
                    day: 'numeric',
                    year: '2-digit',
                },
                medium: {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                },
                long: {
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
                full: {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
            },
            time: {
                short: {
                    hour: 'numeric',
                    minute: 'numeric',
                },
                medium: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                },
                long: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
                full: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
            },
        };
        return IntlMessageFormat;
    }());

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    var o = IntlMessageFormat;

    const r={},i=(e,n,t)=>t?(n in r||(r[n]={}),e in r[n]||(r[n][e]=t),t):t,l=(e,n)=>{if(null==n)return;if(n in r&&e in r[n])return r[n][e];const t=E(n);for(let o=0;o<t.length;o++){const r=c(t[o],e);if(r)return i(e,n,r)}};let a;const s=writable({});function u(e){return e in a}function c(e,n){if(!u(e))return null;return function(e,n){if(null==n)return;if(n in e)return e[n];const t=n.split(".");let o=e;for(let e=0;e<t.length;e++)if("object"==typeof o){if(e>0){const n=t.slice(e,t.length).join(".");if(n in o){o=o[n];break}}o=o[t[e]];}else o=void 0;return o}(function(e){return a[e]||null}(e),n)}function m(e,...n){delete r[e],s.update((o=>(o[e]=cjs.all([o[e]||{},...n]),o)));}const f=derived([s],(([e])=>Object.keys(e)));s.subscribe((e=>a=e));const d={};function g(e){return d[e]}function w(e){return null!=e&&E(e).some((e=>{var n;return null===(n=g(e))||void 0===n?void 0:n.size}))}function h(e,n){return Promise.all(n.map((n=>(function(e,n){d[e].delete(n),0===d[e].size&&delete d[e];}(e,n),n().then((e=>e.default||e)))))).then((n=>m(e,...n)))}const p={};function b(e){if(!w(e))return e in p?p[e]:Promise.resolve();const n=function(e){return E(e).map((e=>{const n=g(e);return [e,n?[...n]:[]]})).filter((([,e])=>e.length>0))}(e);return p[e]=Promise.all(n.map((([e,n])=>h(e,n)))).then((()=>{if(w(e))return b(e);delete p[e];})),p[e]}function y(e,n){g(e)||function(e){d[e]=new Set;}(e);const t=g(e);g(e).has(n)||(u(e)||s.update((n=>(n[e]={},n))),t.add(n));}
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function v(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&n.indexOf(o)<0&&(t[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(o=Object.getOwnPropertySymbols(e);r<o.length;r++)n.indexOf(o[r])<0&&Object.prototype.propertyIsEnumerable.call(e,o[r])&&(t[o[r]]=e[o[r]]);}return t}const O={fallbackLocale:null,loadingDelay:200,formats:{number:{scientific:{notation:"scientific"},engineering:{notation:"engineering"},compactLong:{notation:"compact",compactDisplay:"long"},compactShort:{notation:"compact",compactDisplay:"short"}},date:{short:{month:"numeric",day:"numeric",year:"2-digit"},medium:{month:"short",day:"numeric",year:"numeric"},long:{month:"long",day:"numeric",year:"numeric"},full:{weekday:"long",month:"long",day:"numeric",year:"numeric"}},time:{short:{hour:"numeric",minute:"numeric"},medium:{hour:"numeric",minute:"numeric",second:"numeric"},long:{hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"short"},full:{hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"short"}}},warnOnMissingMessages:!0,ignoreTag:!0};function j(){return O}function $(e){const{formats:n}=e,t=v(e,["formats"]),o=e.initialLocale||e.fallbackLocale;return Object.assign(O,t,{initialLocale:o}),n&&("number"in n&&Object.assign(O.formats.number,n.number),"date"in n&&Object.assign(O.formats.date,n.date),"time"in n&&Object.assign(O.formats.time,n.time)),M.set(o)}const k=writable(!1);let L;const T=writable(null);function x(e){return e.split("-").map(((e,n,t)=>t.slice(0,n+1).join("-"))).reverse()}function E(e,n=j().fallbackLocale){const t=x(e);return n?[...new Set([...t,...x(n)])]:t}function D(){return null!=L?L:void 0}T.subscribe((e=>{L=null!=e?e:void 0,"undefined"!=typeof window&&null!=e&&document.documentElement.setAttribute("lang",e);}));const M=Object.assign(Object.assign({},T),{set:e=>{if(e&&function(e){if(null==e)return;const n=E(e);for(let e=0;e<n.length;e++){const t=n[e];if(u(t))return t}}(e)&&w(e)){const{loadingDelay:n}=j();let t;return "undefined"!=typeof window&&null!=D()&&n?t=window.setTimeout((()=>k.set(!0)),n):k.set(!0),b(e).then((()=>{T.set(e);})).finally((()=>{clearTimeout(t),k.set(!1);}))}return T.set(e)}}),I=()=>"undefined"==typeof window?null:window.navigator.language||window.navigator.languages[0],Z=e=>{const n=Object.create(null);return t=>{const o=JSON.stringify(t);return o in n?n[o]:n[o]=e(t)}},C=(e,n)=>{const{formats:t}=j();if(e in t&&n in t[e])return t[e][n];throw new Error(`[svelte-i18n] Unknown "${n}" ${e} format.`)},G=Z((e=>{var{locale:n,format:t}=e,o=v(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format numbers');return t&&(o=C("number",t)),new Intl.NumberFormat(n,o)})),J=Z((e=>{var{locale:n,format:t}=e,o=v(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format dates');return t?o=C("date",t):0===Object.keys(o).length&&(o=C("date","short")),new Intl.DateTimeFormat(n,o)})),U=Z((e=>{var{locale:n,format:t}=e,o=v(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format time values');return t?o=C("time",t):0===Object.keys(o).length&&(o=C("time","short")),new Intl.DateTimeFormat(n,o)})),_=(e={})=>{var{locale:n=D()}=e,t=v(e,["locale"]);return G(Object.assign({locale:n},t))},q=(e={})=>{var{locale:n=D()}=e,t=v(e,["locale"]);return J(Object.assign({locale:n},t))},B=(e={})=>{var{locale:n=D()}=e,t=v(e,["locale"]);return U(Object.assign({locale:n},t))},H=Z(((e,n=D())=>new o(e,n,j().formats,{ignoreTag:j().ignoreTag}))),K=(e,n={})=>{let t=n;"object"==typeof e&&(t=e,e=t.id);const{values:o,locale:r=D(),default:i}=t;if(null==r)throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");let a=l(e,r);if(a){if("string"!=typeof a)return console.warn(`[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof a}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`),a}else j().warnOnMissingMessages&&console.warn(`[svelte-i18n] The message "${e}" was not found in "${E(r).join('", "')}".${w(D())?"\n\nNote: there are at least one loader still registered to this locale that wasn't executed.":""}`),a=null!=i?i:e;if(!o)return a;let s=a;try{s=H(a,r).format(o);}catch(n){console.warn(`[svelte-i18n] Message "${e}" has syntax error:`,n.message);}return s},Q=(e,n)=>B(n).format(e),R=(e,n)=>q(n).format(e),V=(e,n)=>_(n).format(e),W=(e,n=D())=>l(e,n),X=derived([M,s],(()=>K));derived([M],(()=>Q));derived([M],(()=>R));derived([M],(()=>V));derived([M,s],(()=>W));

    /* src/components/Footer.svelte generated by Svelte v3.44.0 */
    const file$h = "src/components/Footer.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (10:8) <Col xs="12" md="4" lg="6" class="px-4 mt-2">
    function create_default_slot_5$7(ctx) {
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Footer_intro") + "";
    	let t0;
    	let t1;
    	let a;
    	let picture;
    	let source0;
    	let t2;
    	let source1;
    	let t3;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			a = element("a");
    			picture = element("picture");
    			source0 = element("source");
    			t2 = space();
    			source1 = element("source");
    			t3 = space();
    			img = element("img");
    			attr_dev(p, "class", "svelte-vxfk2x");
    			add_location(p, file$h, 10, 10, 256);
    			attr_dev(source0, "media", "(max-width: 600px)");
    			attr_dev(source0, "srcset", "/img/open-knowledge-belgium-footer.svg 113w");
    			add_location(source0, file$h, 15, 14, 386);
    			attr_dev(source1, "media", "(min-width: 600px)");
    			attr_dev(source1, "srcset", "/img/open-knowledge-belgium-footer.svg 266w");
    			add_location(source1, file$h, 18, 14, 523);
    			attr_dev(img, "class", "Footer_footer__img__4N03j svelte-vxfk2x");
    			if (!src_url_equal(img.src, img_src_value = "/img/open-knowledge-belgium-footer.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Open Knowlegde Belgium");
    			add_location(img, file$h, 21, 14, 660);
    			add_location(picture, file$h, 14, 12, 362);
    			attr_dev(a, "href", "https://be.okfn.org/");
    			attr_dev(a, "class", "svelte-vxfk2x");
    			add_location(a, file$h, 13, 10, 318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a, anchor);
    			append_dev(a, picture);
    			append_dev(picture, source0);
    			append_dev(picture, t2);
    			append_dev(picture, source1);
    			append_dev(picture, t3);
    			append_dev(picture, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Footer_intro") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$7.name,
    		type: "slot",
    		source: "(10:8) <Col xs=\\\"12\\\" md=\\\"4\\\" lg=\\\"6\\\" class=\\\"px-4 mt-2\\\">",
    		ctx
    	});

    	return block;
    }

    // (46:12) {#each $locales as locale}
    function create_each_block(ctx) {
    	let option;
    	let t_value = /*locale*/ ctx[4] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*locale*/ ctx[4];
    			option.value = option.__value;
    			add_location(option, file$h, 46, 14, 1630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$locales*/ 4 && t_value !== (t_value = /*locale*/ ctx[4] + "")) set_data_dev(t, t_value);

    			if (dirty & /*$locales*/ 4 && option_value_value !== (option_value_value = /*locale*/ ctx[4])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(46:12) {#each $locales as locale}",
    		ctx
    	});

    	return block;
    }

    // (29:8) <Col xs="6" md="4" lg="3" class="px-4 mt-2">
    function create_default_slot_4$8(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[0]("Footer_nav_title") + "";
    	let t0;
    	let t1;
    	let ul;
    	let li0;
    	let a0;
    	let t2_value = /*$_*/ ctx[0]("The_data") + "";
    	let t2;
    	let t3;
    	let li1;
    	let a1;
    	let t4_value = /*$_*/ ctx[0]("About") + "";
    	let t4;
    	let t5;
    	let li2;
    	let a2;
    	let t6_value = /*$_*/ ctx[0]("FAQ") + "";
    	let t6;
    	let t7;
    	let select;
    	let mounted;
    	let dispose;
    	let each_value = /*$locales*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			ul = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t2 = text(t2_value);
    			t3 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t4 = text(t4_value);
    			t5 = space();
    			li2 = element("li");
    			a2 = element("a");
    			t6 = text(t6_value);
    			t7 = space();
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h3, "class", "text-uppercase");
    			add_location(h3, file$h, 29, 10, 940);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noopener noreferrer");
    			attr_dev(a0, "href", "/datamap");
    			attr_dev(a0, "class", "svelte-vxfk2x");
    			add_location(a0, file$h, 33, 14, 1111);
    			attr_dev(li0, "class", "mb-3");
    			add_location(li0, file$h, 32, 12, 1079);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noopener noreferrer");
    			attr_dev(a1, "href", "/about");
    			attr_dev(a1, "class", "svelte-vxfk2x");
    			add_location(a1, file$h, 37, 14, 1272);
    			attr_dev(li1, "class", "mb-3");
    			add_location(li1, file$h, 36, 12, 1240);
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noopener noreferrer");
    			attr_dev(a2, "href", "/faq");
    			attr_dev(a2, "class", "svelte-vxfk2x");
    			add_location(a2, file$h, 41, 14, 1428);
    			attr_dev(li2, "class", "mb-3");
    			add_location(li2, file$h, 40, 12, 1396);
    			attr_dev(ul, "class", "list-unstyled text-muted mb-6 mb-md-8 mb-lg-0");
    			add_location(ul, file$h, 31, 10, 1008);
    			if (/*$locale*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[3].call(select));
    			add_location(select, file$h, 44, 10, 1545);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t2);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t4);
    			append_dev(ul, t5);
    			append_dev(ul, li2);
    			append_dev(li2, a2);
    			append_dev(a2, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, select, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$locale*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[3]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Footer_nav_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("The_data") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("About") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("FAQ") + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$locales*/ 4) {
    				each_value = /*$locales*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$locale, $locales*/ 6) {
    				select_option(select, /*$locale*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(ul);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(select);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(29:8) <Col xs=\\\"6\\\" md=\\\"4\\\" lg=\\\"3\\\" class=\\\"px-4 mt-2\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:8) <Col xs="6" md="4" lg="3" class="px-4 mt-2">
    function create_default_slot_3$9(ctx) {
    	let h3;
    	let t0_value = /*$_*/ ctx[0]("Footer_contact") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t3;
    	let p1;
    	let t5;
    	let p2;
    	let t7;
    	let a0;
    	let t9;
    	let div;
    	let a1;
    	let svg0;
    	let path0;
    	let a2;
    	let svg1;
    	let path1;
    	let a3;
    	let svg2;
    	let path2;
    	let a4;
    	let svg3;
    	let path3;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Open Knowledge Belgium";
    			t3 = space();
    			p1 = element("p");
    			p1.textContent = "Cantersteen 12";
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "1000 Brussels";
    			t7 = space();
    			a0 = element("a");
    			a0.textContent = "bikedataproject@openknowledge.be";
    			t9 = space();
    			div = element("div");
    			a1 = element("a");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			a2 = element("a");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			a3 = element("a");
    			svg2 = svg_element("svg");
    			path2 = svg_element("path");
    			a4 = element("a");
    			svg3 = svg_element("svg");
    			path3 = svg_element("path");
    			attr_dev(h3, "class", "text-uppercase");
    			add_location(h3, file$h, 51, 10, 1791);
    			attr_dev(p0, "class", "Footer_footer__contactBold__3W-zb svelte-vxfk2x");
    			add_location(p0, file$h, 52, 10, 1856);
    			attr_dev(p1, "class", "svelte-vxfk2x");
    			add_location(p1, file$h, 55, 10, 1962);
    			attr_dev(p2, "class", "svelte-vxfk2x");
    			add_location(p2, file$h, 56, 10, 1994);
    			attr_dev(a0, "href", "mailto:bikedataproject@openknowledge.be");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noopener noreferrer");
    			attr_dev(a0, "class", "svelte-vxfk2x");
    			add_location(a0, file$h, 57, 10, 2025);
    			attr_dev(path0, "d", "M16.5 0C7.38869 0 0 7.38869 0 16.5C0 25.6113 7.38869 33 16.5 33C25.6113 33 33 25.6113 33 16.5C33 7.38869 25.6113 0 16.5 0ZM24.0337 12.8649C24.041 13.0273 24.0445 13.1905 24.0445 13.3544C24.0445 18.3588 20.2353 24.1296 13.269 24.1299H13.2693H13.269C11.1302 24.1299 9.14001 23.503 7.46397 22.4287C7.76031 22.4637 8.06193 22.481 8.36732 22.481C10.1418 22.481 11.7748 21.8758 13.0711 20.8599C11.4132 20.8292 10.0154 19.7342 9.53302 18.2294C9.76389 18.2737 10.0013 18.2979 10.2448 18.2979C10.5905 18.2979 10.9253 18.2513 11.2435 18.1645C9.51061 17.8175 8.20518 16.286 8.20518 14.4521C8.20518 14.435 8.20518 14.4196 8.20569 14.4038C8.71603 14.6875 9.29963 14.8582 9.921 14.8773C8.9041 14.1988 8.23565 13.0389 8.23565 11.7249C8.23565 11.0311 8.42322 10.381 8.7485 9.8213C10.6161 12.1129 13.4073 13.62 16.5549 13.7784C16.4899 13.5009 16.4564 13.2119 16.4564 12.9148C16.4564 10.8241 18.1526 9.12792 20.2441 9.12792C21.3335 9.12792 22.3174 9.58841 23.0085 10.3246C23.8713 10.1544 24.6815 9.83917 25.4134 9.40537C25.1302 10.2893 24.53 11.0311 23.748 11.5001C24.5141 11.4085 25.2442 11.2053 25.9227 10.9037C25.4159 11.6632 24.7732 12.3304 24.0337 12.8649V12.8649Z");
    			attr_dev(path0, "fill", "white");
    			add_location(path0, file$h, 72, 17, 2576);
    			attr_dev(svg0, "width", "33");
    			attr_dev(svg0, "height", "33");
    			attr_dev(svg0, "viewBox", "0 0 33 33");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg0, file$h, 66, 15, 2384);
    			attr_dev(a1, "href", "https://twitter.com/bikedataproject");
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noopener noreferrer");
    			attr_dev(a1, "class", "svelte-vxfk2x");
    			add_location(a1, file$h, 62, 12, 2239);
    			attr_dev(path1, "d", "M33 16.5C33 7.38633 25.6137 0 16.5 0C7.38633 0 0 7.38633 0 16.5C0 25.6137 7.38633 33 16.5 33C16.5967 33 16.6934 33 16.79 32.9936V20.1545H13.2451V16.023H16.79V12.9809C16.79 9.45527 18.9428 7.53457 22.0881 7.53457C23.5963 7.53457 24.8918 7.64414 25.2656 7.6957V11.3824H23.1C21.392 11.3824 21.0568 12.1945 21.0568 13.3869V16.0166H25.1496L24.6146 20.148H21.0568V32.3619C27.9533 30.3832 33 24.0346 33 16.5V16.5Z");
    			attr_dev(path1, "fill", "white");
    			add_location(path1, file$h, 87, 17, 4191);
    			attr_dev(svg1, "width", "33");
    			attr_dev(svg1, "height", "33");
    			attr_dev(svg1, "viewBox", "0 0 33 33");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg1, file$h, 81, 15, 3999);
    			attr_dev(a2, "href", "https://www.facebook.com/BikeDataProject");
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noopener noreferrer");
    			attr_dev(a2, "class", "svelte-vxfk2x");
    			add_location(a2, file$h, 77, 13, 3849);
    			attr_dev(path2, "fill-rule", "evenodd");
    			attr_dev(path2, "clip-rule", "evenodd");
    			attr_dev(path2, "d", "M33 16.5C33 25.6127 25.6127 33 16.5 33C7.3873 33 0 25.6127 0 16.5C0 7.3873 7.3873 0 16.5 0C25.6127 0 33 7.3873 33 16.5ZM13.8419 6.53378C12.7402 6.5346 11.8485 7.42691 11.8493 8.52645C11.8485 9.62599 12.741 10.5183 13.8427 10.5191H15.8361V8.52726C15.8369 7.42772 14.9445 6.53541 13.8419 6.53378ZM13.8419 11.8486H8.52782C7.42608 11.8494 6.53361 12.7418 6.53443 13.8413C6.5328 14.9408 7.42526 15.8331 8.52701 15.8348H13.8419C14.9437 15.834 15.8361 14.9417 15.8353 13.8421C15.8361 12.7418 14.9437 11.8494 13.8419 11.8486ZM24.4717 11.8486C25.5734 11.8494 26.4659 12.7418 26.4651 13.8413C26.4659 14.9417 25.5734 15.834 24.4717 15.8348H22.4783V13.8413C22.4775 12.7418 23.3699 11.8494 24.4717 11.8486ZM21.1502 8.52645V13.8413C21.151 14.9417 20.2585 15.834 19.1568 15.8348C18.055 15.8331 17.1626 14.9408 17.1642 13.8413V8.52645C17.1634 7.42691 18.0558 6.5346 19.1576 6.53378C20.2593 6.53541 21.151 7.42772 21.1502 8.52645ZM19.1568 26.4628C20.2586 26.4619 21.1511 25.5696 21.1502 24.4701C21.1511 23.3706 20.2586 22.4782 19.1568 22.4774H17.1635V24.4701C17.1626 25.5688 18.0551 26.4611 19.1568 26.4628ZM19.1568 21.1471H24.4718C25.5735 21.1463 26.466 20.254 26.4652 19.1544C26.4668 18.0549 25.5743 17.1626 24.4726 17.1609H19.1577C18.0559 17.1618 17.1635 18.0541 17.1643 19.1536C17.1635 20.254 18.0551 21.1463 19.1568 21.1471ZM8.52782 21.1501C7.42608 21.1493 6.53361 20.257 6.53442 19.1574C6.53361 18.0579 7.42608 17.1656 8.52782 17.1648H10.5212V19.1574C10.522 20.257 9.62956 21.1493 8.52782 21.1501ZM11.8493 24.4723V19.1574C11.8485 18.0579 12.7402 17.1656 13.8427 17.1656C14.9445 17.1672 15.8369 18.0595 15.8353 19.1591V24.4731C15.8361 25.5726 14.9437 26.4649 13.8419 26.4658C12.7402 26.4641 11.8477 25.5718 11.8493 24.4723Z");
    			attr_dev(path2, "fill", "white");
    			add_location(path2, file$h, 102, 17, 5110);
    			attr_dev(svg2, "width", "33");
    			attr_dev(svg2, "height", "33");
    			attr_dev(svg2, "viewBox", "0 0 33 33");
    			attr_dev(svg2, "fill", "none");
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg2, file$h, 96, 15, 4918);
    			attr_dev(a3, "href", "https://join.slack.com/t/bikedataproject/shared_invite/zt-g60t5w5c-lT2ucV0HtLEVnE4_wG9hTg");
    			attr_dev(a3, "target", "_blank");
    			attr_dev(a3, "rel", "noopener noreferrer");
    			attr_dev(a3, "class", "svelte-vxfk2x");
    			add_location(a3, file$h, 92, 13, 4719);
    			attr_dev(path3, "d", "M16 0C7.15983 0 0 7.26871 0 16.2433C0 23.877 5.15949 30.2125 12.1205 31.9986C12.0402 31.7954 12.0007 31.5106 12.0007 31.2272V28.4652H10.0003C8.92051 28.4652 7.91966 27.9786 7.47983 27.0842C6.95966 26.1096 6.87932 24.6069 5.55983 23.6724C5.15949 23.3475 5.47949 23.0226 5.91932 23.0627C6.75949 23.306 7.43898 23.8756 8.07898 24.7271C8.71898 25.5801 8.99949 25.7833 10.1991 25.7833C10.7588 25.7833 11.6385 25.7432 12.4391 25.6202C12.879 24.4825 13.6388 23.4678 14.5593 22.9812C9.19966 22.3314 6.63966 19.6509 6.63966 15.9959C6.63966 14.4116 7.31915 12.9089 8.43983 11.6095C8.08034 10.3501 7.59966 7.75117 8.60051 6.73648C11.0012 6.73648 12.4405 8.32072 12.8 8.72576C13.9997 8.31934 15.3205 8.07603 16.6795 8.07603C18.0793 8.07603 19.3593 8.31934 20.559 8.72576C20.9185 8.31934 22.3591 6.73648 24.7585 6.73648C25.7185 7.71108 25.2786 10.3501 24.8783 11.6095C25.999 12.8688 26.639 14.4116 26.639 15.9959C26.639 19.6509 24.1185 22.3314 18.7997 22.8996C20.2798 23.671 21.3202 25.8635 21.3202 27.4878V31.1871C21.3202 31.3088 21.2807 31.4304 21.2807 31.5521C27.52 29.3596 32 23.3503 32 16.2433C32 7.26871 24.8402 0 16 0Z");
    			attr_dev(path3, "fill", "white");
    			add_location(path3, file$h, 119, 17, 7355);
    			attr_dev(svg3, "width", "32");
    			attr_dev(svg3, "height", "32");
    			attr_dev(svg3, "viewBox", "0 0 32 32");
    			attr_dev(svg3, "fill", "none");
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg3, file$h, 113, 15, 7163);
    			attr_dev(a4, "href", "https://github.com/bikedataproject");
    			attr_dev(a4, "target", "_blank");
    			attr_dev(a4, "rel", "noopener noreferrer");
    			attr_dev(a4, "class", "svelte-vxfk2x");
    			add_location(a4, file$h, 109, 13, 7019);
    			attr_dev(div, "class", "socials mt-4 svelte-vxfk2x");
    			add_location(div, file$h, 61, 10, 2200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p2, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, a0, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, a1);
    			append_dev(a1, svg0);
    			append_dev(svg0, path0);
    			append_dev(div, a2);
    			append_dev(a2, svg1);
    			append_dev(svg1, path1);
    			append_dev(div, a3);
    			append_dev(a3, svg2);
    			append_dev(svg2, path2);
    			append_dev(div, a4);
    			append_dev(a4, svg3);
    			append_dev(svg3, path3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Footer_contact") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(51:8) <Col xs=\\\"6\\\" md=\\\"4\\\" lg=\\\"3\\\" class=\\\"px-4 mt-2\\\">",
    		ctx
    	});

    	return block;
    }

    // (9:6) <Row>
    function create_default_slot_2$e(ctx) {
    	let col0;
    	let t0;
    	let col1;
    	let t1;
    	let col2;
    	let current;

    	col0 = new Col({
    			props: {
    				xs: "12",
    				md: "4",
    				lg: "6",
    				class: "px-4 mt-2",
    				$$slots: { default: [create_default_slot_5$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "6",
    				md: "4",
    				lg: "3",
    				class: "px-4 mt-2",
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col2 = new Col({
    			props: {
    				xs: "6",
    				md: "4",
    				lg: "3",
    				class: "px-4 mt-2",
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col0.$$.fragment);
    			t0 = space();
    			create_component(col1.$$.fragment);
    			t1 = space();
    			create_component(col2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(col1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(col2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col0_changes = {};

    			if (dirty & /*$$scope, $_*/ 129) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope, $locale, $locales, $_*/ 135) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    			const col2_changes = {};

    			if (dirty & /*$$scope, $_*/ 129) {
    				col2_changes.$$scope = { dirty, ctx };
    			}

    			col2.$set(col2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			transition_in(col2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			transition_out(col2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(col1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(col2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(9:6) <Row>",
    		ctx
    	});

    	return block;
    }

    // (8:4) <Container>
    function create_default_slot_1$e(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_, $locale, $locales*/ 135) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(8:4) <Container>",
    		ctx
    	});

    	return block;
    }

    // (131:4) <Row class="p-4">
    function create_default_slot$g(ctx) {
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Footer_copyright_one") + "";
    	let t0;
    	let t1;
    	let a;
    	let t3;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			a = element("a");
    			a.textContent = "Creative Commons Attribution 4.0 International License";
    			t3 = text(".");
    			attr_dev(a, "href", "https://creativecommons.org/licenses/by/4.0");
    			attr_dev(a, "class", "svelte-vxfk2x");
    			add_location(a, file$h, 133, 8, 8751);
    			attr_dev(p, "class", "svelte-vxfk2x");
    			add_location(p, file$h, 131, 6, 8702);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, a);
    			append_dev(p, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Footer_copyright_one") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(131:4) <Row class=\\\"p-4\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let footer;
    	let div0;
    	let container;
    	let t;
    	let div1;
    	let row;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row = new Row({
    			props: {
    				class: "p-4",
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			div0 = element("div");
    			create_component(container.$$.fragment);
    			t = space();
    			div1 = element("div");
    			create_component(row.$$.fragment);
    			attr_dev(div0, "class", "pb-5");
    			add_location(div0, file$h, 6, 2, 145);
    			attr_dev(div1, "class", "subfooter svelte-vxfk2x");
    			add_location(div1, file$h, 129, 2, 8650);
    			attr_dev(footer, "class", "pt-5");
    			add_location(footer, file$h, 5, 0, 121);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			append_dev(footer, div0);
    			mount_component(container, div0, null);
    			append_dev(footer, t);
    			append_dev(footer, div1);
    			mount_component(row, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope, $_, $locale, $locales*/ 135) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    			const row_changes = {};

    			if (dirty & /*$$scope, $_*/ 129) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			destroy_component(container);
    			destroy_component(row);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $_;
    	let $locale;
    	let $locales;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	validate_store(M, 'locale');
    	component_subscribe($$self, M, $$value => $$invalidate(1, $locale = $$value));
    	validate_store(f, 'locales');
    	component_subscribe($$self, f, $$value => $$invalidate(2, $locales = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Footer', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		$locale = select_value(this);
    		M.set($locale);
    	}

    	$$self.$capture_state = () => ({
    		Col,
    		Container,
    		Row,
    		_: X,
    		locale: M,
    		locales: f,
    		$_,
    		$locale,
    		$locales
    	});

    	return [$_, $locale, $locales, select_change_handler];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/components/Navbar.svelte generated by Svelte v3.44.0 */
    const file$g = "src/components/Navbar.svelte";

    // (9:6) <Link class="nav-link m-2" to="datamap">
    function create_default_slot_2$d(ctx) {
    	let t_value = /*$_*/ ctx[0]("The_data") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("The_data") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(9:6) <Link class=\\\"nav-link m-2\\\" to=\\\"datamap\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:6) <Link class="nav-link m-2" to="faq">
    function create_default_slot_1$d(ctx) {
    	let t_value = /*$_*/ ctx[0]("FAQ") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("FAQ") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(12:6) <Link class=\\\"nav-link m-2\\\" to=\\\"faq\\\">",
    		ctx
    	});

    	return block;
    }

    // (15:6) <Link class="nav-link m-2" to="about">
    function create_default_slot$f(ctx) {
    	let t_value = /*$_*/ ctx[0]("About") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("About") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(15:6) <Link class=\\\"nav-link m-2\\\" to=\\\"about\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div;
    	let ul;
    	let li0;
    	let link0;
    	let t0;
    	let li1;
    	let link1;
    	let t1;
    	let li2;
    	let link2;
    	let t2;
    	let li3;
    	let a0;
    	let t3_value = /*$_*/ ctx[0]("Wiki") + "";
    	let t3;
    	let t4;
    	let li4;
    	let a1;
    	let t5_value = /*$_*/ ctx[0]("Contribute") + "";
    	let t5;
    	let current;

    	link0 = new Link$1({
    			props: {
    				class: "nav-link m-2",
    				to: "datamap",
    				$$slots: { default: [create_default_slot_2$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link$1({
    			props: {
    				class: "nav-link m-2",
    				to: "faq",
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link$1({
    			props: {
    				class: "nav-link m-2",
    				to: "about",
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			create_component(link0.$$.fragment);
    			t0 = space();
    			li1 = element("li");
    			create_component(link1.$$.fragment);
    			t1 = space();
    			li2 = element("li");
    			create_component(link2.$$.fragment);
    			t2 = space();
    			li3 = element("li");
    			a0 = element("a");
    			t3 = text(t3_value);
    			t4 = space();
    			li4 = element("li");
    			a1 = element("a");
    			t5 = text(t5_value);
    			attr_dev(li0, "class", "nav-item active");
    			add_location(li0, file$g, 7, 4, 186);
    			attr_dev(li1, "class", "nav-item");
    			add_location(li1, file$g, 10, 4, 299);
    			attr_dev(li2, "class", "nav-item");
    			add_location(li2, file$g, 13, 4, 396);
    			attr_dev(a0, "class", "nav-link m-2");
    			attr_dev(a0, "href", "https://wiki.bikedataproject.org/");
    			add_location(a0, file$g, 17, 6, 525);
    			attr_dev(li3, "class", "nav-item");
    			add_location(li3, file$g, 16, 4, 497);
    			attr_dev(a1, "type", "button");
    			attr_dev(a1, "class", "btn btn-primary m-2");
    			attr_dev(a1, "href", "#share-section");
    			add_location(a1, file$g, 20, 6, 649);
    			attr_dev(li4, "class", "nav-item");
    			add_location(li4, file$g, 19, 4, 621);
    			attr_dev(ul, "class", "navbar-nav ms-auto");
    			add_location(ul, file$g, 6, 2, 150);
    			attr_dev(div, "class", "collapse navbar-collapse");
    			attr_dev(div, "id", "navbarNav");
    			add_location(div, file$g, 5, 0, 94);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			mount_component(link0, li0, null);
    			append_dev(ul, t0);
    			append_dev(ul, li1);
    			mount_component(link1, li1, null);
    			append_dev(ul, t1);
    			append_dev(ul, li2);
    			mount_component(link2, li2, null);
    			append_dev(ul, t2);
    			append_dev(ul, li3);
    			append_dev(li3, a0);
    			append_dev(a0, t3);
    			append_dev(ul, t4);
    			append_dev(ul, li4);
    			append_dev(li4, a1);
    			append_dev(a1, t5);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link0_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			if ((!current || dirty & /*$_*/ 1) && t3_value !== (t3_value = /*$_*/ ctx[0]("Wiki") + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*$_*/ 1) && t5_value !== (t5_value = /*$_*/ ctx[0]("Contribute") + "")) set_data_dev(t5, t5_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(link2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navbar', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Link: Link$1, _: X, $_ });
    	return [$_];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src/components/Header.svelte generated by Svelte v3.44.0 */
    const file$f = "src/components/Header.svelte";

    // (7:8) <Link class="navbar-brand" to="/">
    function create_default_slot$e(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;
    	let path6;
    	let path7;
    	let path8;
    	let path9;
    	let path10;
    	let path11;
    	let path12;
    	let path13;
    	let path14;
    	let path15;
    	let path16;
    	let path17;
    	let path18;
    	let path19;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			path18 = svg_element("path");
    			path19 = svg_element("path");
    			attr_dev(path0, "d", "M63.2991 16.6398C64.1257 16.8798 64.7591 17.2998 65.1991 17.8998C65.6524 18.4998 65.8791 19.2398 65.8791 20.1198C65.8791 21.3331 65.4457 22.2865 64.5791 22.9798C63.7257 23.6598 62.5324 23.9998 60.9991 23.9998H54.5391V9.75979H60.7991C62.2657 9.75979 63.4191 10.0931 64.2591 10.7598C65.0991 11.4131 65.5191 12.3198 65.5191 13.4798C65.5191 14.2265 65.3191 14.8798 64.9191 15.4398C64.5324 15.9865 63.9924 16.3865 63.2991 16.6398ZM57.0591 15.7598H60.3791C62.1657 15.7598 63.0591 15.0931 63.0591 13.7598C63.0591 13.0931 62.8391 12.5931 62.3991 12.2598C61.9591 11.9265 61.2857 11.7598 60.3791 11.7598H57.0591V15.7598ZM60.7191 21.9998C61.6524 21.9998 62.3324 21.8331 62.7591 21.4998C63.1991 21.1665 63.4191 20.6398 63.4191 19.9198C63.4191 19.1865 63.1991 18.6465 62.7591 18.2998C62.3324 17.9531 61.6524 17.7798 60.7191 17.7798H57.0591V21.9998H60.7191Z");
    			attr_dev(path0, "fill", "white");
    			add_location(path0, file$f, 15, 16, 511);
    			attr_dev(path1, "d", "M68.4677 23.9998V13.8998H70.9477V23.9998H68.4677ZM68.3077 9.31979H71.0877V11.7798H68.3077V9.31979Z");
    			attr_dev(path1, "fill", "white");
    			add_location(path1, file$f, 19, 16, 1453);
    			attr_dev(path2, "d", "M84.0025 23.9998H80.8825L76.4625 19.3398V23.9998H73.9825V9.27979H76.4625V18.3598L80.6225 13.9198H83.6425L79.1025 18.7398L84.0025 23.9998Z");
    			attr_dev(path2, "fill", "white");
    			add_location(path2, file$f, 23, 16, 1650);
    			attr_dev(path3, "d", "M94.0014 19.0798H87.0414C87.0947 20.1598 87.3614 20.9598 87.8414 21.4798C88.3347 21.9865 89.0614 22.2398 90.0214 22.2398C91.1281 22.2398 92.1547 21.8798 93.1014 21.1598L93.8214 22.8798C93.3414 23.2665 92.7481 23.5798 92.0414 23.8198C91.3481 24.0465 90.6414 24.1598 89.9214 24.1598C88.2681 24.1598 86.9681 23.6931 86.0214 22.7598C85.0747 21.8265 84.6014 20.5465 84.6014 18.9198C84.6014 17.8931 84.8081 16.9798 85.2214 16.1798C85.6347 15.3798 86.2147 14.7598 86.9614 14.3198C87.7081 13.8665 88.5547 13.6398 89.5014 13.6398C90.8881 13.6398 91.9814 14.0931 92.7814 14.9998C93.5947 15.8931 94.0014 17.1265 94.0014 18.6998V19.0798ZM89.5614 15.4398C88.8947 15.4398 88.3481 15.6398 87.9214 16.0398C87.5081 16.4265 87.2414 16.9931 87.1214 17.7398H91.8214C91.7414 16.9798 91.5081 16.4065 91.1214 16.0198C90.7481 15.6331 90.2281 15.4398 89.5614 15.4398Z");
    			attr_dev(path3, "fill", "white");
    			add_location(path3, file$f, 27, 16, 1886);
    			attr_dev(path4, "d", "M102.387 9.75979H107.627C109.96 9.75979 111.767 10.3798 113.047 11.6198C114.34 12.8598 114.987 14.6065 114.987 16.8598C114.987 19.1265 114.34 20.8865 113.047 22.1398C111.767 23.3798 109.96 23.9998 107.627 23.9998H102.387V9.75979ZM107.467 21.8998C110.747 21.8998 112.387 20.2198 112.387 16.8598C112.387 13.5265 110.747 11.8598 107.467 11.8598H104.967V21.8998H107.467Z");
    			attr_dev(path4, "fill", "white");
    			add_location(path4, file$f, 31, 16, 2827);
    			attr_dev(path5, "d", "M127.401 13.8998V23.9998H124.941V22.3798C124.634 22.9398 124.194 23.3798 123.621 23.6998C123.048 24.0065 122.394 24.1598 121.661 24.1598C120.781 24.1598 120.001 23.9465 119.321 23.5198C118.641 23.0931 118.114 22.4865 117.741 21.6998C117.368 20.9131 117.181 19.9998 117.181 18.9598C117.181 17.9198 117.368 16.9998 117.741 16.1998C118.128 15.3865 118.661 14.7598 119.341 14.3198C120.021 13.8665 120.794 13.6398 121.661 13.6398C122.394 13.6398 123.048 13.7998 123.621 14.1198C124.194 14.4265 124.634 14.8598 124.941 15.4198V13.8998H127.401ZM122.341 22.1998C123.168 22.1998 123.808 21.9131 124.261 21.3398C124.714 20.7665 124.941 19.9598 124.941 18.9198C124.941 17.8531 124.714 17.0331 124.261 16.4598C123.808 15.8865 123.161 15.5998 122.321 15.5998C121.494 15.5998 120.848 15.8998 120.381 16.4998C119.928 17.0865 119.701 17.9065 119.701 18.9598C119.701 19.9998 119.928 20.7998 120.381 21.3598C120.848 21.9198 121.501 22.1998 122.341 22.1998Z");
    			attr_dev(path5, "fill", "white");
    			add_location(path5, file$f, 35, 16, 3292);
    			attr_dev(path6, "d", "M133.604 15.7798V20.2998C133.604 21.4865 134.157 22.0798 135.264 22.0798C135.571 22.0798 135.904 22.0265 136.264 21.9198V23.8998C135.824 24.0598 135.291 24.1398 134.664 24.1398C133.517 24.1398 132.637 23.8198 132.024 23.1798C131.411 22.5398 131.104 21.6198 131.104 20.4198V15.7798H129.164V13.8998H131.104V11.4398L133.604 10.5998V13.8998H136.284V15.7798H133.604Z");
    			attr_dev(path6, "fill", "white");
    			add_location(path6, file$f, 39, 16, 4329);
    			attr_dev(path7, "d", "M147.962 13.8998V23.9998H145.502V22.3798C145.195 22.9398 144.755 23.3798 144.182 23.6998C143.609 24.0065 142.955 24.1598 142.222 24.1598C141.342 24.1598 140.562 23.9465 139.882 23.5198C139.202 23.0931 138.675 22.4865 138.302 21.6998C137.929 20.9131 137.742 19.9998 137.742 18.9598C137.742 17.9198 137.929 16.9998 138.302 16.1998C138.689 15.3865 139.222 14.7598 139.902 14.3198C140.582 13.8665 141.355 13.6398 142.222 13.6398C142.955 13.6398 143.609 13.7998 144.182 14.1198C144.755 14.4265 145.195 14.8598 145.502 15.4198V13.8998H147.962ZM142.902 22.1998C143.729 22.1998 144.369 21.9131 144.822 21.3398C145.275 20.7665 145.502 19.9598 145.502 18.9198C145.502 17.8531 145.275 17.0331 144.822 16.4598C144.369 15.8865 143.722 15.5998 142.882 15.5998C142.055 15.5998 141.409 15.8998 140.942 16.4998C140.489 17.0865 140.262 17.9065 140.262 18.9598C140.262 19.9998 140.489 20.7998 140.942 21.3598C141.409 21.9198 142.062 22.1998 142.902 22.1998Z");
    			attr_dev(path7, "fill", "white");
    			add_location(path7, file$f, 43, 16, 4789);
    			attr_dev(path8, "d", "M156.953 9.75979H163.133C164.666 9.75979 165.86 10.1331 166.713 10.8798C167.566 11.6131 167.993 12.6198 167.993 13.8998C167.993 15.1798 167.56 16.1931 166.693 16.9398C165.84 17.6865 164.653 18.0598 163.133 18.0598H159.533V23.9998H156.953V9.75979ZM162.833 16.0598C163.726 16.0598 164.4 15.8798 164.853 15.5198C165.32 15.1465 165.553 14.6131 165.553 13.9198C165.553 13.2131 165.326 12.6798 164.873 12.3198C164.42 11.9465 163.74 11.7598 162.833 11.7598H159.533V16.0598H162.833Z");
    			attr_dev(path8, "fill", "white");
    			add_location(path8, file$f, 47, 16, 5826);
    			attr_dev(path9, "d", "M175.638 13.6598C176.025 13.6598 176.358 13.7131 176.638 13.8198L176.618 16.0998C176.191 15.9265 175.751 15.8398 175.298 15.8398C174.445 15.8398 173.791 16.0865 173.338 16.5798C172.898 17.0731 172.678 17.7265 172.678 18.5398V23.9998H170.198V16.7598C170.198 15.6931 170.145 14.7398 170.038 13.8998H172.378L172.578 15.6798C172.831 15.0265 173.231 14.5265 173.778 14.1798C174.325 13.8331 174.945 13.6598 175.638 13.6598Z");
    			attr_dev(path9, "fill", "white");
    			add_location(path9, file$f, 51, 16, 6399);
    			attr_dev(path10, "d", "M182.715 24.1598C181.688 24.1598 180.782 23.9465 179.995 23.5198C179.222 23.0931 178.622 22.4865 178.195 21.6998C177.782 20.8998 177.575 19.9665 177.575 18.8998C177.575 17.8331 177.782 16.9065 178.195 16.1198C178.622 15.3198 179.222 14.7065 179.995 14.2798C180.782 13.8531 181.688 13.6398 182.715 13.6398C183.728 13.6398 184.622 13.8531 185.395 14.2798C186.168 14.7065 186.762 15.3198 187.175 16.1198C187.602 16.9065 187.815 17.8331 187.815 18.8998C187.815 19.9665 187.602 20.8998 187.175 21.6998C186.762 22.4865 186.168 23.0931 185.395 23.5198C184.622 23.9465 183.728 24.1598 182.715 24.1598ZM182.695 22.1998C183.548 22.1998 184.195 21.9265 184.635 21.3798C185.088 20.8198 185.315 19.9931 185.315 18.8998C185.315 17.8198 185.088 16.9998 184.635 16.4398C184.182 15.8665 183.542 15.5798 182.715 15.5798C181.875 15.5798 181.228 15.8665 180.775 16.4398C180.322 16.9998 180.095 17.8198 180.095 18.8998C180.095 19.9931 180.315 20.8198 180.755 21.3798C181.208 21.9265 181.855 22.1998 182.695 22.1998Z");
    			attr_dev(path10, "fill", "white");
    			add_location(path10, file$f, 55, 16, 6915);
    			attr_dev(path11, "d", "M187.691 26.2198C188.051 26.3265 188.377 26.3798 188.671 26.3798C189.151 26.3798 189.537 26.2398 189.831 25.9598C190.124 25.6798 190.271 25.2265 190.271 24.5998V13.8998H192.751V24.7198C192.751 25.9198 192.444 26.8398 191.831 27.4798C191.231 28.1198 190.371 28.4398 189.251 28.4398C188.651 28.4398 188.131 28.3665 187.691 28.2198V26.2198ZM190.111 9.31979H192.891V11.7798H190.111V9.31979Z");
    			attr_dev(path11, "fill", "white");
    			add_location(path11, file$f, 59, 16, 8008);
    			attr_dev(path12, "d", "M204.626 19.0798H197.666C197.719 20.1598 197.986 20.9598 198.466 21.4798C198.959 21.9865 199.686 22.2398 200.646 22.2398C201.752 22.2398 202.779 21.8798 203.726 21.1598L204.446 22.8798C203.966 23.2665 203.372 23.5798 202.666 23.8198C201.972 24.0465 201.266 24.1598 200.546 24.1598C198.892 24.1598 197.592 23.6931 196.646 22.7598C195.699 21.8265 195.226 20.5465 195.226 18.9198C195.226 17.8931 195.432 16.9798 195.846 16.1798C196.259 15.3798 196.839 14.7598 197.586 14.3198C198.332 13.8665 199.179 13.6398 200.126 13.6398C201.512 13.6398 202.606 14.0931 203.406 14.9998C204.219 15.8931 204.626 17.1265 204.626 18.6998V19.0798ZM200.186 15.4398C199.519 15.4398 198.972 15.6398 198.546 16.0398C198.132 16.4265 197.866 16.9931 197.746 17.7398H202.446C202.366 16.9798 202.132 16.4065 201.746 16.0198C201.372 15.6331 200.852 15.4398 200.186 15.4398Z");
    			attr_dev(path12, "fill", "white");
    			add_location(path12, file$f, 63, 16, 8493);
    			attr_dev(path13, "d", "M211.623 24.1598C210.569 24.1598 209.656 23.9465 208.883 23.5198C208.109 23.0931 207.516 22.4931 207.103 21.7198C206.689 20.9331 206.483 20.0131 206.483 18.9598C206.483 17.9065 206.696 16.9798 207.123 16.1798C207.563 15.3798 208.176 14.7598 208.963 14.3198C209.763 13.8665 210.683 13.6398 211.723 13.6398C212.443 13.6398 213.136 13.7531 213.803 13.9798C214.483 14.2065 215.023 14.5198 215.423 14.9198L214.723 16.6798C214.296 16.3331 213.843 16.0731 213.363 15.8998C212.883 15.7131 212.409 15.6198 211.943 15.6198C211.036 15.6198 210.329 15.9065 209.823 16.4798C209.316 17.0398 209.063 17.8531 209.063 18.9198C209.063 19.9865 209.309 20.7998 209.803 21.3598C210.309 21.9198 211.023 22.1998 211.943 22.1998C212.409 22.1998 212.883 22.1065 213.363 21.9198C213.843 21.7331 214.296 21.4665 214.723 21.1198L215.423 22.8798C214.996 23.2798 214.443 23.5931 213.763 23.8198C213.083 24.0465 212.369 24.1598 211.623 24.1598Z");
    			attr_dev(path13, "fill", "white");
    			add_location(path13, file$f, 67, 16, 9434);
    			attr_dev(path14, "d", "M220.64 15.7798V20.2998C220.64 21.4865 221.193 22.0798 222.3 22.0798C222.607 22.0798 222.94 22.0265 223.3 21.9198V23.8998C222.86 24.0598 222.327 24.1398 221.7 24.1398C220.553 24.1398 219.673 23.8198 219.06 23.1798C218.447 22.5398 218.14 21.6198 218.14 20.4198V15.7798H216.2V13.8998H218.14V11.4398L220.64 10.5998V13.8998H223.32V15.7798H220.64Z");
    			attr_dev(path14, "fill", "white");
    			add_location(path14, file$f, 71, 16, 10446);
    			attr_dev(path15, "d", "M20.3307 4.70999C21.6686 4.70999 22.7532 3.67519 22.7532 2.3987C22.7532 1.1222 21.6686 0.0874023 20.3307 0.0874023C18.9928 0.0874023 17.9082 1.1222 17.9082 2.3987C17.9082 3.67519 18.9928 4.70999 20.3307 4.70999Z");
    			attr_dev(path15, "fill", "white");
    			add_location(path15, file$f, 75, 16, 10887);
    			attr_dev(path16, "d", "M20.3309 4.79813C18.951 4.79813 17.8164 3.71563 17.8164 2.39907C17.8164 1.08251 18.951 0 20.3309 0C21.7108 0 22.8454 1.08251 22.8454 2.39907C22.8454 3.71563 21.7108 4.79813 20.3309 4.79813ZM20.3309 0.146284C19.043 0.146284 17.9697 1.14102 17.9697 2.39907C17.9697 3.62785 19.0123 4.65185 20.3309 4.65185C21.6188 4.65185 22.6921 3.65711 22.6921 2.39907C22.6921 1.14102 21.6188 0.146284 20.3309 0.146284Z");
    			attr_dev(path16, "fill", "white");
    			add_location(path16, file$f, 79, 16, 11197);
    			attr_dev(path17, "d", "M7.35946 30.9257C3.31176 30.9257 0 27.7659 0 23.904C0 20.0421 3.31176 16.8823 7.35946 16.8823C11.4072 16.8823 14.7189 20.0421 14.7189 23.904C14.7189 27.7659 11.4072 30.9257 7.35946 30.9257ZM7.35946 17.9648C3.92504 17.9648 1.16525 20.6272 1.16525 23.8747C1.16525 27.1223 3.95571 29.7846 7.35946 29.7846C10.7632 29.7846 13.5537 27.1515 13.5537 23.904C13.5537 20.6565 10.7939 17.9648 7.35946 17.9648Z");
    			attr_dev(path17, "fill", "white");
    			add_location(path17, file$f, 83, 16, 11697);
    			attr_dev(path18, "d", "M28.6388 30.9257C24.5911 30.9257 21.2793 27.7659 21.2793 23.904C21.2793 20.0421 24.5911 16.8823 28.6388 16.8823C32.6865 16.8823 35.9982 20.0421 35.9982 23.904C35.9982 27.7659 32.6865 30.9257 28.6388 30.9257ZM28.6388 17.9648C25.2043 17.9648 22.4445 20.6272 22.4445 23.8747C22.4445 27.1223 25.235 29.7846 28.6388 29.7846C32.0425 29.7846 34.833 27.1223 34.833 23.8747C34.833 20.6272 32.0425 17.9648 28.6388 17.9648Z");
    			attr_dev(path18, "fill", "white");
    			add_location(path18, file$f, 87, 16, 12193);
    			attr_dev(path19, "d", "M26.2785 9.94836C26.0945 9.94836 25.9412 9.97762 25.7878 10.0361C24.04 10.0946 19.8696 8.86585 18.7964 7.46152C18.5204 7.08118 18.0604 6.81787 17.5391 6.81787C16.7112 6.81787 16.0059 7.46152 16.0059 8.28072C15.9446 9.74356 14.81 11.6453 12.6022 12.4937C11.8969 12.6985 11.4062 13.3129 11.4062 14.0443C11.4062 14.922 12.1729 15.6535 13.0928 15.6535C14.1354 15.829 16.6499 17.9355 16.9872 19.8079C16.9872 20.1298 17.0792 20.4223 17.2631 20.6564C17.3245 20.7442 17.3551 20.8027 17.4165 20.8612C18.0604 21.8559 17.9991 24.6353 16.6499 26.42C15.9446 27.0051 15.8526 27.9999 16.4352 28.702C17.0485 29.3749 18.0911 29.4627 18.827 28.9068C19.471 28.3802 19.5936 27.5025 19.1643 26.8296C18.643 25.3667 18.643 22.09 19.8083 20.9782C20.1456 20.6856 20.3603 20.276 20.3603 19.8079C20.3603 18.9302 19.5936 18.1988 18.6737 18.1988C18.643 18.1988 18.643 18.1988 18.6124 18.1988C17.2631 17.9355 15.0246 15.6535 14.7793 13.9273C14.9327 12.0549 16.1899 10.7968 17.9071 9.65579C18.0298 9.62653 18.1524 9.56802 18.2444 9.50951C21.0962 9.50951 23.4574 10.3872 24.9292 12.0549C25.1746 12.523 25.6959 12.8155 26.2478 12.8155C27.0758 12.8155 27.781 12.1719 27.781 11.3527C27.781 10.5335 27.1064 9.94836 26.2785 9.94836Z");
    			attr_dev(path19, "fill", "white");
    			add_location(path19, file$f, 91, 16, 12704);
    			attr_dev(svg, "width", "224");
    			attr_dev(svg, "height", "31");
    			attr_dev(svg, "viewBox", "0 0 224 31");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "alt", "Bike Data Project logo");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$f, 7, 12, 259);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    			append_dev(svg, path4);
    			append_dev(svg, path5);
    			append_dev(svg, path6);
    			append_dev(svg, path7);
    			append_dev(svg, path8);
    			append_dev(svg, path9);
    			append_dev(svg, path10);
    			append_dev(svg, path11);
    			append_dev(svg, path12);
    			append_dev(svg, path13);
    			append_dev(svg, path14);
    			append_dev(svg, path15);
    			append_dev(svg, path16);
    			append_dev(svg, path17);
    			append_dev(svg, path18);
    			append_dev(svg, path19);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(7:8) <Link class=\\\"navbar-brand\\\" to=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let nav;
    	let div;
    	let link;
    	let t;
    	let navbar;
    	let current;

    	link = new Link$1({
    			props: {
    				class: "navbar-brand",
    				to: "/",
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navbar = new Navbar({ $$inline: true });

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div = element("div");
    			create_component(link.$$.fragment);
    			t = space();
    			create_component(navbar.$$.fragment);
    			attr_dev(div, "class", "container");
    			add_location(div, file$f, 5, 4, 180);
    			attr_dev(nav, "class", "navbar fixed-top navbar-expand-lg navbar-dark bg-dark");
    			add_location(nav, file$f, 4, 0, 108);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div);
    			mount_component(link, div, null);
    			append_dev(div, t);
    			mount_component(navbar, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link_changes.$$scope = { dirty, ctx };
    			}

    			link.$set(link_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(link.$$.fragment, local);
    			transition_in(navbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(link.$$.fragment, local);
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(link);
    			destroy_component(navbar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Header', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Link: Link$1, Navbar });
    	return [];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/views/about/About.svelte generated by Svelte v3.44.0 */
    const file$e = "src/views/about/About.svelte";

    // (8:6) <Col xs="9">
    function create_default_slot_2$c(ctx) {
    	let h2;
    	let t1;
    	let p0;
    	let strong;
    	let t3;
    	let div;
    	let h30;
    	let t5;
    	let p1;
    	let t6;
    	let a0;
    	let t8;
    	let a1;
    	let t10;
    	let t11;
    	let p2;
    	let t12;
    	let a2;
    	let t14;
    	let t15;
    	let p3;
    	let t17;
    	let h31;
    	let t19;
    	let p4;
    	let t21;
    	let p5;
    	let t23;
    	let h32;
    	let t25;
    	let p6;
    	let t27;
    	let p7;
    	let t29;
    	let ul;
    	let li0;
    	let span0;
    	let t31;
    	let t32;
    	let li1;
    	let span1;
    	let t34;
    	let t35;
    	let li2;
    	let span2;
    	let t37;
    	let t38;
    	let h33;
    	let t40;
    	let p8;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "About the Bike Data Project";
    			t1 = space();
    			p0 = element("p");
    			strong = element("strong");
    			strong.textContent = "With the Bike Data Project, Open Knowledge Belgium – the umbrella\n            organisation for open knowledge and open data initiatives in Belgium\n            – wants to build a community-driven open bike data platform that\n            collects data on where and when people actually cycle. The project\n            aims at aggregating data from cyclists, coming from different mobile\n            applications and sources, into one open bike data platform. The\n            collective open data will empower local communities in making\n            cycling more visible and decision-makers in making cities more\n            liveable and bike-friendly.";
    			t3 = space();
    			div = element("div");
    			h30 = element("h3");
    			h30.textContent = "Short history: who's behind the project";
    			t5 = space();
    			p1 = element("p");
    			t6 = text("The Bike Data Project was initially set up by ");
    			a0 = element("a");
    			a0.textContent = "WG film";
    			t8 = text("\n            and launched as part of the release of the\n            ");
    			a1 = element("a");
    			a1.textContent = "Bikes vs Cars documentary";
    			t10 = text(", directed by Fredrik Gertten. As the documentary has been screened\n            in over 50 countries, there has already been collected more than\n            275.000 bicycle rides collected.");
    			t11 = space();
    			p2 = element("p");
    			t12 = text("At the beginning of 2020, the project was moved under the umbrella\n            of Open Knowledge Belgium. ");
    			a2 = element("a");
    			a2.textContent = "Open Knowledge Belgium";
    			t14 = text(" (non-profit/vzw/asbl),\n            as local chapter of Open Knowledge International, is an umbrella organisation\n            for various open knowledge and open data initiatives in Belgium. We strive\n            for a world where knowledge creates power for the many, not the few and\n            proactively promote openness through projects and events, to the general\n            public as well as to experts in the field. As grassroots organisation\n            we consist of people, mainly volunteers, passionate about openness, using\n            advocacy, research, technology and projects to unlock information, enabling\n            people to use and share knowledge.");
    			t15 = space();
    			p3 = element("p");
    			p3.textContent = "Open Knowledge Belgium guarantees the openness of the project for\n            all purposes and takes all required measures according to the GDPR\n            regulations concerning data privacy and protection. With a\n            transparent and clear terms of use for this project, Open Knowledge\n            Belgium wants to set an example on how to deal with privacy-related\n            issues and wants to take the opportunity to inform citizens about\n            their digital rights.";
    			t17 = space();
    			h31 = element("h3");
    			h31.textContent = "More cycling data means more power to and for cyclists";
    			t19 = space();
    			p4 = element("p");
    			p4.textContent = "Little is known about how cyclists move around in cities today. If\n            there’s data available, it’s closed and restricted data sold by one\n            single app provider or static data collected through manual counts.\n            If we want to have more people cycling in cities and make the\n            bicycle as easy and logical to opt for as the car, we also need to\n            get the same data insights into cyclists’ behavior as we have about\n            car transport.";
    			t21 = space();
    			p5 = element("p");
    			p5.textContent = "Open Knowledge Belgium aims to create impact by showing where and\n            when people actually cycle. The Bike Data Project provides the\n            opportunity to collect all cycling data from different applications\n            into one platform, which is - based on the principle of open source\n            and open data - adaptable and accessible by everyone to ensure it\n            benefits society.";
    			t23 = space();
    			h32 = element("h3");
    			h32.textContent = "Public digital infrastructure as common good";
    			t25 = space();
    			p6 = element("p");
    			p6.textContent = "Similar to activities like OpenStreetMap Belgium and Open Planner\n            Team by Open Knowledge Belgium, the Bike Data Project is set up as a\n            collaborative project which is open to all and makes society benefit\n            as a whole. Therefore, the digital infrastructure and aggregated\n            data are - based on the principles of open source and open data -\n            freely adaptable and accessible to anyone.";
    			t27 = space();
    			p7 = element("p");
    			p7.textContent = "Furthermore, Open Knowledge Belgium strives to play with this Bike\n            Data Project an important role in wider societal movements:";
    			t29 = space();
    			ul = element("ul");
    			li0 = element("li");
    			span0 = element("span");
    			span0.textContent = "Citizens can take back control of their data";
    			t31 = text(" thanks to\n              strong European GDPR regulations. In the case of the Bike Data Project,\n              we want to encourage citizens to get their data out of third party\n              apps (e.g. popular apps as Strava and even potentially Google Maps)\n              and ask them to contribute them to a good cause.");
    			t32 = space();
    			li1 = element("li");
    			span1 = element("span");
    			span1.textContent = "Promote skill sharing and encourage learning within the\n                community";
    			t34 = text(" throughout the whole process from project launch\n              to further development of the platform. Strongly inspired by the work\n              of the School of Data in Riga, we want to involve the cycling community\n              in the local Bike Data Project campaigns as from the first day. Throughout\n              a series of community events, Open Knowledge Belgium wants to improve\n              data literacy.");
    			t35 = space();
    			li2 = element("li");
    			span2 = element("span");
    			span2.textContent = "Think globally, act locally.";
    			t37 = text(" The Bike Data Project platform\n              is global and open by default. Although it is possible for cycling\n              communities all around the world to contribute to the project, Open\n              Knowledge Belgium wants to support local communities with making them\n              act on a local level.");
    			t38 = space();
    			h33 = element("h3");
    			h33.textContent = "Longer-term sustainability of the Bike Data Project";
    			t40 = space();
    			p8 = element("p");
    			p8.textContent = "Open Knowledge Belgium partners up with Brussels Mobility to launch,\n            as part of its Bike for Brussels program, a first campaign in the\n            Brussels-Capital Region. The launch of local crowdsourcing campaigns\n            in different cities and the setup of the open data platform are part\n            of a longer-term plan for the Bike Data Project. When a\n            crowdsourcing campaign in a specific city or region comes to an end,\n            the platform will stay online and will be maintained by the open\n            source community of Open Knowledge Belgium. Cycling communities in\n            other cities will be encouraged to launch a campaign in their cities\n            and make use of the platform. Given the interest of different\n            stakeholders in the Bike Data Platform, Open Knowledge Belgium has\n            already received confirmation from different stakeholders that they\n            want to contribute financially to the project so that the server\n            costs can get covered. In that way, the project will be sustained\n            over the longer term.";
    			add_location(h2, file$e, 8, 8, 186);
    			add_location(strong, file$e, 10, 10, 245);
    			add_location(p0, file$e, 9, 8, 231);
    			attr_dev(h30, "class", "svelte-368w88");
    			add_location(h30, file$e, 24, 10, 973);
    			attr_dev(a0, "href", "https://www.wgfilm.com");
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "rel", "noopener noreferrer");
    			add_location(a0, file$e, 28, 58, 1118);
    			attr_dev(a1, "href", "https://vimeo.com/ondemand/bikesvscars");
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "rel", "noopener noreferrer");
    			add_location(a1, file$e, 33, 12, 1314);
    			add_location(p1, file$e, 27, 10, 1056);
    			attr_dev(a2, "href", "https://be.okfn.org/");
    			attr_dev(a2, "target", "_blank");
    			attr_dev(a2, "rel", "noopener noreferrer");
    			add_location(a2, file$e, 43, 39, 1826);
    			add_location(p2, file$e, 41, 10, 1704);
    			add_location(p3, file$e, 56, 10, 2665);
    			attr_dev(h31, "class", "svelte-368w88");
    			add_location(h31, file$e, 65, 10, 3194);
    			add_location(p4, file$e, 68, 10, 3292);
    			add_location(p5, file$e, 77, 10, 3820);
    			attr_dev(h32, "class", "svelte-368w88");
    			add_location(h32, file$e, 85, 10, 4270);
    			add_location(p6, file$e, 88, 10, 4358);
    			add_location(p7, file$e, 96, 10, 4837);
    			add_location(span0, file$e, 102, 14, 5053);
    			add_location(li0, file$e, 101, 12, 5034);
    			add_location(span1, file$e, 109, 14, 5482);
    			add_location(li1, file$e, 108, 12, 5463);
    			add_location(span2, file$e, 119, 14, 6064);
    			add_location(li2, file$e, 118, 12, 6045);
    			add_location(ul, file$e, 100, 10, 5017);
    			attr_dev(h33, "class", "svelte-368w88");
    			add_location(h33, file$e, 126, 10, 6464);
    			add_location(p8, file$e, 129, 10, 6559);
    			add_location(div, file$e, 23, 8, 957);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, strong);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, h30);
    			append_dev(div, t5);
    			append_dev(div, p1);
    			append_dev(p1, t6);
    			append_dev(p1, a0);
    			append_dev(p1, t8);
    			append_dev(p1, a1);
    			append_dev(p1, t10);
    			append_dev(div, t11);
    			append_dev(div, p2);
    			append_dev(p2, t12);
    			append_dev(p2, a2);
    			append_dev(p2, t14);
    			append_dev(div, t15);
    			append_dev(div, p3);
    			append_dev(div, t17);
    			append_dev(div, h31);
    			append_dev(div, t19);
    			append_dev(div, p4);
    			append_dev(div, t21);
    			append_dev(div, p5);
    			append_dev(div, t23);
    			append_dev(div, h32);
    			append_dev(div, t25);
    			append_dev(div, p6);
    			append_dev(div, t27);
    			append_dev(div, p7);
    			append_dev(div, t29);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			append_dev(li0, span0);
    			append_dev(li0, t31);
    			append_dev(ul, t32);
    			append_dev(ul, li1);
    			append_dev(li1, span1);
    			append_dev(li1, t34);
    			append_dev(ul, t35);
    			append_dev(ul, li2);
    			append_dev(li2, span2);
    			append_dev(li2, t37);
    			append_dev(div, t38);
    			append_dev(div, h33);
    			append_dev(div, t40);
    			append_dev(div, p8);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(8:6) <Col xs=\\\"9\\\">",
    		ctx
    	});

    	return block;
    }

    // (7:4) <Row>
    function create_default_slot_1$c(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "9",
    				$$slots: { default: [create_default_slot_2$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(7:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (6:2) <Container>
    function create_default_slot$d(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(6:2) <Container>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let section;
    	let p;
    	let t1;
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			p.textContent = "About";
    			t1 = space();
    			create_component(container.$$.fragment);
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$e, 4, 2, 92);
    			attr_dev(section, "class", "svelte-368w88");
    			add_location(section, file$e, 3, 0, 80);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(section, t1);
    			mount_component(container, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('About', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Container, Row, Col });
    	return [];
    }

    class About$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src/views/faq/Question.svelte generated by Svelte v3.44.0 */

    const file$d = "src/views/faq/Question.svelte";

    function create_fragment$f(ctx) {
    	let div2;
    	let h2;
    	let button;
    	let t0;
    	let button_data_bs_target_value;
    	let button_aria_controls_value;
    	let h2_id_value;
    	let t1;
    	let div1;
    	let div0;
    	let div1_id_value;
    	let div1_aria_labelledby_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h2 = element("h2");
    			button = element("button");
    			t0 = text(/*question*/ ctx[0]);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", "accordion-button collapsed");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "data-bs-toggle", "collapse");
    			attr_dev(button, "data-bs-target", button_data_bs_target_value = "#collapse" + /*id*/ ctx[1]);
    			attr_dev(button, "aria-expanded", "false");
    			attr_dev(button, "aria-controls", button_aria_controls_value = "collapse" + /*id*/ ctx[1]);
    			add_location(button, file$d, 6, 4, 147);
    			attr_dev(h2, "class", "accordion-header");
    			attr_dev(h2, "id", h2_id_value = "heading" + /*id*/ ctx[1]);
    			add_location(h2, file$d, 5, 2, 96);
    			attr_dev(div0, "class", "accordion-body");
    			add_location(div0, file$d, 21, 4, 535);
    			attr_dev(div1, "id", div1_id_value = "collapse" + /*id*/ ctx[1]);
    			attr_dev(div1, "class", "accordion-collapse collapse");
    			attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value = "heading" + /*id*/ ctx[1]);
    			attr_dev(div1, "data-bs-parent", "#accordionExample");
    			add_location(div1, file$d, 16, 2, 390);
    			attr_dev(div2, "class", "accordion-item");
    			add_location(div2, file$d, 4, 0, 65);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h2);
    			append_dev(h2, button);
    			append_dev(button, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*question*/ 1) set_data_dev(t0, /*question*/ ctx[0]);

    			if (!current || dirty & /*id*/ 2 && button_data_bs_target_value !== (button_data_bs_target_value = "#collapse" + /*id*/ ctx[1])) {
    				attr_dev(button, "data-bs-target", button_data_bs_target_value);
    			}

    			if (!current || dirty & /*id*/ 2 && button_aria_controls_value !== (button_aria_controls_value = "collapse" + /*id*/ ctx[1])) {
    				attr_dev(button, "aria-controls", button_aria_controls_value);
    			}

    			if (!current || dirty & /*id*/ 2 && h2_id_value !== (h2_id_value = "heading" + /*id*/ ctx[1])) {
    				attr_dev(h2, "id", h2_id_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 2 && div1_id_value !== (div1_id_value = "collapse" + /*id*/ ctx[1])) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (!current || dirty & /*id*/ 2 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = "heading" + /*id*/ ctx[1])) {
    				attr_dev(div1, "aria-labelledby", div1_aria_labelledby_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Question', slots, ['default']);
    	let { question } = $$props;
    	let { id } = $$props;
    	const writable_props = ['question', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Question> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('question' in $$props) $$invalidate(0, question = $$props.question);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ question, id });

    	$$self.$inject_state = $$props => {
    		if ('question' in $$props) $$invalidate(0, question = $$props.question);
    		if ('id' in $$props) $$invalidate(1, id = $$props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [question, id, $$scope, slots];
    }

    class Question extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { question: 0, id: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Question",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*question*/ ctx[0] === undefined && !('question' in props)) {
    			console.warn("<Question> was created without expected prop 'question'");
    		}

    		if (/*id*/ ctx[1] === undefined && !('id' in props)) {
    			console.warn("<Question> was created without expected prop 'id'");
    		}
    	}

    	get question() {
    		throw new Error("<Question>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set question(value) {
    		throw new Error("<Question>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Question>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Question>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/views/faq/Faq.svelte generated by Svelte v3.44.0 */
    const file$c = "src/views/faq/Faq.svelte";

    // (13:10) <Question             id="q1"             question="Why should I participate in this project?">
    function create_default_slot_11(ctx) {
    	let p0;
    	let t1;
    	let p1;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "By contributing your cycling data, you can help make our cities\n              better adapted to cyclists.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "More cycling data means more power to and for cyclists. Little is\n              known about how cyclists move around in cities today. If there’s\n              data available, it’s closed and restricted data sold by one single\n              app provider or static data collected through manual counts. If we\n              want to have more people cycling in cities and make the bicycle as\n              easy and logical to opt for as the car, we also need to get the\n              same data insights into cyclists’ behavior as we have about car\n              transport.";
    			add_location(p0, file$c, 15, 12, 462);
    			add_location(p1, file$c, 19, 12, 615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(13:10) <Question             id=\\\"q1\\\"             question=\\\"Why should I participate in this project?\\\">",
    		ctx
    	});

    	return block;
    }

    // (31:10) <Question id="q2" question="How does this project work?">
    function create_default_slot_10(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "To make this work we want to ask you to contribute your cycling\n              data. We need to know where you ride your bicycle. Your data\n              contributions, combined with the data from many other cyclists,\n              will make cities more adapted to cyclists.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "We ask different types of cyclists (e.g., daily commuters,\n              delivery riders, sportsmen and tourists) to track their bicycle\n              rides via their preferred mobile application and contribute their\n              data to our community-driven bike data platform. Every kind of\n              cyclist has something to contribute to this project. Some people\n              already track their activity for training purposes. That’s great,\n              but we also really want to take into account the short routes:\n              commuting to work, dropping the kids off at school or a quick ride\n              to the grocery store.";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "In return, the anonymous aggregated cycling data will be opened up\n              to the public and can be freely used by anyone. We aim to create\n              impact by showing where and when people actually cycle. More data\n              means more influence over those in power to make cities more\n              sustainable and bike-friendly.";
    			add_location(p0, file$c, 31, 12, 1321);
    			add_location(p1, file$c, 37, 12, 1642);
    			add_location(p2, file$c, 48, 12, 2336);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(31:10) <Question id=\\\"q2\\\" question=\\\"How does this project work?\\\">",
    		ctx
    	});

    	return block;
    }

    // (57:10) <Question id="q3" question="How do I contribute my data?">
    function create_default_slot_9$1(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "You can simply connect your existing cycling app to the Bike Data\n              Project platform. For now, you can either connect your Strava\n              account or upload your Garmin files, but we're also working on the\n              integration of other cycling apps. Once your app is connected you\n              can just carry on as usual and your rides will be automatically\n              uploaded to the Bike Data Project platform. If you do not use any\n              cycling app yet, you will be able to use our own app soon. With\n              the Bike Data Project app, you won't need to create an account,\n              you will be able to anonymously share your data to the platform.";
    			add_location(p, file$c, 57, 12, 2820);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(57:10) <Question id=\\\"q3\\\" question=\\\"How do I contribute my data?\\\">",
    		ctx
    	});

    	return block;
    }

    // (70:10) <Question id="q4" question="What is happening with my data?">
    function create_default_slot_8$1(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let ul;
    	let li0;
    	let t5;
    	let li1;
    	let t7;
    	let li2;
    	let t9;
    	let li3;
    	let t11;
    	let p2;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "The data collected by this project consists of contributions made\n              by all different kinds of cyclists. All individual cycling data\n              are aggregated into collective data. The collective data gives us\n              patterns we can use to demonstrate where and when cyclists ride\n              their bicycles.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "The anonymous aggregated cycling data will be opened up to the\n              public as open data. The open data provided by the Bike Data\n              Project platform can be freely used by different stakeholders and\n              for different purposes. Here’s a non-exhaustive list of different\n              use cases of the open data:";
    			t3 = space();
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "Transportation experts, city planners, mobility planners and\n                urban designers around the world need open data like this to\n                help them develop modern infrastructure and sustainable cities.";
    			t5 = space();
    			li1 = element("li");
    			li1.textContent = "Citizens can get a high-level overview of the number of cyclists\n                and kilometers cycled in the city and check out a map with the\n                number of cyclists per route.";
    			t7 = space();
    			li2 = element("li");
    			li2.textContent = "Civil society and journalists use the data to analyse the\n                situation for cyclists in the city, such as the amount of time\n                cyclists lose on average at traffic lights.";
    			t9 = space();
    			li3 = element("li");
    			li3.textContent = "Data and software companies can dive into the data to obtain\n                smart cycling insights and build tools like advanced cycling\n                route planners and recommendation engines to improve cycling\n                infrastructure. The data can also be very useful for other bike\n                related products and services.";
    			t11 = space();
    			p2 = element("p");
    			p2.textContent = "All aggregated cycling data will be available as open data by the\n              end of October 2020. For now, you can contribute to the project by\n              donating your cycling data.";
    			add_location(p0, file$c, 70, 12, 3657);
    			add_location(p1, file$c, 77, 12, 4036);
    			add_location(li0, file$c, 85, 14, 4442);
    			add_location(li1, file$c, 90, 14, 4715);
    			add_location(li2, file$c, 95, 14, 4960);
    			add_location(li3, file$c, 100, 14, 5212);
    			add_location(ul, file$c, 84, 12, 4423);
    			add_location(p2, file$c, 108, 12, 5625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(ul, t5);
    			append_dev(ul, li1);
    			append_dev(ul, t7);
    			append_dev(ul, li2);
    			append_dev(ul, t9);
    			append_dev(ul, li3);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, p2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(ul);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(70:10) <Question id=\\\"q4\\\" question=\\\"What is happening with my data?\\\">",
    		ctx
    	});

    	return block;
    }

    // (115:10) <Question             id="q5"             question="Is my privacy respected when I contribute my data?">
    function create_default_slot_7$2(ctx) {
    	let p0;
    	let t1;
    	let p1;
    	let t3;
    	let p2;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "Yes, Open Knowledge Belgium guarantees the openness of the project\n              so that society benefits as a whole and takes all required\n              measures according to the GDPR regulations concerning data privacy\n              and protection.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "We are collecting cycling data of many individual cyclists and aim\n              to make the anonymous aggregated data available to the public as\n              open data. The aggregated data will be published in a way that\n              it's not possible to retrieve any personal information of an\n              individual cyclist.";
    			t3 = space();
    			p2 = element("p");
    			p2.textContent = "The data publishing will be done based on the principle of\n              differential privacy, which is a system for publicly sharing\n              information about a dataset by describing the patterns of groups\n              within the dataset while withholding information about individuals\n              in the dataset. This basically means that data will only be\n              published if a particular individual's information cannot be\n              retrieved.";
    			add_location(p0, file$c, 117, 12, 5998);
    			add_location(p1, file$c, 123, 12, 6296);
    			add_location(p2, file$c, 130, 12, 6675);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p2, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(115:10) <Question             id=\\\"q5\\\"             question=\\\"Is my privacy respected when I contribute my data?\\\">",
    		ctx
    	});

    	return block;
    }

    // (141:10) <Question id="q6" question="Can I delete my data?">
    function create_default_slot_6$5(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Yes! Although you contribute your data in an anonymous way (we\n              don't ask for your name or any other information that identifies\n              you), you can ask us to extract your data from the Bike Data\n              Project platform.If you'd like to do so, please send us an email\n              to bikedataproject@openknowledge.be with the name of the app\n              you've used to contribute your data and, if possible, also the ID\n              number associated with your account in the app.";
    			add_location(p, file$c, 141, 12, 7274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$5.name,
    		type: "slot",
    		source: "(141:10) <Question id=\\\"q6\\\" question=\\\"Can I delete my data?\\\">",
    		ctx
    	});

    	return block;
    }

    // (152:10) <Question id="q7" question="What data am I sharing from my app?">
    function create_default_slot_5$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("We mainly want to ask you to contribute the data regarding your\n            cycling activities, more specifically where and when you cycle.\n            Besides that, there's the possibility to share information on your\n            gender, age, type of bicycles and the reason of your bicycle\n            ride(leisure, sports, commute, ...).");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(152:10) <Question id=\\\"q7\\\" question=\\\"What data am I sharing from my app?\\\">",
    		ctx
    	});

    	return block;
    }

    // (159:10) <Question id="q8" question="How do I get access to the open data?">
    function create_default_slot_4$7(ctx) {
    	let p0;
    	let t1;
    	let p1;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "The anonymous aggregated cycling data will be opened up to the\n              public as open data. The open data provided by the Bike Data\n              Project platform can be freely used by different stakeholders and\n              for different purposes.";
    			t1 = space();
    			p1 = element("p");
    			p1.textContent = "All aggregated cycling data will be available as open data by the\n              end of October 2020. For now, you can contribute to the project by\n              donating your cycling data.";
    			add_location(p0, file$c, 159, 12, 8385);
    			add_location(p1, file$c, 165, 12, 8688);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(159:10) <Question id=\\\"q8\\\" question=\\\"How do I get access to the open data?\\\">",
    		ctx
    	});

    	return block;
    }

    // (172:10) <Question             id="q9"             question="I'd love to be more involved in this project - how can I help?">
    function create_default_slot_3$8(ctx) {
    	let p;

    	const block = {
    		c: function create() {
    			p = element("p");
    			p.textContent = "That's awesome! Feel free to join our Slack group\n              (https://join.slack.com/t/bikedataproject/shared_invite/zt-hr00amgw-elYn9WbdFHLta8qQKW_wvQ)\n              and introduce yourself there. We'd love to hear how you'd like to\n              contribute to the project!";
    			add_location(p, file$c, 174, 12, 9073);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(172:10) <Question             id=\\\"q9\\\"             question=\\\"I'd love to be more involved in this project - how can I help?\\\">",
    		ctx
    	});

    	return block;
    }

    // (10:6) <Col xs="10">
    function create_default_slot_2$b(ctx) {
    	let h2;
    	let t1;
    	let div;
    	let question0;
    	let t2;
    	let question1;
    	let t3;
    	let question2;
    	let t4;
    	let question3;
    	let t5;
    	let question4;
    	let t6;
    	let question5;
    	let t7;
    	let question6;
    	let t8;
    	let question7;
    	let t9;
    	let question8;
    	let current;

    	question0 = new Question({
    			props: {
    				id: "q1",
    				question: "Why should I participate in this project?",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question1 = new Question({
    			props: {
    				id: "q2",
    				question: "How does this project work?",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question2 = new Question({
    			props: {
    				id: "q3",
    				question: "How do I contribute my data?",
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question3 = new Question({
    			props: {
    				id: "q4",
    				question: "What is happening with my data?",
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question4 = new Question({
    			props: {
    				id: "q5",
    				question: "Is my privacy respected when I contribute my data?",
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question5 = new Question({
    			props: {
    				id: "q6",
    				question: "Can I delete my data?",
    				$$slots: { default: [create_default_slot_6$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question6 = new Question({
    			props: {
    				id: "q7",
    				question: "What data am I sharing from my app?",
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question7 = new Question({
    			props: {
    				id: "q8",
    				question: "How do I get access to the open data?",
    				$$slots: { default: [create_default_slot_4$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	question8 = new Question({
    			props: {
    				id: "q9",
    				question: "I'd love to be more involved in this project - how can I help?",
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Frequently Asked Questions";
    			t1 = space();
    			div = element("div");
    			create_component(question0.$$.fragment);
    			t2 = space();
    			create_component(question1.$$.fragment);
    			t3 = space();
    			create_component(question2.$$.fragment);
    			t4 = space();
    			create_component(question3.$$.fragment);
    			t5 = space();
    			create_component(question4.$$.fragment);
    			t6 = space();
    			create_component(question5.$$.fragment);
    			t7 = space();
    			create_component(question6.$$.fragment);
    			t8 = space();
    			create_component(question7.$$.fragment);
    			t9 = space();
    			create_component(question8.$$.fragment);
    			add_location(h2, file$c, 10, 8, 254);
    			attr_dev(div, "class", "accordion");
    			attr_dev(div, "id", "accordionExample");
    			add_location(div, file$c, 11, 8, 298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(question0, div, null);
    			append_dev(div, t2);
    			mount_component(question1, div, null);
    			append_dev(div, t3);
    			mount_component(question2, div, null);
    			append_dev(div, t4);
    			mount_component(question3, div, null);
    			append_dev(div, t5);
    			mount_component(question4, div, null);
    			append_dev(div, t6);
    			mount_component(question5, div, null);
    			append_dev(div, t7);
    			mount_component(question6, div, null);
    			append_dev(div, t8);
    			mount_component(question7, div, null);
    			append_dev(div, t9);
    			mount_component(question8, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const question0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question0_changes.$$scope = { dirty, ctx };
    			}

    			question0.$set(question0_changes);
    			const question1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question1_changes.$$scope = { dirty, ctx };
    			}

    			question1.$set(question1_changes);
    			const question2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question2_changes.$$scope = { dirty, ctx };
    			}

    			question2.$set(question2_changes);
    			const question3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question3_changes.$$scope = { dirty, ctx };
    			}

    			question3.$set(question3_changes);
    			const question4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question4_changes.$$scope = { dirty, ctx };
    			}

    			question4.$set(question4_changes);
    			const question5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question5_changes.$$scope = { dirty, ctx };
    			}

    			question5.$set(question5_changes);
    			const question6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question6_changes.$$scope = { dirty, ctx };
    			}

    			question6.$set(question6_changes);
    			const question7_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question7_changes.$$scope = { dirty, ctx };
    			}

    			question7.$set(question7_changes);
    			const question8_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				question8_changes.$$scope = { dirty, ctx };
    			}

    			question8.$set(question8_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(question0.$$.fragment, local);
    			transition_in(question1.$$.fragment, local);
    			transition_in(question2.$$.fragment, local);
    			transition_in(question3.$$.fragment, local);
    			transition_in(question4.$$.fragment, local);
    			transition_in(question5.$$.fragment, local);
    			transition_in(question6.$$.fragment, local);
    			transition_in(question7.$$.fragment, local);
    			transition_in(question8.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(question0.$$.fragment, local);
    			transition_out(question1.$$.fragment, local);
    			transition_out(question2.$$.fragment, local);
    			transition_out(question3.$$.fragment, local);
    			transition_out(question4.$$.fragment, local);
    			transition_out(question5.$$.fragment, local);
    			transition_out(question6.$$.fragment, local);
    			transition_out(question7.$$.fragment, local);
    			transition_out(question8.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			destroy_component(question0);
    			destroy_component(question1);
    			destroy_component(question2);
    			destroy_component(question3);
    			destroy_component(question4);
    			destroy_component(question5);
    			destroy_component(question6);
    			destroy_component(question7);
    			destroy_component(question8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(10:6) <Col xs=\\\"10\\\">",
    		ctx
    	});

    	return block;
    }

    // (9:4) <Row>
    function create_default_slot_1$b(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "10",
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(9:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (8:2) <Container>
    function create_default_slot$c(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(8:2) <Container>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let section;
    	let p;
    	let t1;
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			p.textContent = "Faq";
    			t1 = space();
    			create_component(container.$$.fragment);
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$c, 6, 2, 161);
    			attr_dev(section, "class", "svelte-jmhmt");
    			add_location(section, file$c, 5, 0, 149);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(section, t1);
    			mount_component(container, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Faq', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Faq> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Container, Row, Col, Question });
    	return [];
    }

    class Faq$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Faq",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/views/datamap/Data.svelte generated by Svelte v3.44.0 */
    const file$b = "src/views/datamap/Data.svelte";

    // (8:6) <Col xs="9">
    function create_default_slot_7$1(ctx) {
    	let h2;
    	let t1;
    	let p;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "The data";
    			t1 = space();
    			p = element("p");
    			p.textContent = "The data collected by this project consists of contributions made by\n          all different kinds of cyclists. All individual cycling data are\n          aggregated into collective data. The collective data gives us patterns\n          we can use to demonstrate where and when cyclists ride their bicycles.";
    			add_location(h2, file$b, 8, 8, 199);
    			add_location(p, file$b, 9, 8, 225);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(8:6) <Col xs=\\\"9\\\">",
    		ctx
    	});

    	return block;
    }

    // (7:4) <Row>
    function create_default_slot_6$4(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "9",
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$4.name,
    		type: "slot",
    		source: "(7:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (6:2) <Container>
    function create_default_slot_5$5(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_6$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(6:2) <Container>",
    		ctx
    	});

    	return block;
    }

    // (28:6) <Col xs="9">
    function create_default_slot_4$6(ctx) {
    	let p0;
    	let t1;
    	let ul;
    	let li0;
    	let t3;
    	let li1;
    	let t5;
    	let li2;
    	let t7;
    	let li3;
    	let t9;
    	let p1;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "The anonymous aggregated cycling data will be opened up to the public\n          as open data. The open data provided by the Bike Data Project platform\n          can be freely used by different stakeholders and for different\n          purposes. Here’s a non-exhaustive list of different use cases of the\n          open data:";
    			t1 = space();
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "Transportation experts, city planners, mobility planners and urban\n            designers around the world need open data like this to help them\n            develop modern infrastructure and sustainable cities.";
    			t3 = space();
    			li1 = element("li");
    			li1.textContent = "Citizens can get a high-level overview of the number of cyclists and\n            kilometers cycled in the city and check out a map with the number of\n            cyclists per route.";
    			t5 = space();
    			li2 = element("li");
    			li2.textContent = "Civil society and journalists use the data to analyse the situation\n            for cyclists in the city, such as the amount of time cyclists lose\n            on average at traffic lights.";
    			t7 = space();
    			li3 = element("li");
    			li3.textContent = "Data and software companies can dive into the data to obtain smart\n            cycling insights and build tools like advanced cycling route\n            planners and recommendation engines to improve cycling\n            infrastructure. The data can also be very useful for other bike\n            related products and services.";
    			t9 = space();
    			p1 = element("p");
    			p1.textContent = "All aggregated cycling data will be available as open data by the end\n          of October 2020. For now, you can contribute to the project by\n          donating your cycling data.";
    			add_location(p0, file$b, 28, 8, 793);
    			add_location(li0, file$b, 36, 10, 1167);
    			add_location(li1, file$b, 41, 10, 1420);
    			add_location(li2, file$b, 46, 10, 1645);
    			add_location(li3, file$b, 51, 10, 1877);
    			add_location(ul, file$b, 35, 8, 1152);
    			add_location(p1, file$b, 59, 8, 2258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(ul, t3);
    			append_dev(ul, li1);
    			append_dev(ul, t5);
    			append_dev(ul, li2);
    			append_dev(ul, t7);
    			append_dev(ul, li3);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, p1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(ul);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(28:6) <Col xs=\\\"9\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:4) <Row>
    function create_default_slot_3$7(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "9",
    				$$slots: { default: [create_default_slot_4$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(27:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (68:6) <Col xs="9">
    function create_default_slot_2$a(ctx) {
    	let div1;
    	let div0;
    	let h3;
    	let t1;
    	let a;
    	let svg;
    	let path;
    	let t2;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h3 = element("h3");
    			h3.textContent = "Have a look at our open source code";
    			t1 = space();
    			a = element("a");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t2 = text("Github");
    			add_location(h3, file$b, 70, 12, 2611);
    			attr_dev(path, "d", "M16 0C7.15983 0 0 7.26871 0 16.2433C0 23.877 5.15949 30.2125 12.1205 31.9986C12.0402 31.7954 12.0007 31.5106 12.0007 31.2272V28.4652H10.0003C8.92051 28.4652 7.91966 27.9786 7.47983 27.0842C6.95966 26.1096 6.87932 24.6069 5.55983 23.6724C5.15949 23.3475 5.47949 23.0226 5.91932 23.0627C6.75949 23.306 7.43898 23.8756 8.07898 24.7271C8.71898 25.5801 8.99949 25.7833 10.1991 25.7833C10.7588 25.7833 11.6385 25.7432 12.4391 25.6202C12.879 24.4825 13.6388 23.4678 14.5593 22.9812C9.19966 22.3314 6.63966 19.6509 6.63966 15.9959C6.63966 14.4116 7.31915 12.9089 8.43983 11.6095C8.08034 10.3501 7.59966 7.75117 8.60051 6.73648C11.0012 6.73648 12.4405 8.32072 12.8 8.72576C13.9997 8.31934 15.3205 8.07603 16.6795 8.07603C18.0793 8.07603 19.3593 8.31934 20.559 8.72576C20.9185 8.31934 22.3591 6.73648 24.7585 6.73648C25.7185 7.71108 25.2786 10.3501 24.8783 11.6095C25.999 12.8688 26.639 14.4116 26.639 15.9959C26.639 19.6509 24.1185 22.3314 18.7997 22.8996C20.2798 23.671 21.3202 25.8635 21.3202 27.4878V31.1871C21.3202 31.3088 21.2807 31.4304 21.2807 31.5521C27.52 29.3596 32 23.3503 32 16.2433C32 7.26871 24.8402 0 16 0Z");
    			attr_dev(path, "fill", "white");
    			attr_dev(path, "class", "svelte-uc2yr5");
    			add_location(path, file$b, 78, 17, 2942);
    			attr_dev(svg, "width", "32");
    			attr_dev(svg, "height", "32");
    			attr_dev(svg, "viewBox", "0 0 32 32");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "class", "svelte-uc2yr5");
    			add_location(svg, file$b, 72, 15, 2750);
    			attr_dev(a, "href", "https://github.com/bikedataproject");
    			attr_dev(a, "class", "btn btn-share svelte-uc2yr5");
    			add_location(a, file$b, 71, 12, 2668);
    			attr_dev(div0, "class", "open-source svelte-uc2yr5");
    			add_location(div0, file$b, 69, 10, 2573);
    			attr_dev(div1, "class", "open-source-container svelte-uc2yr5");
    			add_location(div1, file$b, 68, 8, 2527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h3);
    			append_dev(div0, t1);
    			append_dev(div0, a);
    			append_dev(a, svg);
    			append_dev(svg, path);
    			append_dev(a, t2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(68:6) <Col xs=\\\"9\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:4) <Row>
    function create_default_slot_1$a(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "9",
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(67:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (26:2) <Container>
    function create_default_slot$b(ctx) {
    	let row0;
    	let t;
    	let row1;
    	let current;

    	row0 = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_3$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row1 = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row0.$$.fragment);
    			t = space();
    			create_component(row1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(row1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				row0_changes.$$scope = { dirty, ctx };
    			}

    			row0.$set(row0_changes);
    			const row1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				row1_changes.$$scope = { dirty, ctx };
    			}

    			row1.$set(row1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row0.$$.fragment, local);
    			transition_in(row1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row0.$$.fragment, local);
    			transition_out(row1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(row1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(26:2) <Container>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let section0;
    	let p;
    	let t1;
    	let container0;
    	let t2;
    	let section1;
    	let iframe;
    	let iframe_src_value;
    	let t3;
    	let section2;
    	let container1;
    	let current;

    	container0 = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	container1 = new Container({
    			props: {
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			p = element("p");
    			p.textContent = "Data";
    			t1 = space();
    			create_component(container0.$$.fragment);
    			t2 = space();
    			section1 = element("section");
    			iframe = element("iframe");
    			t3 = space();
    			section2 = element("section");
    			create_component(container1.$$.fragment);
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$b, 4, 2, 106);
    			attr_dev(section0, "class", "first svelte-uc2yr5");
    			add_location(section0, file$b, 3, 0, 80);
    			if (!src_url_equal(iframe.src, iframe_src_value = "https://data.bikedataproject.org/map/#2.01/45/24.32")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "title", "Data map");
    			attr_dev(iframe, "class", "svelte-uc2yr5");
    			add_location(iframe, file$b, 20, 2, 620);
    			add_location(section1, file$b, 19, 0, 608);
    			add_location(section2, file$b, 24, 0, 732);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, p);
    			append_dev(section0, t1);
    			mount_component(container0, section0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, iframe);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, section2, anchor);
    			mount_component(container1, section2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				container0_changes.$$scope = { dirty, ctx };
    			}

    			container0.$set(container0_changes);
    			const container1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				container1_changes.$$scope = { dirty, ctx };
    			}

    			container1.$set(container1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container0.$$.fragment, local);
    			transition_in(container1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container0.$$.fragment, local);
    			transition_out(container1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			destroy_component(container0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(section1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(section2);
    			destroy_component(container1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Data', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Data> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Container, Row, Col });
    	return [];
    }

    class Data$4 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Data",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/views/home/Data.svelte generated by Svelte v3.44.0 */
    const file$a = "src/views/home/Data.svelte";

    // (55:6) <Button class="btn-share mt-3">
    function create_default_slot$a(ctx) {
    	let t_value = /*$_*/ ctx[0]("Data_button") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("Data_button") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(55:6) <Button class=\\\"btn-share mt-3\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let section;
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Data") + "";
    	let t0;
    	let t1;
    	let div9;
    	let h2;
    	let t2_value = /*$_*/ ctx[0]("Data_title") + "";
    	let t2;
    	let t3;
    	let div3;
    	let div0;
    	let span0;
    	let t5;
    	let span1;
    	let t6_value = /*$_*/ ctx[0]("Rides_collected") + "";
    	let t6;
    	let t7;
    	let div1;
    	let span4;
    	let span2;
    	let t9;
    	let span3;
    	let t11;
    	let span5;
    	let t12_value = /*$_*/ ctx[0]("Distance_collected") + "";
    	let t12;
    	let t13;
    	let div2;
    	let span9;
    	let span7;
    	let t14;
    	let span6;
    	let t16;
    	let span8;
    	let t17_value = /*$_*/ ctx[0]("Average_distance") + "";
    	let t17;
    	let t18;
    	let div7;
    	let div4;
    	let span12;
    	let span10;
    	let t20;
    	let span11;
    	let t22;
    	let span13;
    	let t23_value = /*$_*/ ctx[0]("Average_speed") + "";
    	let t23;
    	let t24;
    	let div5;
    	let span16;
    	let span14;
    	let t26;
    	let span15;
    	let t28;
    	let span17;
    	let t29_value = /*$_*/ ctx[0]("Average_duration") + "";
    	let t29;
    	let t30;
    	let div6;
    	let span20;
    	let span18;
    	let t32;
    	let span19;
    	let t34;
    	let span21;
    	let t35_value = /*$_*/ ctx[0]("co2_saved") + "";
    	let t35;
    	let t36;
    	let div8;
    	let h3;
    	let t37_value = /*$_*/ ctx[0]("Data_subtitle") + "";
    	let t37;
    	let t38;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				class: "btn-share mt-3",
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			div9 = element("div");
    			h2 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			div3 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "381.167";
    			t5 = space();
    			span1 = element("span");
    			t6 = text(t6_value);
    			t7 = space();
    			div1 = element("div");
    			span4 = element("span");
    			span2 = element("span");
    			span2.textContent = "6.220";
    			t9 = space();
    			span3 = element("span");
    			span3.textContent = "K km";
    			t11 = space();
    			span5 = element("span");
    			t12 = text(t12_value);
    			t13 = space();
    			div2 = element("div");
    			span9 = element("span");
    			span7 = element("span");
    			t14 = text("16");
    			span6 = element("span");
    			span6.textContent = "km";
    			t16 = space();
    			span8 = element("span");
    			t17 = text(t17_value);
    			t18 = space();
    			div7 = element("div");
    			div4 = element("div");
    			span12 = element("span");
    			span10 = element("span");
    			span10.textContent = "14";
    			t20 = space();
    			span11 = element("span");
    			span11.textContent = "km/h";
    			t22 = space();
    			span13 = element("span");
    			t23 = text(t23_value);
    			t24 = space();
    			div5 = element("div");
    			span16 = element("span");
    			span14 = element("span");
    			span14.textContent = "68";
    			t26 = space();
    			span15 = element("span");
    			span15.textContent = "min";
    			t28 = space();
    			span17 = element("span");
    			t29 = text(t29_value);
    			t30 = space();
    			div6 = element("div");
    			span20 = element("span");
    			span18 = element("span");
    			span18.textContent = "809";
    			t32 = text("K\n          ");
    			span19 = element("span");
    			span19.textContent = "t";
    			t34 = space();
    			span21 = element("span");
    			t35 = text(t35_value);
    			t36 = space();
    			div8 = element("div");
    			h3 = element("h3");
    			t37 = text(t37_value);
    			t38 = space();
    			create_component(button.$$.fragment);
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$a, 6, 2, 103);
    			add_location(h2, file$a, 8, 4, 201);
    			attr_dev(span0, "class", "counter-number svelte-jdhn9y");
    			add_location(span0, file$a, 11, 8, 298);
    			add_location(span1, file$a, 12, 8, 350);
    			attr_dev(div0, "class", "col-4 counter svelte-jdhn9y");
    			add_location(div0, file$a, 10, 6, 262);
    			attr_dev(span2, "class", "counter-number svelte-jdhn9y");
    			add_location(span2, file$a, 16, 10, 459);
    			add_location(span3, file$a, 17, 10, 511);
    			add_location(span4, file$a, 15, 8, 442);
    			add_location(span5, file$a, 19, 8, 553);
    			attr_dev(div1, "class", "col-4 counter svelte-jdhn9y");
    			add_location(div1, file$a, 14, 6, 406);
    			add_location(span6, file$a, 24, 41, 713);
    			attr_dev(span7, "class", "counter-number svelte-jdhn9y");
    			add_location(span7, file$a, 24, 10, 682);
    			add_location(span8, file$a, 25, 10, 747);
    			attr_dev(span9, "class", "counter svelte-jdhn9y");
    			add_location(span9, file$a, 23, 8, 649);
    			attr_dev(div2, "class", "col-4 counter svelte-jdhn9y");
    			add_location(div2, file$a, 22, 6, 613);
    			attr_dev(div3, "class", "row mb-4");
    			add_location(div3, file$a, 9, 4, 233);
    			attr_dev(span10, "class", "counter-number svelte-jdhn9y");
    			add_location(span10, file$a, 32, 10, 906);
    			add_location(span11, file$a, 33, 10, 955);
    			add_location(span12, file$a, 31, 8, 889);
    			add_location(span13, file$a, 35, 8, 998);
    			attr_dev(div4, "class", "col-4 counter svelte-jdhn9y");
    			add_location(div4, file$a, 30, 6, 853);
    			attr_dev(span14, "class", "counter-number svelte-jdhn9y");
    			add_location(span14, file$a, 39, 10, 1105);
    			add_location(span15, file$a, 40, 10, 1154);
    			add_location(span16, file$a, 38, 8, 1088);
    			add_location(span17, file$a, 42, 8, 1196);
    			attr_dev(div5, "class", "col-4 counter svelte-jdhn9y");
    			add_location(div5, file$a, 37, 6, 1052);
    			attr_dev(span18, "class", "counter-number svelte-jdhn9y");
    			add_location(span18, file$a, 46, 10, 1306);
    			add_location(span19, file$a, 47, 10, 1357);
    			add_location(span20, file$a, 45, 8, 1289);
    			add_location(span21, file$a, 49, 8, 1397);
    			attr_dev(div6, "class", "col-4 counter svelte-jdhn9y");
    			add_location(div6, file$a, 44, 6, 1253);
    			attr_dev(div7, "class", "row");
    			add_location(div7, file$a, 29, 4, 829);
    			add_location(h3, file$a, 53, 6, 1484);
    			attr_dev(div8, "class", "explore svelte-jdhn9y");
    			add_location(div8, file$a, 52, 4, 1456);
    			attr_dev(div9, "class", "container container-section");
    			add_location(div9, file$a, 7, 2, 155);
    			add_location(section, file$a, 5, 0, 91);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(p, t0);
    			append_dev(section, t1);
    			append_dev(section, div9);
    			append_dev(div9, h2);
    			append_dev(h2, t2);
    			append_dev(div9, t3);
    			append_dev(div9, div3);
    			append_dev(div3, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t5);
    			append_dev(div0, span1);
    			append_dev(span1, t6);
    			append_dev(div3, t7);
    			append_dev(div3, div1);
    			append_dev(div1, span4);
    			append_dev(span4, span2);
    			append_dev(span4, t9);
    			append_dev(span4, span3);
    			append_dev(div1, t11);
    			append_dev(div1, span5);
    			append_dev(span5, t12);
    			append_dev(div3, t13);
    			append_dev(div3, div2);
    			append_dev(div2, span9);
    			append_dev(span9, span7);
    			append_dev(span7, t14);
    			append_dev(span7, span6);
    			append_dev(span9, t16);
    			append_dev(span9, span8);
    			append_dev(span8, t17);
    			append_dev(div9, t18);
    			append_dev(div9, div7);
    			append_dev(div7, div4);
    			append_dev(div4, span12);
    			append_dev(span12, span10);
    			append_dev(span12, t20);
    			append_dev(span12, span11);
    			append_dev(div4, t22);
    			append_dev(div4, span13);
    			append_dev(span13, t23);
    			append_dev(div7, t24);
    			append_dev(div7, div5);
    			append_dev(div5, span16);
    			append_dev(span16, span14);
    			append_dev(span16, t26);
    			append_dev(span16, span15);
    			append_dev(div5, t28);
    			append_dev(div5, span17);
    			append_dev(span17, t29);
    			append_dev(div7, t30);
    			append_dev(div7, div6);
    			append_dev(div6, span20);
    			append_dev(span20, span18);
    			append_dev(span20, t32);
    			append_dev(span20, span19);
    			append_dev(div6, t34);
    			append_dev(div6, span21);
    			append_dev(span21, t35);
    			append_dev(div9, t36);
    			append_dev(div9, div8);
    			append_dev(div8, h3);
    			append_dev(h3, t37);
    			append_dev(div8, t38);
    			mount_component(button, div8, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("Data") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$_*/ 1) && t2_value !== (t2_value = /*$_*/ ctx[0]("Data_title") + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*$_*/ 1) && t6_value !== (t6_value = /*$_*/ ctx[0]("Rides_collected") + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*$_*/ 1) && t12_value !== (t12_value = /*$_*/ ctx[0]("Distance_collected") + "")) set_data_dev(t12, t12_value);
    			if ((!current || dirty & /*$_*/ 1) && t17_value !== (t17_value = /*$_*/ ctx[0]("Average_distance") + "")) set_data_dev(t17, t17_value);
    			if ((!current || dirty & /*$_*/ 1) && t23_value !== (t23_value = /*$_*/ ctx[0]("Average_speed") + "")) set_data_dev(t23, t23_value);
    			if ((!current || dirty & /*$_*/ 1) && t29_value !== (t29_value = /*$_*/ ctx[0]("Average_duration") + "")) set_data_dev(t29, t29_value);
    			if ((!current || dirty & /*$_*/ 1) && t35_value !== (t35_value = /*$_*/ ctx[0]("co2_saved") + "")) set_data_dev(t35, t35_value);
    			if ((!current || dirty & /*$_*/ 1) && t37_value !== (t37_value = /*$_*/ ctx[0]("Data_subtitle") + "")) set_data_dev(t37, t37_value);
    			const button_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Data', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Data> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Button, _: X, $_ });
    	return [$_];
    }

    class Data$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Data",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src/views/home/Head.svelte generated by Svelte v3.44.0 */
    const file$9 = "src/views/home/Head.svelte";

    function create_fragment$b(ctx) {
    	let section;
    	let div1;
    	let div0;
    	let h1;
    	let t0_value = /*$_*/ ctx[0]("Heading") + "";
    	let t0;
    	let t1;
    	let div3;
    	let p0;
    	let t2_value = /*$_*/ ctx[0]("Introduction") + "";
    	let t2;
    	let t3;
    	let div2;
    	let p1;
    	let t4;
    	let span;
    	let t6;
    	let t7;
    	let p2;
    	let t8_value = /*$_*/ ctx[0]("Label_total_km") + "";
    	let t8;

    	const block = {
    		c: function create() {
    			section = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			div3 = element("div");
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			p1 = element("p");
    			t4 = text("+");
    			span = element("span");
    			span.textContent = "6.220";
    			t6 = text("K");
    			t7 = space();
    			p2 = element("p");
    			t8 = text(t8_value);
    			attr_dev(h1, "class", "slogan svelte-1y6g8ok");
    			add_location(h1, file$9, 6, 6, 148);
    			attr_dev(div0, "class", "container svelte-1y6g8ok");
    			add_location(div0, file$9, 5, 4, 118);
    			attr_dev(div1, "class", "jumbotron jumbotron-fluid svelte-1y6g8ok");
    			add_location(div1, file$9, 4, 2, 74);
    			attr_dev(p0, "class", "p-0 m-0");
    			add_location(p0, file$9, 12, 4, 253);
    			add_location(span, file$9, 17, 9, 395);
    			attr_dev(p1, "class", "counter-number p-0 m-0 svelte-1y6g8ok");
    			add_location(p1, file$9, 16, 6, 351);
    			attr_dev(p2, "class", "p-0 m-0");
    			add_location(p2, file$9, 19, 6, 432);
    			attr_dev(div2, "class", "counter p-0 m-0");
    			add_location(div2, file$9, 15, 4, 315);
    			attr_dev(div3, "class", "subtitle svelte-1y6g8ok");
    			add_location(div3, file$9, 11, 2, 226);
    			add_location(section, file$9, 3, 0, 62);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div1);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			append_dev(h1, t0);
    			append_dev(section, t1);
    			append_dev(section, div3);
    			append_dev(div3, p0);
    			append_dev(p0, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, p1);
    			append_dev(p1, t4);
    			append_dev(p1, span);
    			append_dev(p1, t6);
    			append_dev(div2, t7);
    			append_dev(div2, p2);
    			append_dev(p2, t8);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Heading") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("Introduction") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t8_value !== (t8_value = /*$_*/ ctx[0]("Label_total_km") + "")) set_data_dev(t8, t8_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Head', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Head> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ _: X, $_ });
    	return [$_];
    }

    class Head extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Head",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/views/home/Help.svelte generated by Svelte v3.44.0 */
    const file$8 = "src/views/home/Help.svelte";

    // (10:6) <Col xs="6">
    function create_default_slot_3$6(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("Help_title") + "";
    	let t0;
    	let t1;
    	let div;
    	let p0;
    	let t2_value = /*$_*/ ctx[0]("Ask_for_favor") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[0]("By_sharing_your") + "";
    	let t4;
    	let t5;
    	let p2;
    	let t6_value = /*$_*/ ctx[0]("Every_cyclist_can") + "";
    	let t6;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			t6 = text(t6_value);
    			add_location(h2, file$8, 10, 8, 253);
    			attr_dev(p0, "class", "fw-bold");
    			add_location(p0, file$8, 12, 10, 321);
    			add_location(p1, file$8, 15, 10, 400);
    			add_location(p2, file$8, 18, 10, 465);
    			attr_dev(div, "class", "content");
    			add_location(div, file$8, 11, 8, 289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, t2);
    			append_dev(div, t3);
    			append_dev(div, p1);
    			append_dev(p1, t4);
    			append_dev(div, t5);
    			append_dev(div, p2);
    			append_dev(p2, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Help_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("Ask_for_favor") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("By_sharing_your") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("Every_cyclist_can") + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(10:6) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (24:6) <Col xs="6">
    function create_default_slot_2$9(ctx) {
    	let picture;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			picture = element("picture");
    			img = element("img");
    			attr_dev(img, "class", "Home_content__img__225R5");
    			if (!src_url_equal(img.src, img_src_value = "/img/mockup-big.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Mock up of the app on a phone");
    			attr_dev(img, "width", "468");
    			attr_dev(img, "height", "593");
    			add_location(img, file$8, 25, 11, 630);
    			attr_dev(picture, "class", "Home_content__img__225R5");
    			add_location(picture, file$8, 24, 8, 577);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, picture, anchor);
    			append_dev(picture, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(picture);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(24:6) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (9:4) <Row>
    function create_default_slot_1$9(ctx) {
    	let col0;
    	let t;
    	let col1;
    	let current;

    	col0 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col0.$$.fragment);
    			t = space();
    			create_component(col1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(col1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col0_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(col1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(9:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (8:2) <Container class="container container-section">
    function create_default_slot$9(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(8:2) <Container class=\\\"container container-section\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let section;
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Help") + "";
    	let t0;
    	let t1;
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				class: "container container-section",
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(container.$$.fragment);
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$8, 6, 2, 116);
    			add_location(section, file$8, 5, 0, 104);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(p, t0);
    			append_dev(section, t1);
    			mount_component(container, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("Help") + "")) set_data_dev(t0, t0_value);
    			const container_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Help', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Help> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Col, Container, Row, _: X, $_ });
    	return [$_];
    }

    class Help$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Help",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/views/home/Newsletter.svelte generated by Svelte v3.44.0 */
    const file$7 = "src/views/home/Newsletter.svelte";

    // (9:6) <Col xs="8">
    function create_default_slot_2$8(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("Informed_title") + "";
    	let t0;
    	let t1;
    	let form;
    	let div0;
    	let input0;
    	let t2;
    	let label;
    	let t3_value = /*$_*/ ctx[0]("Email_label") + "";
    	let t3;
    	let t4;
    	let div1;
    	let input1;
    	let input1_placeholder_value;
    	let t5;
    	let button;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			form = element("form");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			label = element("label");
    			t3 = text(t3_value);
    			t4 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t5 = space();
    			button = element("button");
    			img = element("img");
    			add_location(h2, file$7, 9, 8, 191);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "name", "b_4e280417525a8a98031f1ce33_9af7c29f8d");
    			attr_dev(input0, "tabindex", "-1");
    			input0.value = "";
    			attr_dev(input0, "class", "svelte-umtqww");
    			add_location(input0, file$7, 18, 12, 596);
    			attr_dev(div0, "class", "d-none");
    			attr_dev(div0, "aria-hidden", "true");
    			add_location(div0, file$7, 17, 10, 544);
    			attr_dev(label, "for", "mce-EMAIL");
    			attr_dev(label, "class", "svelte-umtqww");
    			add_location(label, file$7, 24, 10, 770);
    			attr_dev(input1, "type", "email");
    			attr_dev(input1, "placeholder", input1_placeholder_value = /*$_*/ ctx[0]("Informed_placeholder"));
    			attr_dev(input1, "name", "EMAIL");
    			attr_dev(input1, "id", "mce-EMAIL");
    			input1.required = "";
    			attr_dev(input1, "class", "svelte-umtqww");
    			add_location(input1, file$7, 26, 12, 849);
    			if (!src_url_equal(img.src, img_src_value = "/img/arrow-orange.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Arrow orange icon");
    			attr_dev(img, "width", "20");
    			attr_dev(img, "height", "20");
    			add_location(img, file$7, 33, 14, 1060);
    			attr_dev(button, "class", "svelte-umtqww");
    			add_location(button, file$7, 32, 12, 1037);
    			add_location(div1, file$7, 25, 10, 831);
    			attr_dev(form, "action", "https://bikedataproject.us10.list-manage.com/subscribe/post?u=0c7a4077dc373a78e97129b40&id=48e38aad42");
    			attr_dev(form, "method", "post");
    			attr_dev(form, "class", "Home_form__3a7DN");
    			attr_dev(form, "id", "mc-embedded-subscribe-form");
    			attr_dev(form, "name", "mc-embedded-subscribe-form");
    			attr_dev(form, "target", "_blank");
    			add_location(form, file$7, 10, 8, 231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, input0);
    			append_dev(form, t2);
    			append_dev(form, label);
    			append_dev(label, t3);
    			append_dev(form, t4);
    			append_dev(form, div1);
    			append_dev(div1, input1);
    			append_dev(div1, t5);
    			append_dev(div1, button);
    			append_dev(button, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Informed_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t3_value !== (t3_value = /*$_*/ ctx[0]("Email_label") + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*$_*/ 1 && input1_placeholder_value !== (input1_placeholder_value = /*$_*/ ctx[0]("Informed_placeholder"))) {
    				attr_dev(input1, "placeholder", input1_placeholder_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(form);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(9:6) <Col xs=\\\"8\\\">",
    		ctx
    	});

    	return block;
    }

    // (8:4) <Row>
    function create_default_slot_1$8(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "8",
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(8:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (7:2) <Container class="mb-5">
    function create_default_slot$8(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(7:2) <Container class=\\\"mb-5\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let section;
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				class: "mb-5",
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(container.$$.fragment);
    			attr_dev(section, "class", "my-5 svelte-umtqww");
    			add_location(section, file$7, 5, 0, 104);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(container, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const container_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Newsletter', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Newsletter> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Col, Container, Row, _: X, $_ });
    	return [$_];
    }

    class Newsletter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newsletter",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/views/home/OpenData.svelte generated by Svelte v3.44.0 */
    const file$6 = "src/views/home/OpenData.svelte";

    // (9:6) <Col xs="6">
    function create_default_slot_2$7(ctx) {
    	let div1;
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("Contribute_title") + "";
    	let t0;
    	let t1;
    	let div0;
    	let p0;
    	let t2_value = /*$_*/ ctx[0]("People_who_work") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[0]("Common_goal") + "";
    	let t4;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			add_location(h2, file$6, 10, 10, 199);
    			add_location(p0, file$6, 12, 12, 261);
    			add_location(p1, file$6, 15, 12, 332);
    			add_location(div0, file$6, 11, 10, 243);
    			attr_dev(div1, "class", "text-box svelte-1f0jxfc");
    			add_location(div1, file$6, 9, 8, 166);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, h2);
    			append_dev(h2, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, p0);
    			append_dev(p0, t2);
    			append_dev(div0, t3);
    			append_dev(div0, p1);
    			append_dev(p1, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Contribute_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("People_who_work") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("Common_goal") + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(9:6) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:6) <Col xs="6">
    function create_default_slot_1$7(ctx) {
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Contribute_big") + "";
    	let t0;
    	let t1;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			img = element("img");
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$6, 22, 8, 459);
    			attr_dev(img, "class", "illustration svelte-1f0jxfc");
    			if (!src_url_equal(img.src, img_src_value = "/img/contribute.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "People cycling");
    			add_location(img, file$6, 23, 8, 527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Contribute_big") + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(22:6) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (8:4) <Row>
    function create_default_slot$7(ctx) {
    	let col0;
    	let t;
    	let col1;
    	let current;

    	col0 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col0.$$.fragment);
    			t = space();
    			create_component(col1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(col1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col0_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(col1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(8:4) <Row>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let section;
    	let div;
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			create_component(row.$$.fragment);
    			attr_dev(div, "class", "container");
    			add_location(div, file$6, 6, 2, 105);
    			attr_dev(section, "class", "svelte-1f0jxfc");
    			add_location(section, file$6, 5, 0, 93);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			mount_component(row, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(row);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OpenData', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OpenData> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Col, Row, _: X, $_ });
    	return [$_];
    }

    class OpenData extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OpenData",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src/views/home/Partners.svelte generated by Svelte v3.44.0 */
    const file$5 = "src/views/home/Partners.svelte";

    // (11:6) <Col xs="3" class="mt-3">
    function create_default_slot_6$3(ctx) {
    	let a;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "/img/partners/open-knowledge-belgium.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo of Open Knowlegde Belgium");
    			attr_dev(img, "class", "svelte-q1dc45");
    			add_location(img, file$5, 16, 10, 430);
    			attr_dev(a, "href", "https://be.okfn.org/");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "partner-card svelte-q1dc45");
    			attr_dev(a, "rel", "noopener noreferrer");
    			add_location(a, file$5, 11, 8, 285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(11:6) <Col xs=\\\"3\\\" class=\\\"mt-3\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:6) <Col xs="3" class="mt-3">
    function create_default_slot_5$4(ctx) {
    	let a;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "/img/partners/wg-film.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo of WG Film");
    			attr_dev(img, "class", "svelte-q1dc45");
    			add_location(img, file$5, 27, 10, 760);
    			attr_dev(a, "href", "https://www.wgfilm.com/");
    			attr_dev(a, "class", "partner-card svelte-q1dc45");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			add_location(a, file$5, 22, 8, 612);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(22:6) <Col xs=\\\"3\\\" class=\\\"mt-3\\\">",
    		ctx
    	});

    	return block;
    }

    // (31:6) <Col xs="3" class="mt-3">
    function create_default_slot_4$5(ctx) {
    	let a;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "/img/partners/brussels-mobility.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo of brussels mobility");
    			attr_dev(img, "class", "svelte-q1dc45");
    			add_location(img, file$5, 36, 10, 1049);
    			attr_dev(a, "href", "https://mobilite-mobiliteit.brussels");
    			attr_dev(a, "class", "partner-card svelte-q1dc45");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			add_location(a, file$5, 31, 8, 888);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(31:6) <Col xs=\\\"3\\\" class=\\\"mt-3\\\">",
    		ctx
    	});

    	return block;
    }

    // (42:6) <Col xs="3" class="mt-3">
    function create_default_slot_3$5(ctx) {
    	let a;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "/img/partners/bike-for-brussels.webp")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Logo of Bike Fore Brussels");
    			attr_dev(img, "class", "svelte-q1dc45");
    			add_location(img, file$5, 47, 10, 1371);
    			attr_dev(a, "href", "https://bike.brussels/nl/");
    			attr_dev(a, "class", "partner-card svelte-q1dc45");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			add_location(a, file$5, 42, 8, 1221);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(42:6) <Col xs=\\\"3\\\" class=\\\"mt-3\\\">",
    		ctx
    	});

    	return block;
    }

    // (53:6) <Col xs="3" class="mt-3">
    function create_default_slot_2$6(ctx) {
    	let a;
    	let h3;
    	let t_value = /*$_*/ ctx[0]("Partner_up") + "";
    	let t;

    	const block = {
    		c: function create() {
    			a = element("a");
    			h3 = element("h3");
    			t = text(t_value);
    			attr_dev(h3, "class", "svelte-q1dc45");
    			add_location(h3, file$5, 58, 10, 1709);
    			attr_dev(a, "href", "mailto:bikedataproject@openknowledge.be");
    			attr_dev(a, "class", "partner-card svelte-q1dc45");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			add_location(a, file$5, 53, 8, 1545);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, h3);
    			append_dev(h3, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t_value !== (t_value = /*$_*/ ctx[0]("Partner_up") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(53:6) <Col xs=\\\"3\\\" class=\\\"mt-3\\\">",
    		ctx
    	});

    	return block;
    }

    // (9:4) <Row>
    function create_default_slot_1$6(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("Partners_title") + "";
    	let t0;
    	let t1;
    	let col0;
    	let t2;
    	let col1;
    	let t3;
    	let col2;
    	let t4;
    	let col3;
    	let t5;
    	let col4;
    	let current;

    	col0 = new Col({
    			props: {
    				xs: "3",
    				class: "mt-3",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "3",
    				class: "mt-3",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col2 = new Col({
    			props: {
    				xs: "3",
    				class: "mt-3",
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col3 = new Col({
    			props: {
    				xs: "3",
    				class: "mt-3",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col4 = new Col({
    			props: {
    				xs: "3",
    				class: "mt-3",
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(col0.$$.fragment);
    			t2 = space();
    			create_component(col1.$$.fragment);
    			t3 = space();
    			create_component(col2.$$.fragment);
    			t4 = space();
    			create_component(col3.$$.fragment);
    			t5 = space();
    			create_component(col4.$$.fragment);
    			add_location(h2, file$5, 9, 6, 213);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			mount_component(col0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(col1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(col2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(col3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(col4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("Partners_title") + "")) set_data_dev(t0, t0_value);
    			const col0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    			const col2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				col2_changes.$$scope = { dirty, ctx };
    			}

    			col2.$set(col2_changes);
    			const col3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				col3_changes.$$scope = { dirty, ctx };
    			}

    			col3.$set(col3_changes);
    			const col4_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				col4_changes.$$scope = { dirty, ctx };
    			}

    			col4.$set(col4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			transition_in(col2.$$.fragment, local);
    			transition_in(col3.$$.fragment, local);
    			transition_in(col4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			transition_out(col2.$$.fragment, local);
    			transition_out(col3.$$.fragment, local);
    			transition_out(col4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(col1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(col2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(col3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(col4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(9:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (8:2) <Container>
    function create_default_slot$6(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(8:2) <Container>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let section;
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Partners") + "";
    	let t0;
    	let t1;
    	let container;
    	let t2;
    	let div1;
    	let div0;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(container.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$5, 6, 2, 129);
    			attr_dev(div0, "class", "Home_partners__1dttM Home_grid__XUG6j components_grid__1VC05");
    			add_location(div0, file$5, 64, 4, 1838);
    			attr_dev(div1, "class", "Home_content__wrapper__lZpMD");
    			add_location(div1, file$5, 63, 2, 1791);
    			attr_dev(section, "class", "my-5");
    			add_location(section, file$5, 5, 0, 104);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(p, t0);
    			append_dev(section, t1);
    			mount_component(container, section, null);
    			append_dev(section, t2);
    			append_dev(section, div1);
    			append_dev(div1, div0);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("Partners") + "")) set_data_dev(t0, t0_value);
    			const container_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Partners', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Partners> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Container, Row, Col, _: X, $_ });
    	return [$_];
    }

    class Partners$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Partners",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/views/home/Power.svelte generated by Svelte v3.44.0 */
    const file$4 = "src/views/home/Power.svelte";

    // (10:6) <Col xs="8">
    function create_default_slot_2$5(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("Visible_title") + "";
    	let t0;
    	let t1;
    	let div;
    	let p0;
    	let t2_value = /*$_*/ ctx[0]("Community_more_visible") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[0]("Globally_but_locally") + "";
    	let t4;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			div = element("div");
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			add_location(h2, file$4, 10, 8, 218);
    			add_location(p0, file$4, 12, 10, 273);
    			add_location(p1, file$4, 15, 10, 345);
    			add_location(div, file$4, 11, 8, 257);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, t2);
    			append_dev(div, t3);
    			append_dev(div, p1);
    			append_dev(p1, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("Visible_title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("Community_more_visible") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("Globally_but_locally") + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(10:6) <Col xs=\\\"8\\\">",
    		ctx
    	});

    	return block;
    }

    // (9:4) <Row>
    function create_default_slot_1$5(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "8",
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(9:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (8:2) <Container>
    function create_default_slot$5(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(8:2) <Container>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let section;
    	let p;
    	let t0_value = /*$_*/ ctx[0]("Power") + "";
    	let t0;
    	let t1;
    	let container;
    	let t2;
    	let img;
    	let img_src_value;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(container.$$.fragment);
    			t2 = space();
    			img = element("img");
    			attr_dev(p, "class", "background-big-letter");
    			add_location(p, file$4, 6, 2, 116);
    			add_location(section, file$4, 5, 0, 104);
    			attr_dev(img, "class", "illustration svelte-oppfdo");
    			if (!src_url_equal(img.src, img_src_value = "/img/route.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Striped line of a route with places marked on");
    			add_location(img, file$4, 23, 0, 470);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p);
    			append_dev(p, t0);
    			append_dev(section, t1);
    			mount_component(container, section, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, img, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("Power") + "")) set_data_dev(t0, t0_value);
    			const container_changes = {};

    			if (dirty & /*$$scope, $_*/ 3) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Power', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Power> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Container, Row, Col, _: X, $_ });
    	return [$_];
    }

    class Power$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Power",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/integrations/Gpx.svelte generated by Svelte v3.44.0 */

    const { console: console_1 } = globals;
    const file$3 = "src/integrations/Gpx.svelte";

    // (10:0) <Button class="btn-share w-100" on:click={toggle}>
    function create_default_slot_4$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("GPX");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(10:0) <Button class=\\\"btn-share w-100\\\" on:click={toggle}>",
    		ctx
    	});

    	return block;
    }

    // (18:8) <Label for="email">
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Email");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(18:8) <Label for=\\\"email\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:4) <FormGroup>
    function create_default_slot_2$4(ctx) {
    	let label;
    	let t;
    	let input;
    	let current;

    	label = new Label({
    			props: {
    				for: "email",
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	input = new Input({
    			props: {
    				type: "email",
    				name: "email",
    				id: "email",
    				placeholder: "your@email.com"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    			t = space();
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(17:4) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (29:4) <Button color="secondary" on:click={link}>
    function create_default_slot_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Link my account.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(29:4) <Button color=\\\"secondary\\\" on:click={link}>",
    		ctx
    	});

    	return block;
    }

    // (11:0) <Modal body {isOpen} {toggle} header="Thanks for sharing your Strava data!">
    function create_default_slot$4(ctx) {
    	let p0;
    	let t1;
    	let formgroup;
    	let t2;
    	let p1;
    	let t4;
    	let button;
    	let current;

    	formgroup = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				color: "secondary",
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*link*/ ctx[2]);

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			p0.textContent = "When linking your Fitbit account BikeDataProject gets access to your\n        cycling data. Any cycling trips you do with your Fitbit device gets\n        shared automatically with BikeDataProject.";
    			t1 = space();
    			create_component(formgroup.$$.fragment);
    			t2 = space();
    			p1 = element("p");
    			p1.textContent = "Your link with Fitbit will not last forever, we use your email address only to notify you when your link to the BikeDataProject is broken. You can leave your email address blank but then we won't be able to notify you if data sharing is turned off.";
    			t4 = space();
    			create_component(button.$$.fragment);
    			add_location(p0, file$3, 11, 4, 386);
    			add_location(p1, file$3, 25, 4, 821);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(formgroup, target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p1, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formgroup_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				formgroup_changes.$$scope = { dirty, ctx };
    			}

    			formgroup.$set(formgroup_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formgroup.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formgroup.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			destroy_component(formgroup, detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t4);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(11:0) <Modal body {isOpen} {toggle} header=\\\"Thanks for sharing your Strava data!\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let button;
    	let t;
    	let modal;
    	let current;

    	button = new Button({
    			props: {
    				class: "btn-share w-100",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*toggle*/ ctx[1]);

    	modal = new Modal({
    			props: {
    				body: true,
    				isOpen: /*isOpen*/ ctx[0],
    				toggle: /*toggle*/ ctx[1],
    				header: "Thanks for sharing your Strava data!",
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			const modal_changes = {};
    			if (dirty & /*isOpen*/ 1) modal_changes.isOpen = /*isOpen*/ ctx[0];

    			if (dirty & /*$$scope*/ 8) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Gpx', slots, []);
    	let isOpen = false;
    	const toggle = () => $$invalidate(0, isOpen = !isOpen);

    	const link = () => {
    		$$invalidate(0, isOpen = false);
    		console.log("yes please, link.");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Gpx> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Button,
    		Modal,
    		FormGroup,
    		Input,
    		Label,
    		isOpen,
    		toggle,
    		link
    	});

    	$$self.$inject_state = $$props => {
    		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isOpen, toggle, link];
    }

    class Gpx extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gpx",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    class MessageManager {
        constructor() {
            this.eventHandlers = {
                show: [],
                hide: []
            };
        }
        on(event, handler) {
            if (event === "show") {
                this.eventHandlers.show.push(handler);
            }
            if (event === "hide") {
                this.eventHandlers.hide.push(handler);
            }
        }
        trigger(event, data) {
            if (event === "show") {
                this.eventHandlers.show.forEach(h => h(data));
            }
            if (event === "hide") {
                this.eventHandlers.hide.forEach(h => h(data));
            }
        }
        show(message) {
            this.trigger("show", message);
        }
        hide() {
            this.trigger("hide");
        }
    }

    /* src/components/modals/Message.svelte generated by Svelte v3.44.0 */
    const file$2 = "src/components/modals/Message.svelte";

    // (19:4) <Row class="w-100">
    function create_default_slot_5$3(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*message*/ ctx[0]);
    			add_location(p, file$2, 19, 6, 525);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 1) set_data_dev(t, /*message*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(19:4) <Row class=\\\"w-100\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:8) <Button color="primary" on:click="{async () => await link()}"           >
    function create_default_slot_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("OK");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(26:8) <Button color=\\\"primary\\\" on:click=\\\"{async () => await link()}\\\"           >",
    		ctx
    	});

    	return block;
    }

    // (25:6) <Col xs="6">
    function create_default_slot_3$3(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(25:6) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (24:4) <Row class="w-100">
    function create_default_slot_2$3(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(24:4) <Row class=\\\"w-100\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:2) <Container>
    function create_default_slot_1$3(ctx) {
    	let row0;
    	let t;
    	let row1;
    	let current;

    	row0 = new Row({
    			props: {
    				class: "w-100",
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row1 = new Row({
    			props: {
    				class: "w-100",
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row0.$$.fragment);
    			t = space();
    			create_component(row1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(row1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row0_changes = {};

    			if (dirty & /*$$scope, message*/ 65) {
    				row0_changes.$$scope = { dirty, ctx };
    			}

    			row0.$set(row0_changes);
    			const row1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				row1_changes.$$scope = { dirty, ctx };
    			}

    			row1.$set(row1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row0.$$.fragment, local);
    			transition_in(row1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row0.$$.fragment, local);
    			transition_out(row1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(row1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(18:2) <Container>",
    		ctx
    	});

    	return block;
    }

    // (17:0) <Modal body isOpen="{isOpen}" header="Thanks for sharing your data!">
    function create_default_slot$3(ctx) {
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const container_changes = {};

    			if (dirty & /*$$scope, message*/ 65) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(17:0) <Modal body isOpen=\\\"{isOpen}\\\" header=\\\"Thanks for sharing your data!\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let modal;
    	let current;

    	modal = new Modal({
    			props: {
    				body: true,
    				isOpen: /*isOpen*/ ctx[1],
    				header: "Thanks for sharing your data!",
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};
    			if (dirty & /*isOpen*/ 2) modal_changes.isOpen = /*isOpen*/ ctx[1];

    			if (dirty & /*$$scope, message*/ 65) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Message', slots, []);
    	let manager = new MessageManager();
    	let message = "";
    	const hook = manager;
    	let isOpen = false;
    	manager.on("hide", () => $$invalidate(1, isOpen = false));

    	manager.on("show", m => {
    		$$invalidate(0, message = m);
    		$$invalidate(1, isOpen = true);
    	});

    	const link = async () => {
    		$$invalidate(1, isOpen = false);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Message> was created with unknown prop '${key}'`);
    	});

    	const click_handler = async () => await link();

    	$$self.$capture_state = () => ({
    		Button,
    		Modal,
    		Row,
    		Container,
    		Col,
    		MessageManager,
    		manager,
    		message,
    		hook,
    		isOpen,
    		link
    	});

    	$$self.$inject_state = $$props => {
    		if ('manager' in $$props) manager = $$props.manager;
    		if ('message' in $$props) $$invalidate(0, message = $$props.message);
    		if ('isOpen' in $$props) $$invalidate(1, isOpen = $$props.isOpen);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [message, isOpen, link, hook, click_handler];
    }

    class Message extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { hook: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Message",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get hook() {
    		return this.$$.ctx[3];
    	}

    	set hook(value) {
    		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class FitbitIdentityApi {
        constructor(url) {
            this.url = url;
        }
        async register(data) {
            const registerEndPoint = `${this.url}/fitbit/register`;
            try {
                const response = await fetch(registerEndPoint, {
                    body: JSON.stringify(data),
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                if (response.ok)
                    return true;
            }
            catch (error) {
                console.error(error);
            }
            return false;
        }
        async authorize(data) {
            const registerEndPoint = `${this.url}/fitbit/authorize`;
            try {
                const response = await fetch(registerEndPoint, {
                    body: JSON.stringify(data),
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                if (response.ok)
                    return await response.json();
            }
            catch (error) {
                console.error(error);
            }
            return undefined;
        }
        async callback(code, redirectUrl) {
            const registerCallbackEndPoint = `${this.url}/fitbit/register/callback?code=${code}&redirectUrl=${redirectUrl}`;
            try {
                const response = await fetch(registerCallbackEndPoint);
                if (!response.ok) {
                    return false;
                }
                return true;
            }
            catch (error) {
                console.error(error);
            }
            return false;
        }
    }

    class IdentityApi {
        constructor(options) {
            this.url = options.url;
            this.fitbit = new FitbitIdentityApi(this.url);
        }
        /**
         * Register a new user using email and pass.
         * @param data The user data.
         * @returns True if registering the user succeeded, false otherwise.
         */
        async register(data) {
            const registerUrl = `${this.url}/register`;
            try {
                const response = await fetch(registerUrl, {
                    body: JSON.stringify(data),
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });
                if (!response.ok) {
                    return false;
                }
                return true;
            }
            catch (error) {
                console.error(error);
            }
            return false;
        }
        /**
         * Confirms a users' email using a token. The user is logged in after confirmation.
         * @param email The email.
         * @param token The token.
         */
        async confirmEmail(email, token) {
            const comfirmEmailUrl = `${this.url}/confirmemail?email=${email}&token=${token}`;
            try {
                const response = await fetch(comfirmEmailUrl);
                if (!response.ok) {
                    return false;
                }
                return true;
            }
            catch (error) {
                console.error(error);
            }
            return false;
        }
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

    var token = '%[a-f0-9]{2}';
    var singleMatcher = new RegExp(token, 'gi');
    var multiMatcher = new RegExp('(' + token + ')+', 'gi');

    function decodeComponents(components, split) {
    	try {
    		// Try to decode the entire string first
    		return decodeURIComponent(components.join(''));
    	} catch (err) {
    		// Do nothing
    	}

    	if (components.length === 1) {
    		return components;
    	}

    	split = split || 1;

    	// Split the array in 2 parts
    	var left = components.slice(0, split);
    	var right = components.slice(split);

    	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }

    function decode(input) {
    	try {
    		return decodeURIComponent(input);
    	} catch (err) {
    		var tokens = input.match(singleMatcher);

    		for (var i = 1; i < tokens.length; i++) {
    			input = decodeComponents(tokens, i).join('');

    			tokens = input.match(singleMatcher);
    		}

    		return input;
    	}
    }

    function customDecodeURIComponent(input) {
    	// Keep track of all the replacements and prefill the map with the `BOM`
    	var replaceMap = {
    		'%FE%FF': '\uFFFD\uFFFD',
    		'%FF%FE': '\uFFFD\uFFFD'
    	};

    	var match = multiMatcher.exec(input);
    	while (match) {
    		try {
    			// Decode as big chunks as possible
    			replaceMap[match[0]] = decodeURIComponent(match[0]);
    		} catch (err) {
    			var result = decode(match[0]);

    			if (result !== match[0]) {
    				replaceMap[match[0]] = result;
    			}
    		}

    		match = multiMatcher.exec(input);
    	}

    	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    	replaceMap['%C2'] = '\uFFFD';

    	var entries = Object.keys(replaceMap);

    	for (var i = 0; i < entries.length; i++) {
    		// Replace all decoded components
    		var key = entries[i];
    		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    	}

    	return input;
    }

    var decodeUriComponent = function (encodedURI) {
    	if (typeof encodedURI !== 'string') {
    		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    	}

    	try {
    		encodedURI = encodedURI.replace(/\+/g, ' ');

    		// Try the built in decoder first
    		return decodeURIComponent(encodedURI);
    	} catch (err) {
    		// Fallback to a more advanced decoder
    		return customDecodeURIComponent(encodedURI);
    	}
    };

    var splitOnFirst = (string, separator) => {
    	if (!(typeof string === 'string' && typeof separator === 'string')) {
    		throw new TypeError('Expected the arguments to be of type `string`');
    	}

    	if (separator === '') {
    		return [string];
    	}

    	const separatorIndex = string.indexOf(separator);

    	if (separatorIndex === -1) {
    		return [string];
    	}

    	return [
    		string.slice(0, separatorIndex),
    		string.slice(separatorIndex + separator.length)
    	];
    };

    var filterObj = function (obj, predicate) {
    	var ret = {};
    	var keys = Object.keys(obj);
    	var isArr = Array.isArray(predicate);

    	for (var i = 0; i < keys.length; i++) {
    		var key = keys[i];
    		var val = obj[key];

    		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
    			ret[key] = val;
    		}
    	}

    	return ret;
    };

    var queryString = createCommonjsModule(function (module, exports) {





    const isNullOrUndefined = value => value === null || value === undefined;

    const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

    function encoderForArrayFormat(options) {
    	switch (options.arrayFormat) {
    		case 'index':
    			return key => (result, value) => {
    				const index = result.length;

    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				if (value === null) {
    					return [...result, [encode(key, options), '[', index, ']'].join('')];
    				}

    				return [
    					...result,
    					[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
    				];
    			};

    		case 'bracket':
    			return key => (result, value) => {
    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				if (value === null) {
    					return [...result, [encode(key, options), '[]'].join('')];
    				}

    				return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
    			};

    		case 'comma':
    		case 'separator':
    		case 'bracket-separator': {
    			const keyValueSep = options.arrayFormat === 'bracket-separator' ?
    				'[]=' :
    				'=';

    			return key => (result, value) => {
    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				// Translate null to an empty string so that it doesn't serialize as 'null'
    				value = value === null ? '' : value;

    				if (result.length === 0) {
    					return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
    				}

    				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
    			};
    		}

    		default:
    			return key => (result, value) => {
    				if (
    					value === undefined ||
    					(options.skipNull && value === null) ||
    					(options.skipEmptyString && value === '')
    				) {
    					return result;
    				}

    				if (value === null) {
    					return [...result, encode(key, options)];
    				}

    				return [...result, [encode(key, options), '=', encode(value, options)].join('')];
    			};
    	}
    }

    function parserForArrayFormat(options) {
    	let result;

    	switch (options.arrayFormat) {
    		case 'index':
    			return (key, value, accumulator) => {
    				result = /\[(\d*)\]$/.exec(key);

    				key = key.replace(/\[\d*\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = {};
    				}

    				accumulator[key][result[1]] = value;
    			};

    		case 'bracket':
    			return (key, value, accumulator) => {
    				result = /(\[\])$/.exec(key);
    				key = key.replace(/\[\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = [value];
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};

    		case 'comma':
    		case 'separator':
    			return (key, value, accumulator) => {
    				const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
    				const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
    				value = isEncodedArray ? decode(value, options) : value;
    				const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
    				accumulator[key] = newValue;
    			};

    		case 'bracket-separator':
    			return (key, value, accumulator) => {
    				const isArray = /(\[\])$/.test(key);
    				key = key.replace(/\[\]$/, '');

    				if (!isArray) {
    					accumulator[key] = value ? decode(value, options) : value;
    					return;
    				}

    				const arrayValue = value === null ?
    					[] :
    					value.split(options.arrayFormatSeparator).map(item => decode(item, options));

    				if (accumulator[key] === undefined) {
    					accumulator[key] = arrayValue;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], arrayValue);
    			};

    		default:
    			return (key, value, accumulator) => {
    				if (accumulator[key] === undefined) {
    					accumulator[key] = value;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};
    	}
    }

    function validateArrayFormatSeparator(value) {
    	if (typeof value !== 'string' || value.length !== 1) {
    		throw new TypeError('arrayFormatSeparator must be single character string');
    	}
    }

    function encode(value, options) {
    	if (options.encode) {
    		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    	}

    	return value;
    }

    function decode(value, options) {
    	if (options.decode) {
    		return decodeUriComponent(value);
    	}

    	return value;
    }

    function keysSorter(input) {
    	if (Array.isArray(input)) {
    		return input.sort();
    	}

    	if (typeof input === 'object') {
    		return keysSorter(Object.keys(input))
    			.sort((a, b) => Number(a) - Number(b))
    			.map(key => input[key]);
    	}

    	return input;
    }

    function removeHash(input) {
    	const hashStart = input.indexOf('#');
    	if (hashStart !== -1) {
    		input = input.slice(0, hashStart);
    	}

    	return input;
    }

    function getHash(url) {
    	let hash = '';
    	const hashStart = url.indexOf('#');
    	if (hashStart !== -1) {
    		hash = url.slice(hashStart);
    	}

    	return hash;
    }

    function extract(input) {
    	input = removeHash(input);
    	const queryStart = input.indexOf('?');
    	if (queryStart === -1) {
    		return '';
    	}

    	return input.slice(queryStart + 1);
    }

    function parseValue(value, options) {
    	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
    		value = Number(value);
    	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    		value = value.toLowerCase() === 'true';
    	}

    	return value;
    }

    function parse(query, options) {
    	options = Object.assign({
    		decode: true,
    		sort: true,
    		arrayFormat: 'none',
    		arrayFormatSeparator: ',',
    		parseNumbers: false,
    		parseBooleans: false
    	}, options);

    	validateArrayFormatSeparator(options.arrayFormatSeparator);

    	const formatter = parserForArrayFormat(options);

    	// Create an object with no prototype
    	const ret = Object.create(null);

    	if (typeof query !== 'string') {
    		return ret;
    	}

    	query = query.trim().replace(/^[?#&]/, '');

    	if (!query) {
    		return ret;
    	}

    	for (const param of query.split('&')) {
    		if (param === '') {
    			continue;
    		}

    		let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

    		// Missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
    		formatter(decode(key, options), value, ret);
    	}

    	for (const key of Object.keys(ret)) {
    		const value = ret[key];
    		if (typeof value === 'object' && value !== null) {
    			for (const k of Object.keys(value)) {
    				value[k] = parseValue(value[k], options);
    			}
    		} else {
    			ret[key] = parseValue(value, options);
    		}
    	}

    	if (options.sort === false) {
    		return ret;
    	}

    	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
    		const value = ret[key];
    		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
    			// Sort object keys, not values
    			result[key] = keysSorter(value);
    		} else {
    			result[key] = value;
    		}

    		return result;
    	}, Object.create(null));
    }

    exports.extract = extract;
    exports.parse = parse;

    exports.stringify = (object, options) => {
    	if (!object) {
    		return '';
    	}

    	options = Object.assign({
    		encode: true,
    		strict: true,
    		arrayFormat: 'none',
    		arrayFormatSeparator: ','
    	}, options);

    	validateArrayFormatSeparator(options.arrayFormatSeparator);

    	const shouldFilter = key => (
    		(options.skipNull && isNullOrUndefined(object[key])) ||
    		(options.skipEmptyString && object[key] === '')
    	);

    	const formatter = encoderForArrayFormat(options);

    	const objectCopy = {};

    	for (const key of Object.keys(object)) {
    		if (!shouldFilter(key)) {
    			objectCopy[key] = object[key];
    		}
    	}

    	const keys = Object.keys(objectCopy);

    	if (options.sort !== false) {
    		keys.sort(options.sort);
    	}

    	return keys.map(key => {
    		const value = object[key];

    		if (value === undefined) {
    			return '';
    		}

    		if (value === null) {
    			return encode(key, options);
    		}

    		if (Array.isArray(value)) {
    			if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
    				return encode(key, options) + '[]';
    			}

    			return value
    				.reduce(formatter(key), [])
    				.join('&');
    		}

    		return encode(key, options) + '=' + encode(value, options);
    	}).filter(x => x.length > 0).join('&');
    };

    exports.parseUrl = (url, options) => {
    	options = Object.assign({
    		decode: true
    	}, options);

    	const [url_, hash] = splitOnFirst(url, '#');

    	return Object.assign(
    		{
    			url: url_.split('?')[0] || '',
    			query: parse(extract(url), options)
    		},
    		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
    	);
    };

    exports.stringifyUrl = (object, options) => {
    	options = Object.assign({
    		encode: true,
    		strict: true,
    		[encodeFragmentIdentifier]: true
    	}, options);

    	const url = removeHash(object.url).split('?')[0] || '';
    	const queryFromUrl = exports.extract(object.url);
    	const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

    	const query = Object.assign(parsedQueryFromUrl, object.query);
    	let queryString = exports.stringify(query, options);
    	if (queryString) {
    		queryString = `?${queryString}`;
    	}

    	let hash = getHash(object.url);
    	if (object.fragmentIdentifier) {
    		hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    	}

    	return `${url}${queryString}${hash}`;
    };

    exports.pick = (input, filter, options) => {
    	options = Object.assign({
    		parseFragmentIdentifier: true,
    		[encodeFragmentIdentifier]: false
    	}, options);

    	const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
    	return exports.stringifyUrl({
    		url,
    		query: filterObj(query, filter),
    		fragmentIdentifier
    	}, options);
    };

    exports.exclude = (input, filter, options) => {
    	const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);

    	return exports.pick(input, exclusionFilter, options);
    };
    });

    /* src/integrations/Fitbit.svelte generated by Svelte v3.44.0 */

    const { Error: Error_1 } = globals;
    const file$1 = "src/integrations/Fitbit.svelte";

    // (82:0) {#if isCallback}
    function create_if_block_2(ctx) {
    	let await_block_anchor;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block_1
    	};

    	handle_promise(/*callback*/ ctx[7](), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(82:0) {#if isCallback}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }
    function create_catch_block_1(ctx) {
    	const block = { c: noop, m: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(1:0) <script lang=\\\"ts\\\">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }
    function create_then_block_1(ctx) {
    	const block = { c: noop, m: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(1:0) <script lang=\\\"ts\\\">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }",
    		ctx
    	});

    	return block;
    }

    // (83:21)      <div></div>   {/await}
    function create_pending_block_1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			add_location(div, file$1, 83, 4, 2972);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(83:21)      <div></div>   {/await}",
    		ctx
    	});

    	return block;
    }

    // (88:0) {#if isConfirmEmail}
    function create_if_block_1(ctx) {
    	let await_block_anchor;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block
    	};

    	handle_promise(/*confirmEmail*/ ctx[8](), info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(88:0) {#if isConfirmEmail}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }
    function create_catch_block(ctx) {
    	const block = { c: noop, m: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script lang=\\\"ts\\\">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script lang="ts">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }
    function create_then_block(ctx) {
    	const block = { c: noop, m: noop, d: noop };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(1:0) <script lang=\\\"ts\\\">import { Button, Modal, Container, Row, FormGroup, Label, Input, Col, }",
    		ctx
    	});

    	return block;
    }

    // (89:25)      <div></div>   {/await}
    function create_pending_block(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			add_location(div, file$1, 89, 4, 3053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(89:25)      <div></div>   {/await}",
    		ctx
    	});

    	return block;
    }

    // (96:0) <Button class="btn-share w-100" on:click="{async () => await open()}"   >
    function create_default_slot_9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fitbit");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(96:0) <Button class=\\\"btn-share w-100\\\" on:click=\\\"{async () => await open()}\\\"   >",
    		ctx
    	});

    	return block;
    }

    // (99:0) {#if registerOpen}
    function create_if_block$1(ctx) {
    	let modal;
    	let current;

    	modal = new Modal({
    			props: {
    				body: true,
    				isOpen: /*registerOpen*/ ctx[4],
    				toggle: /*func*/ ctx[13],
    				header: "Connect your Fitbit account!",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const modal_changes = {};
    			if (dirty & /*registerOpen*/ 16) modal_changes.isOpen = /*registerOpen*/ ctx[4];
    			if (dirty & /*registerOpen*/ 16) modal_changes.toggle = /*func*/ ctx[13];

    			if (dirty & /*$$scope, registerOpen, email*/ 131096) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(99:0) {#if registerOpen}",
    		ctx
    	});

    	return block;
    }

    // (108:6) <Row class="sharing-illustration w-100">
    function create_default_slot_8(ctx) {
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div1;
    	let img1;
    	let img1_src_value;
    	let t1;
    	let div3;
    	let div2;
    	let img2;
    	let img2_src_value;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			img0 = element("img");
    			t0 = space();
    			div1 = element("div");
    			img1 = element("img");
    			t1 = space();
    			div3 = element("div");
    			div2 = element("div");
    			img2 = element("img");
    			if (!src_url_equal(img0.src, img0_src_value = "/img/providers/fitbit-logo.svg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "Fitbit logo");
    			add_location(img0, file$1, 109, 10, 3497);
    			attr_dev(div0, "class", "sharing-large-logo");
    			add_location(div0, file$1, 108, 8, 3454);
    			if (!src_url_equal(img1.src, img1_src_value = "/img/arrow.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "Arrow");
    			add_location(img1, file$1, 112, 10, 3621);
    			attr_dev(div1, "class", "sharing-arrow");
    			add_location(div1, file$1, 111, 8, 3583);
    			if (!src_url_equal(img2.src, img2_src_value = "/img/logo-large.avif")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "Bike data project");
    			add_location(img2, file$1, 116, 12, 3767);
    			attr_dev(div2, "class", "sharing-logo");
    			add_location(div2, file$1, 115, 10, 3728);
    			attr_dev(div3, "class", "sharing-large-logo");
    			add_location(div3, file$1, 114, 8, 3685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, img0);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img1);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, img2);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(108:6) <Row class=\\\"sharing-illustration w-100\\\">",
    		ctx
    	});

    	return block;
    }

    // (128:10) <Label for="email">
    function create_default_slot_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Email");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(128:10) <Label for=\\\"email\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:8) <FormGroup>
    function create_default_slot_6$2(ctx) {
    	let label;
    	let t;
    	let input;
    	let updating_value;
    	let current;

    	label = new Label({
    			props: {
    				for: "email",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function input_value_binding(value) {
    		/*input_value_binding*/ ctx[11](value);
    	}

    	let input_props = {
    		type: "email",
    		name: "email",
    		id: "email",
    		placeholder: "your@email.com"
    	};

    	if (/*email*/ ctx[3] !== void 0) {
    		input_props.value = /*email*/ ctx[3];
    	}

    	input = new Input({ props: input_props, $$inline: true });
    	binding_callbacks.push(() => bind(input, 'value', input_value_binding));

    	const block = {
    		c: function create() {
    			create_component(label.$$.fragment);
    			t = space();
    			create_component(input.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(label, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(input, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const label_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				label_changes.$$scope = { dirty, ctx };
    			}

    			label.$set(label_changes);
    			const input_changes = {};

    			if (!updating_value && dirty & /*email*/ 8) {
    				updating_value = true;
    				input_changes.value = /*email*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			input.$set(input_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label.$$.fragment, local);
    			transition_in(input.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label.$$.fragment, local);
    			transition_out(input.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(label, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(input, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(127:8) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (121:6) <Row class="w-100">
    function create_default_slot_5$2(ctx) {
    	let p0;
    	let t0;
    	let strong;
    	let t2;
    	let t3;
    	let formgroup;
    	let t4;
    	let p1;
    	let current;

    	formgroup = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = text("When connecting your Fitbit account ");
    			strong = element("strong");
    			strong.textContent = "any cycling trips you do with your Fitbit device get shared\n            automatically";
    			t2 = text(" with BikeDataProject.");
    			t3 = space();
    			create_component(formgroup.$$.fragment);
    			t4 = space();
    			p1 = element("p");
    			p1.textContent = "Your connection with BikeDataProject won't last forever, if you share\n          your email address we will notify you when your connection to the\n          BikeDataProject is broken.";
    			add_location(strong, file$1, 122, 46, 3955);
    			add_location(p0, file$1, 121, 8, 3905);
    			add_location(p1, file$1, 135, 8, 4365);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t0);
    			append_dev(p0, strong);
    			append_dev(p0, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(formgroup, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, p1, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formgroup_changes = {};

    			if (dirty & /*$$scope, email*/ 131080) {
    				formgroup_changes.$$scope = { dirty, ctx };
    			}

    			formgroup.$set(formgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			destroy_component(formgroup, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(p1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(121:6) <Row class=\\\"w-100\\\">",
    		ctx
    	});

    	return block;
    }

    // (144:10) <Button             color="primary"             on:click="{async () => {               registerOpen = false;               await buttonPush();             }}">
    function create_default_slot_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Connect my Fitbit account");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(144:10) <Button             color=\\\"primary\\\"             on:click=\\\"{async () => {               registerOpen = false;               await buttonPush();             }}\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:8) <Col xs="6">
    function create_default_slot_3$2(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_1*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(143:8) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:6) <Row class="w-100">
    function create_default_slot_2$2(ctx) {
    	let col;
    	let current;

    	col = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col_changes = {};

    			if (dirty & /*$$scope, registerOpen*/ 131088) {
    				col_changes.$$scope = { dirty, ctx };
    			}

    			col.$set(col_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(142:6) <Row class=\\\"w-100\\\">",
    		ctx
    	});

    	return block;
    }

    // (107:4) <Container>
    function create_default_slot_1$2(ctx) {
    	let row0;
    	let t0;
    	let row1;
    	let t1;
    	let row2;
    	let current;

    	row0 = new Row({
    			props: {
    				class: "sharing-illustration w-100",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row1 = new Row({
    			props: {
    				class: "w-100",
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	row2 = new Row({
    			props: {
    				class: "w-100",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row0.$$.fragment);
    			t0 = space();
    			create_component(row1.$$.fragment);
    			t1 = space();
    			create_component(row2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(row1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(row2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row0_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				row0_changes.$$scope = { dirty, ctx };
    			}

    			row0.$set(row0_changes);
    			const row1_changes = {};

    			if (dirty & /*$$scope, email*/ 131080) {
    				row1_changes.$$scope = { dirty, ctx };
    			}

    			row1.$set(row1_changes);
    			const row2_changes = {};

    			if (dirty & /*$$scope, registerOpen*/ 131088) {
    				row2_changes.$$scope = { dirty, ctx };
    			}

    			row2.$set(row2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row0.$$.fragment, local);
    			transition_in(row1.$$.fragment, local);
    			transition_in(row2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row0.$$.fragment, local);
    			transition_out(row1.$$.fragment, local);
    			transition_out(row2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(row1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(row2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(107:4) <Container>",
    		ctx
    	});

    	return block;
    }

    // (100:2) <Modal     body     isOpen="{registerOpen}"     toggle="{async () => {       registerOpen = false;     }}"     header="Connect your Fitbit account!">
    function create_default_slot$2(ctx) {
    	let container;
    	let current;

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(container.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(container, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const container_changes = {};

    			if (dirty & /*$$scope, registerOpen, email*/ 131096) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(container, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(100:2) <Modal     body     isOpen=\\\"{registerOpen}\\\"     toggle=\\\"{async () => {       registerOpen = false;     }}\\\"     header=\\\"Connect your Fitbit account!\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let t0;
    	let t1;
    	let message;
    	let updating_hook;
    	let t2;
    	let button;
    	let t3;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = /*isCallback*/ ctx[0] && create_if_block_2(ctx);
    	let if_block1 = /*isConfirmEmail*/ ctx[1] && create_if_block_1(ctx);

    	function message_hook_binding(value) {
    		/*message_hook_binding*/ ctx[9](value);
    	}

    	let message_props = {};

    	if (/*messageHook*/ ctx[2] !== void 0) {
    		message_props.hook = /*messageHook*/ ctx[2];
    	}

    	message = new Message({ props: message_props, $$inline: true });
    	binding_callbacks.push(() => bind(message, 'hook', message_hook_binding));

    	button = new Button({
    			props: {
    				class: "btn-share w-100",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[10]);
    	let if_block2 = /*registerOpen*/ ctx[4] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(message.$$.fragment);
    			t2 = space();
    			create_component(button.$$.fragment);
    			t3 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(message, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(button, target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isCallback*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*isConfirmEmail*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const message_changes = {};

    			if (!updating_hook && dirty & /*messageHook*/ 4) {
    				updating_hook = true;
    				message_changes.hook = /*messageHook*/ ctx[2];
    				add_flush_callback(() => updating_hook = false);
    			}

    			message.$set(message_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*registerOpen*/ ctx[4]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*registerOpen*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(message, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const redirectUrl = "http://localhost:8080/fitbit/callback";
    const confirmEmailUrl = "http://localhost:8080/fitbit/confirmemail";

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Fitbit', slots, []);
    	let { isCallback = false } = $$props;
    	let { isConfirmEmail = false } = $$props;
    	let messageHook;

    	let identityApi = new IdentityApi({
    			url: "http://localhost:8080/api/identity"
    		});

    	let email;
    	let registerOpen = false;

    	let open = async () => {
    		$$invalidate(4, registerOpen = true);
    	};

    	let buttonPush = async () => {
    		if (email) {
    			await register();
    		} else {
    			await authorize();
    		}
    	};

    	let authorize = async () => {
    		
    	};

    	let register = async () => {
    		const registerResponse = await identityApi.fitbit.register({ confirmEmailUrl, email });

    		// show message if register failed.
    		if (!registerResponse) {
    			messageHook.show("Our apologies, linking your fitbit account failed, please try again later.");
    			return;
    		}

    		messageHook.show("Thank you for sharing, we've sent you an email to confirm.");
    	};

    	let callback = async () => {
    		const parsed = queryString.parse(window.location.search);

    		if (!parsed.code) {
    			throw Error("callback without code");
    		}

    		const ok = await identityApi.fitbit.callback(parsed.code, redirectUrl);

    		if (ok) {
    			messageHook.show("Your fitbit account was successfully linked, thank you!");
    		} else {
    			messageHook.show("Something went wrong while linking your fitbit account, please try again or get in touch with us!");
    		}
    	};

    	let confirmEmail = async () => {
    		const parsed = queryString.parse(window.location.search);

    		if (!parsed.email) {
    			throw Error("callback without code");
    		}

    		if (!parsed.token) {
    			throw Error("callback without token");
    		}

    		// confirm email, this also logs in the user.
    		const emailResult = await identityApi.confirmEmail(parsed.email, parsed.token);

    		// show message if email confirmation failed.
    		if (!emailResult) {
    			messageHook.show("Our apologies, we could not confirm your email, the link is probably expired. Try connecting your account again.");
    			return;
    		}

    		// call register again, this time the user is logged in.
    		// this should return the authorize link only.
    		const registerResponse = await identityApi.fitbit.authorize({ redirectUrl });

    		// check if there is a response.
    		if (typeof registerResponse === "undefined") {
    			messageHook.show("Our apologies, linking your fitbit account failed, please try again later.");
    			return;
    		}

    		// the response should be a url to redirect.
    		window.location.href = registerResponse.url;
    	};

    	const writable_props = ['isCallback', 'isConfirmEmail'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Fitbit> was created with unknown prop '${key}'`);
    	});

    	function message_hook_binding(value) {
    		messageHook = value;
    		$$invalidate(2, messageHook);
    	}

    	const click_handler = async () => await open();

    	function input_value_binding(value) {
    		email = value;
    		$$invalidate(3, email);
    	}

    	const click_handler_1 = async () => {
    		$$invalidate(4, registerOpen = false);
    		await buttonPush();
    	};

    	const func = async () => {
    		$$invalidate(4, registerOpen = false);
    	};

    	$$self.$$set = $$props => {
    		if ('isCallback' in $$props) $$invalidate(0, isCallback = $$props.isCallback);
    		if ('isConfirmEmail' in $$props) $$invalidate(1, isConfirmEmail = $$props.isConfirmEmail);
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		Modal,
    		Container,
    		Row,
    		FormGroup,
    		Label,
    		Input,
    		Col,
    		IdentityApi,
    		Message,
    		queryString,
    		isCallback,
    		isConfirmEmail,
    		messageHook,
    		identityApi,
    		email,
    		registerOpen,
    		open,
    		redirectUrl,
    		confirmEmailUrl,
    		buttonPush,
    		authorize,
    		register,
    		callback,
    		confirmEmail
    	});

    	$$self.$inject_state = $$props => {
    		if ('isCallback' in $$props) $$invalidate(0, isCallback = $$props.isCallback);
    		if ('isConfirmEmail' in $$props) $$invalidate(1, isConfirmEmail = $$props.isConfirmEmail);
    		if ('messageHook' in $$props) $$invalidate(2, messageHook = $$props.messageHook);
    		if ('identityApi' in $$props) identityApi = $$props.identityApi;
    		if ('email' in $$props) $$invalidate(3, email = $$props.email);
    		if ('registerOpen' in $$props) $$invalidate(4, registerOpen = $$props.registerOpen);
    		if ('open' in $$props) $$invalidate(5, open = $$props.open);
    		if ('buttonPush' in $$props) $$invalidate(6, buttonPush = $$props.buttonPush);
    		if ('authorize' in $$props) authorize = $$props.authorize;
    		if ('register' in $$props) register = $$props.register;
    		if ('callback' in $$props) $$invalidate(7, callback = $$props.callback);
    		if ('confirmEmail' in $$props) $$invalidate(8, confirmEmail = $$props.confirmEmail);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isCallback,
    		isConfirmEmail,
    		messageHook,
    		email,
    		registerOpen,
    		open,
    		buttonPush,
    		callback,
    		confirmEmail,
    		message_hook_binding,
    		click_handler,
    		input_value_binding,
    		click_handler_1,
    		func
    	];
    }

    class Fitbit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { isCallback: 0, isConfirmEmail: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Fitbit",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get isCallback() {
    		throw new Error_1("<Fitbit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCallback(value) {
    		throw new Error_1("<Fitbit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isConfirmEmail() {
    		throw new Error_1("<Fitbit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isConfirmEmail(value) {
    		throw new Error_1("<Fitbit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/views/home/Share.svelte generated by Svelte v3.44.0 */
    const file = "src/views/home/Share.svelte";

    // (21:10) <Col xs="6">
    function create_default_slot_6$1(ctx) {
    	let h4;
    	let t0_value = /*$_*/ ctx[2]("Connect_existing_account") + "";
    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let fitbit_1;
    	let t2;
    	let p;
    	let current;

    	fitbit_1 = new Fitbit({
    			props: {
    				isCallback: /*fitbit*/ ctx[0].isCallback,
    				isConfirmEmail: /*fitbit*/ ctx[0].isConfirmEmail
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			create_component(fitbit_1.$$.fragment);
    			t2 = space();
    			p = element("p");
    			p.textContent = "After connecting your account your data will be automatically\n              shared with us. You can revoke our access at any time.";
    			attr_dev(h4, "class", "svelte-1lcp26q");
    			add_location(h4, file, 21, 12, 614);
    			attr_dev(div0, "class", "mb-1");
    			add_location(div0, file, 23, 14, 706);
    			attr_dev(div1, "class", "mt-1 mb-3");
    			add_location(div1, file, 22, 12, 668);
    			add_location(p, file, 29, 12, 914);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(fitbit_1, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 4) && t0_value !== (t0_value = /*$_*/ ctx[2]("Connect_existing_account") + "")) set_data_dev(t0, t0_value);
    			const fitbit_1_changes = {};
    			if (dirty & /*fitbit*/ 1) fitbit_1_changes.isCallback = /*fitbit*/ ctx[0].isCallback;
    			if (dirty & /*fitbit*/ 1) fitbit_1_changes.isConfirmEmail = /*fitbit*/ ctx[0].isConfirmEmail;
    			fitbit_1.$set(fitbit_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fitbit_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fitbit_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(fitbit_1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(21:10) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (35:10) <Col xs="6">
    function create_default_slot_5$1(ctx) {
    	let h4;
    	let t1;
    	let div1;
    	let div0;
    	let gpx;
    	let t2;
    	let p;
    	let current;
    	gpx = new Gpx({ $$inline: true });

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Upload your data";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			create_component(gpx.$$.fragment);
    			t2 = space();
    			p = element("p");
    			p.textContent = "Have GPX tracks of your cycling trips, upload them here!";
    			attr_dev(h4, "class", "svelte-1lcp26q");
    			add_location(h4, file, 35, 12, 1132);
    			attr_dev(div0, "class", "mb-1");
    			add_location(div0, file, 37, 14, 1208);
    			attr_dev(div1, "class", "mt-1 mb-3");
    			add_location(div1, file, 36, 12, 1170);
    			add_location(p, file, 39, 12, 1271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(gpx, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, p, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(gpx.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(gpx.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(gpx);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(35:10) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (20:8) <Row>
    function create_default_slot_4$1(ctx) {
    	let col0;
    	let t;
    	let col1;
    	let current;

    	col0 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col0.$$.fragment);
    			t = space();
    			create_component(col1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(col1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col0_changes = {};

    			if (dirty & /*$$scope, fitbit, $_*/ 21) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(col1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(20:8) <Row>",
    		ctx
    	});

    	return block;
    }

    // (19:6) <Col class="mt-5" xs="6">
    function create_default_slot_3$1(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, fitbit, $_*/ 21) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(19:6) <Col class=\\\"mt-5\\\" xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:6) <Col xs="6">
    function create_default_slot_2$1(ctx) {
    	let p0;
    	let t0_value = /*$_*/ ctx[2]("Contribute_big") + "";
    	let t0;
    	let t1;
    	let h2;
    	let t2_value = /*$_*/ ctx[2]("Donate_title") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[2]("Several_ways_to_contribute") + "";
    	let t4;
    	let t5;
    	let p2;
    	let t6_value = /*$_*/ ctx[2]("You_not_using") + "";
    	let t6;

    	const block = {
    		c: function create() {
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			h2 = element("h2");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			t6 = text(t6_value);
    			attr_dev(p0, "class", "background-big-letter");
    			add_location(p0, file, 44, 8, 1407);
    			add_location(h2, file, 45, 8, 1475);
    			add_location(p1, file, 46, 8, 1513);
    			add_location(p2, file, 49, 8, 1583);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t6);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 4 && t0_value !== (t0_value = /*$_*/ ctx[2]("Contribute_big") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 4 && t2_value !== (t2_value = /*$_*/ ctx[2]("Donate_title") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 4 && t4_value !== (t4_value = /*$_*/ ctx[2]("Several_ways_to_contribute") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 4 && t6_value !== (t6_value = /*$_*/ ctx[2]("You_not_using") + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(p2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(44:6) <Col xs=\\\"6\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:4) <Row>
    function create_default_slot_1$1(ctx) {
    	let col0;
    	let t;
    	let col1;
    	let current;

    	col0 = new Col({
    			props: {
    				class: "mt-5",
    				xs: "6",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	col1 = new Col({
    			props: {
    				xs: "6",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(col0.$$.fragment);
    			t = space();
    			create_component(col1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(col0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(col1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const col0_changes = {};

    			if (dirty & /*$$scope, fitbit, $_*/ 21) {
    				col0_changes.$$scope = { dirty, ctx };
    			}

    			col0.$set(col0_changes);
    			const col1_changes = {};

    			if (dirty & /*$$scope, $_*/ 20) {
    				col1_changes.$$scope = { dirty, ctx };
    			}

    			col1.$set(col1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(col0.$$.fragment, local);
    			transition_in(col1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(col0.$$.fragment, local);
    			transition_out(col1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(col0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(col1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(18:4) <Row>",
    		ctx
    	});

    	return block;
    }

    // (17:2) <Container>
    function create_default_slot$1(ctx) {
    	let row;
    	let current;

    	row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, $_, fitbit*/ 21) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(17:2) <Container>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let message;
    	let updating_hook;
    	let t0;
    	let section;
    	let img;
    	let img_src_value;
    	let t1;
    	let container;
    	let current;

    	function message_hook_binding(value) {
    		/*message_hook_binding*/ ctx[3](value);
    	}

    	let message_props = {};

    	if (/*messageHook*/ ctx[1] !== void 0) {
    		message_props.hook = /*messageHook*/ ctx[1];
    	}

    	message = new Message({ props: message_props, $$inline: true });
    	binding_callbacks.push(() => bind(message, 'hook', message_hook_binding));

    	container = new Container({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(message.$$.fragment);
    			t0 = space();
    			section = element("section");
    			img = element("img");
    			t1 = space();
    			create_component(container.$$.fragment);
    			attr_dev(img, "class", "illustration");
    			if (!src_url_equal(img.src, img_src_value = "/img/bike_illustration.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "Line illustration of a bike and some trees.");
    			add_location(img, file, 12, 2, 385);
    			attr_dev(section, "id", "share-section");
    			add_location(section, file, 11, 0, 354);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(message, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, section, anchor);
    			append_dev(section, img);
    			append_dev(section, t1);
    			mount_component(container, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const message_changes = {};

    			if (!updating_hook && dirty & /*messageHook*/ 2) {
    				updating_hook = true;
    				message_changes.hook = /*messageHook*/ ctx[1];
    				add_flush_callback(() => updating_hook = false);
    			}

    			message.$set(message_changes);
    			const container_changes = {};

    			if (dirty & /*$$scope, $_, fitbit*/ 21) {
    				container_changes.$$scope = { dirty, ctx };
    			}

    			container.$set(container_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(message.$$.fragment, local);
    			transition_in(container.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(message.$$.fragment, local);
    			transition_out(container.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(message, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(section);
    			destroy_component(container);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(X, '_');
    	component_subscribe($$self, X, $$value => $$invalidate(2, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Share', slots, []);
    	let { fitbit } = $$props;
    	let messageHook;
    	const writable_props = ['fitbit'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Share> was created with unknown prop '${key}'`);
    	});

    	function message_hook_binding(value) {
    		messageHook = value;
    		$$invalidate(1, messageHook);
    	}

    	$$self.$$set = $$props => {
    		if ('fitbit' in $$props) $$invalidate(0, fitbit = $$props.fitbit);
    	};

    	$$self.$capture_state = () => ({
    		Container,
    		Row,
    		Col,
    		Gpx,
    		Message,
    		Fitbit,
    		_: X,
    		fitbit,
    		messageHook,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('fitbit' in $$props) $$invalidate(0, fitbit = $$props.fitbit);
    		if ('messageHook' in $$props) $$invalidate(1, messageHook = $$props.messageHook);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fitbit, messageHook, $_, message_hook_binding];
    }

    class Share extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { fitbit: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Share",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*fitbit*/ ctx[0] === undefined && !('fitbit' in props)) {
    			console.warn("<Share> was created without expected prop 'fitbit'");
    		}
    	}

    	get fitbit() {
    		throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fitbit(value) {
    		throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/views/home/Home.svelte generated by Svelte v3.44.0 */

    function create_fragment$1(ctx) {
    	let head;
    	let t0;
    	let help;
    	let t1;
    	let share;
    	let t2;
    	let data;
    	let t3;
    	let opendata;
    	let t4;
    	let power;
    	let t5;
    	let newsletter;
    	let t6;
    	let partners;
    	let current;
    	head = new Head({ $$inline: true });
    	help = new Help$3({ $$inline: true });

    	share = new Share({
    			props: { fitbit: /*fitbit*/ ctx[0] },
    			$$inline: true
    		});

    	data = new Data$3({ $$inline: true });
    	opendata = new OpenData({ $$inline: true });
    	power = new Power$3({ $$inline: true });
    	newsletter = new Newsletter({ $$inline: true });
    	partners = new Partners$3({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(head.$$.fragment);
    			t0 = space();
    			create_component(help.$$.fragment);
    			t1 = space();
    			create_component(share.$$.fragment);
    			t2 = space();
    			create_component(data.$$.fragment);
    			t3 = space();
    			create_component(opendata.$$.fragment);
    			t4 = space();
    			create_component(power.$$.fragment);
    			t5 = space();
    			create_component(newsletter.$$.fragment);
    			t6 = space();
    			create_component(partners.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(head, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(help, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(share, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(data, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(opendata, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(power, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(newsletter, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(partners, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const share_changes = {};
    			if (dirty & /*fitbit*/ 1) share_changes.fitbit = /*fitbit*/ ctx[0];
    			share.$set(share_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(head.$$.fragment, local);
    			transition_in(help.$$.fragment, local);
    			transition_in(share.$$.fragment, local);
    			transition_in(data.$$.fragment, local);
    			transition_in(opendata.$$.fragment, local);
    			transition_in(power.$$.fragment, local);
    			transition_in(newsletter.$$.fragment, local);
    			transition_in(partners.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(head.$$.fragment, local);
    			transition_out(help.$$.fragment, local);
    			transition_out(share.$$.fragment, local);
    			transition_out(data.$$.fragment, local);
    			transition_out(opendata.$$.fragment, local);
    			transition_out(power.$$.fragment, local);
    			transition_out(newsletter.$$.fragment, local);
    			transition_out(partners.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(head, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(help, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(share, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(data, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(opendata, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(power, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(newsletter, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(partners, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	let { fitbit = { isCallback: false, isConfirmEmail: false } } = $$props;
    	const writable_props = ['fitbit'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('fitbit' in $$props) $$invalidate(0, fitbit = $$props.fitbit);
    	};

    	$$self.$capture_state = () => ({
    		Data: Data$3,
    		Head,
    		Help: Help$3,
    		Newsletter,
    		OpenData,
    		Partners: Partners$3,
    		Power: Power$3,
    		Share,
    		fitbit
    	});

    	$$self.$inject_state = $$props => {
    		if ('fitbit' in $$props) $$invalidate(0, fitbit = $$props.fitbit);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [fitbit];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { fitbit: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get fitbit() {
    		throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fitbit(value) {
    		throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.44.0 */

    // (19:0) {:else}
    function create_else_block(ctx) {
    	let router;
    	let current;

    	router = new Router$1({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(19:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:0) {#if $isLoading}
    function create_if_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Please wait...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(17:0) {#if $isLoading}",
    		ctx
    	});

    	return block;
    }

    // (22:2) <Route path="/">
    function create_default_slot_6(ctx) {
    	let home;
    	let current;
    	home = new Home({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(22:2) <Route path=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:2) <Route path="faq">
    function create_default_slot_5(ctx) {
    	let faq;
    	let current;
    	faq = new Faq$3({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(faq.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(faq, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(faq.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(faq.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(faq, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(26:2) <Route path=\\\"faq\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:2) <Route path="about">
    function create_default_slot_4(ctx) {
    	let about;
    	let current;
    	about = new About$3({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(about.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(about, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(about.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(about.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(about, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(30:2) <Route path=\\\"about\\\">",
    		ctx
    	});

    	return block;
    }

    // (34:2) <Route path="datamap">
    function create_default_slot_3(ctx) {
    	let data;
    	let current;
    	data = new Data$4({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(data.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(data, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(data.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(data.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(data, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(34:2) <Route path=\\\"datamap\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:2) <Route path="fitbit/callback">
    function create_default_slot_2(ctx) {
    	let home;
    	let current;

    	home = new Home({
    			props: {
    				fitbit: { isCallback: true, isConfirmEmail: false }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(38:2) <Route path=\\\"fitbit/callback\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:2) <Route path="fitbit/confirmemail">
    function create_default_slot_1(ctx) {
    	let home;
    	let current;

    	home = new Home({
    			props: {
    				fitbit: { isCallback: false, isConfirmEmail: true }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(home.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(home, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(home.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(home.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(home, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(44:2) <Route path=\\\"fitbit/confirmemail\\\">",
    		ctx
    	});

    	return block;
    }

    // (20:0) <Router>
    function create_default_slot(ctx) {
    	let header;
    	let t0;
    	let route0;
    	let t1;
    	let route1;
    	let t2;
    	let route2;
    	let t3;
    	let route3;
    	let t4;
    	let route4;
    	let t5;
    	let route5;
    	let t6;
    	let footer;
    	let current;
    	header = new Header({ $$inline: true });

    	route0 = new Route$1({
    			props: {
    				path: "/",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route1 = new Route$1({
    			props: {
    				path: "faq",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route2 = new Route$1({
    			props: {
    				path: "about",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route3 = new Route$1({
    			props: {
    				path: "datamap",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route4 = new Route$1({
    			props: {
    				path: "fitbit/callback",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route5 = new Route$1({
    			props: {
    				path: "fitbit/confirmemail",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(header.$$.fragment);
    			t0 = space();
    			create_component(route0.$$.fragment);
    			t1 = space();
    			create_component(route1.$$.fragment);
    			t2 = space();
    			create_component(route2.$$.fragment);
    			t3 = space();
    			create_component(route3.$$.fragment);
    			t4 = space();
    			create_component(route4.$$.fragment);
    			t5 = space();
    			create_component(route5.$$.fragment);
    			t6 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(header, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(route0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(route1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(route2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(route3, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(route4, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(route5, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route0_changes.$$scope = { dirty, ctx };
    			}

    			route0.$set(route0_changes);
    			const route1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route1_changes.$$scope = { dirty, ctx };
    			}

    			route1.$set(route1_changes);
    			const route2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route2_changes.$$scope = { dirty, ctx };
    			}

    			route2.$set(route2_changes);
    			const route3_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route3_changes.$$scope = { dirty, ctx };
    			}

    			route3.$set(route3_changes);
    			const route4_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route4_changes.$$scope = { dirty, ctx };
    			}

    			route4.$set(route4_changes);
    			const route5_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				route5_changes.$$scope = { dirty, ctx };
    			}

    			route5.$set(route5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(route0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(route1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(route2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(route3, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(route4, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(route5, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(20:0) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$isLoading*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $isLoading;
    	validate_store(k, 'isLoading');
    	component_subscribe($$self, k, $$value => $$invalidate(0, $isLoading = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	y("en", () => Promise.resolve().then(function () { return en$1; }));
    	y("fr", () => Promise.resolve().then(function () { return fr$1; }));
    	y("nl", () => Promise.resolve().then(function () { return nl$1; }));

    	$({
    		fallbackLocale: "en",
    		initialLocale: I()
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router: Router$1,
    		Route: Route$1,
    		Footer,
    		Header,
    		About: About$3,
    		Faq: Faq$3,
    		Data: Data$4,
    		Home,
    		register: y,
    		init: $,
    		getLocaleFromNavigator: I,
    		isLoading: k,
    		$isLoading
    	});

    	return [$isLoading];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    var app = new App({
        target: document.body
    });

    var Contribute$2 = "Participate";
    var The_data$2 = "The Data";
    var About$2 = "About";
    var FAQ$2 = "FAQ";
    var Contact$2 = "Contact";
    var Heading$2 = "Citizens collecting cycling data to make cities more bike-friendly.";
    var Introduction$2 = "Thanks to the data shared by citizens around the world, the Bike Data Project aims at showing where and when people ride their bicycles. The data gathered will help local communities and decision-makers make cycling and cities safer.";
    var Label_total_km$2 = "Total kilometers cycled and shared so far by citizens all over the world";
    var Help_title$2 = "We need your help!";
    var Ask_for_favor$2 = "To make this work we want to ask you to share your cycling data.";
    var By_sharing_your$2 = "We need to know where you ride your bicycle. Your data contributions, combined with the data from many other cyclists, will make cities more adapted to cyclists.";
    var Every_cyclist_can$2 = "All cyclists are welcome to contribute to this project. Some people already track their activity for training purposes. That’s great, but we also want to consider other types of activities such as: commuting to work, dropping the kids off at school or a quick ride to the grocery store.";
    var Donate_title$2 = "Share your bike data";
    var Several_ways_to_contribute$2 = "There are a several ways you can contribute to the Bike Data Project. For now, you can either connect your Strava account or upload your Garmin files. Once your app is connected you can just carry on as usual and your rides will be automatically uploaded to the Bike Data Project platform.";
    var You_not_using$2 = "What if you aren't using any of the listed apps yet? You will be able to download and use the Bike Data Project app soon. Moreover, we're also working on the integration of other cycling apps!";
    var Connect_existing_account$2 = "Connect your existing account";
    var Download_our_app$2 = "Download our app (coming soon)";
    var Data_title$2 = "Collected data worldwide";
    var Rides_collected$2 = "rides collected";
    var Distance_collected$2 = "distance collected";
    var Average_duration$2 = "average duration";
    var Average_speed$2 = "average speed";
    var Average_distance$2 = "average distance";
    var co2_saved$2 = "CO2 saved";
    var Data_subtitle$2 = "Interested in the data by region?";
    var Data_button$2 = "Explore the data";
    var Contribute_title$2 = "Who's the data for?";
    var People_who_work$2 = "People who work in departments of transportation and city planners around the world need data like this to help them develop modern infrastructure and sustainable cities. Some of them are aware and others we have to convince. And the more data we can provide, the greater impact we shall have.";
    var Common_goal$2 = "The data can also be very useful for other bike related products and services. The common goal is aggregating cycling data and make it available as open data in order to make cities better adapted to cyclists. For us and the people to come.";
    var Visible_title$2 = "More cycling data means more power to and for cyclists";
    var Community_more_visible$2 = "The Bike Data Project provides the opportunity to collect all cycling data from different applications into one platform, which is - based on the principle of open source and open data - adaptable and accessible by everyone to ensure it benefits society.";
    var Globally_but_locally$2 = "Little is known about how cyclists move around in cities today. If there’s data available, it’s closed and restricted data sold by one single app provider or static data collected through manual counts. If we want to have more people cycling in cities and make the bicycle as easy and logical to opt for as the car, we also need to get the same data insights into cyclists’ behavior as we have about car transport.";
    var Informed_title$2 = "Stay informed";
    var Email_label$2 = "Email";
    var Informed_placeholder$2 = "Your email adress";
    var Partners_title$2 = "Project Partners";
    var Footer_intro$2 = "Bike Data Project is a project managed by Open Knowledge Belgium";
    var Footer_nav_title$2 = "Information";
    var Footer_contact$2 = "Contact";
    var Footer_street$2 = "Cantersteen 12";
    var Footer_city$2 = "1000 Brussels";
    var Footer_copyright_one$2 = "Except where otherwise noted, content on this site is licensed under a";
    var Footer_copyright_two$2 = "Creative Commons Attribution 4.0 International License";
    var Terms_of_use$2 = "Terms of use";
    var Privacy_policy$2 = "Privacy policy";
    var Cookie_policy$2 = "Cookie policy";
    var Help$2 = "Help";
    var Contribute_big$2 = "Share";
    var Data$2 = "Data";
    var Power$2 = "Power";
    var Partners$2 = "Partners";
    var About_us$2 = "About";
    var Faq$2 = "Faq";
    var Contact_us$2 = "Contact";
    var Cookies$2 = "Cookies";
    var Privacy$2 = "Privacy";
    var Terms$2 = "Terms";
    var Map_title$2 = "The Data";
    var Data_content_one$2 = "Scroll down to explore the map with all cycling data collected so far.";
    var Data_content_two$2 = "The data collected by this project consists of contributions made by all different kinds of cyclists. All individual cycling data are aggregated into collective data. The collective data gives us patterns we can use to demonstrate where and when cyclists ride their bicycles.";
    var Data_content_three$2 = "The anonymous aggregated cycling data will be opened up to the public as open data. The open data provided by the Bike Data Project platform can be freely used by different stakeholders and for different purposes. Here’s a non-exhaustive list of different use cases of the open data:";
    var Data_content_listOne$2 = "Transportation experts, city planners, mobility planners and urban designers around the world need open data like this to help them develop modern infrastructure and sustainable cities.";
    var Data_content_listTwo$2 = "Citizens can get a high-level overview of the number of cyclists and kilometers cycled in the city and check out a map with the number of cyclists per route.";
    var Data_content_listThree$2 = "Civil society and journalists use the data to analyse the situation for cyclists in the city, such as the amount of time cyclists lose on average at traffic lights.";
    var Data_content_listFour$2 = "Data and software companies can dive into the data to obtain smart cycling insights and build tools like advanced cycling route planners and recommendation engines to improve cycling infrastructure. The data can also be very useful for other bike related products and services.";
    var Data_content_four$2 = "All aggregated cycling data will be available as open data by the end of October 2020. For now, you can contribute to the project by donating your cycling data.";
    var Map_subtitle$2 = "Have a look at our open source code";
    var About_title$2 = "About the Bike Data Project";
    var About_intro$2 = "With the Bike Data Project, Open Knowledge Belgium – the umbrella organisation for open knowledge and open data initiatives in Belgium – wants to build a community-driven open bike data platform that collects data on where and when people actually cycle. The project aims at aggregating data from cyclists, coming from different mobile applications and sources, into one open bike data platform. The collective open data will empower local communities in making cycling more visible and decision-makers in making cities more liveable and bike-friendly.";
    var About_titleOne$2 = "Short history: who's behind the project";
    var About_contentOne_oneBefore$2 = "The Bike Data Project was initially set up by";
    var About_contentOne_oneMiddle$2 = "and launched as part of the release of the ";
    var About_contentOne_oneAfter$2 = ", directed by Fredrik Gertten. As the documentary has been screened in over 50 countries, there has already been collected more than 275.000 bicycle rides collected.";
    var About_contentOne_twoBefore$2 = "At the beginning of 2020, the project was moved under the umbrella of Open Knowledge Belgium. ";
    var About_contentOne_twoAfter$2 = "(non-profit/vzw/asbl), as local chapter of Open Knowledge International, is an umbrella organisation for various open knowledge and open data initiatives in Belgium. We strive for a world where knowledge creates power for the many, not the few and proactively promote openness through projects and events, to the general public as well as to experts in the field. As grassroots organisation we consist of people, mainly volunteers, passionate about openness, using advocacy, research, technology and projects to unlock information, enabling people to use and share knowledge.";
    var About_contentOne_three$2 = "Open Knowledge Belgium guarantees the openness of the project for all purposes and takes all required measures according to the GDPR regulations concerning data privacy and protection. With a transparent and clear terms of use for this project, Open Knowledge Belgium wants to set an example on how to deal with privacy-related issues and wants to take the opportunity to inform citizens about their digital rights.";
    var About_titleTwo$2 = "More cycling data means more power to and for cyclists";
    var About_contentTwo_one$2 = "Little is known about how cyclists move around in cities today. If there’s data available, it’s closed and restricted data sold by one single app provider or static data collected through manual counts. If we want to have more people cycling in cities and make the bicycle as easy and logical to opt for as the car, we also need to get the same data insights into cyclists’ behavior as we have about car transport.";
    var About_contentTwo_two$2 = "Open Knowledge Belgium aims to create impact by showing where and when people actually cycle. The Bike Data Project provides the opportunity to collect all cycling data from different applications into one platform, which is - based on the principle of open source and open data - adaptable and accessible by everyone to ensure it benefits society.";
    var About_titleThree$2 = "Public digital infrastructure as common good";
    var About_contentThree_one$2 = "Similar to activities like OpenStreetMap Belgium and Open Planner Team by Open Knowledge Belgium, the Bike Data Project is set up as a collaborative project which is open to all and makes society benefit as a whole. Therefore, the digital infrastructure and aggregated data are - based on the principles of open source and open data - freely adaptable and accessible to anyone.";
    var About_contentThree_two$2 = "Furthermore, Open Knowledge Belgium strives to play with this Bike Data Project an important role in wider societal movements:";
    var About_contentThree_listOneBold$2 = "Citizens can take back control of their data";
    var About_contentThree_listOne$2 = "thanks to strong European GDPR regulations. In the case of the Bike Data Project, we want to encourage citizens to get their data out of third party apps (e.g. popular apps as Strava and even potentially Google Maps) and ask them to contribute them to a good cause.";
    var About_contentThree_listTwoBold$2 = "Promote skill sharing and encourage learning within the community";
    var About_contentThree_listTwo$2 = "throughout the whole process from project launch to further development of the platform. Strongly inspired by the work of the School of Data in Riga, we want to involve the cycling community in the local Bike Data Project campaigns as from the first day. Throughout a series of community events, Open Knowledge Belgium wants to improve data literacy.";
    var About_contentThree_listThreeBold$2 = "Think globally, act locally.";
    var About_contentThree_listThree$2 = "The Bike Data Project platform is global and open by default. Although it is possible for cycling communities all around the world to contribute to the project, Open Knowledge Belgium wants to support local communities with making them act on a local level.";
    var About_titleFour$2 = "Longer-term sustainability of the Bike Data Project";
    var About_contentFour$2 = "Open Knowledge Belgium partners up with Brussels Mobility to launch, as part of its Bike for Brussels program, a first campaign in the Brussels-Capital Region. The launch of local crowdsourcing campaigns in different cities and the setup of the open data platform are part of a longer-term plan for the Bike Data Project. When a crowdsourcing campaign in a specific city or region comes to an end, the platform will stay online and will be maintained by the open source community of Open Knowledge Belgium. Cycling communities in other cities will be encouraged to launch a campaign in their cities and make use of the platform. Given the interest of different stakeholders in the Bike Data Platform, Open Knowledge Belgium has already received confirmation from different stakeholders that they want to contribute financially to the project so that the server costs can get covered. In that way, the project will be sustained over the longer term.";
    var Faq_title$2 = "Frequently Asked Questions";
    var Question_one_title$2 = "Why should I participate in this project?";
    var Question_one_answerOne$2 = "By contributing your cycling data, you can help make our cities better adapted to cyclists.";
    var Question_one_answerTwo$2 = "More cycling data means more power to and for cyclists. Little is known about how cyclists move around in cities today. If there’s data available, it’s closed and restricted data sold by one single app provider or static data collected through manual counts. If we want to have more people cycling in cities and make the bicycle as easy and logical to opt for as the car, we also need to get the same data insights into cyclists’ behavior as we have about car transport.";
    var Question_two_title$2 = "How does this project work?";
    var Question_two_answerOne$2 = "To make this work we want to ask you to contribute your cycling data. We need to know where you ride your bicycle. Your data contributions, combined with the data from many other cyclists, will make cities more adapted to cyclists.";
    var Question_two_answerTwo$2 = "We ask different types of cyclists (e.g., daily commuters, delivery riders, sportsmen and tourists) to track their bicycle rides via their preferred mobile application and contribute their data to our community-driven bike data platform. Every kind of cyclist has something to contribute to this project. Some people already track their activity for training purposes. That’s great, but we also really want to take into account the short routes: commuting to work, dropping the kids off at school or a quick ride to the grocery store.";
    var Question_two_answerThree$2 = "In return, the anonymous aggregated cycling data will be opened up to the public and can be freely used by anyone. We aim to create impact by showing where and when people actually cycle. More data means more influence over those in power to make cities more sustainable and bike-friendly.";
    var Question_three_title$2 = "How do I contribute my data to the platform?";
    var Question_three_answer$2 = "You can simply connect your existing cycling app to the Bike Data Project platform. For now, you can either connect your Strava account or upload your Garmin files, but we're also working on the integration of other cycling apps. Once your app is connected you can just carry on as usual and your rides will be automatically uploaded to the Bike Data Project platform. If you do not use any cycling app yet, you will be able to use our own app soon. With the Bike Data Project app, you won't need to create an account, you will be able to anonymously share your data to the platform.";
    var Question_four_title$2 = "What is happening with my data?";
    var Question_four_answerOne$2 = "The data collected by this project consists of contributions made by all different kinds of cyclists. All individual cycling data are aggregated into collective data. The collective data gives us patterns we can use to demonstrate where and when cyclists ride their bicycles.";
    var Question_four_answerTwo$2 = "The anonymous aggregated cycling data will be opened up to the public as open data. The open data provided by the Bike Data Project platform can be freely used by different stakeholders and for different purposes. Here’s a non-exhaustive list of different use cases of the open data:";
    var Question_four_answerThree$2 = "Transportation experts, city planners, mobility planners and urban designers around the world need open data like this to help them develop modern infrastructure and sustainable cities.";
    var Question_four_answerFour$2 = "Citizens can get a high-level overview of the number of cyclists and kilometers cycled in the city and check out a map with the number of cyclists per route.";
    var Question_four_answerFive$2 = "Civil society and journalists use the data to analyse the situation for cyclists in the city, such as the amount of time cyclists lose on average at traffic lights.";
    var Question_four_answerSix$2 = "Data and software companies can dive into the data to obtain smart cycling insights and build tools like advanced cycling route planners and recommendation engines to improve cycling infrastructure. The data can also be very useful for other bike related products and services.";
    var Question_four_answerSeven$2 = "All aggregated cycling data will be available as open data by the end of October 2020. For now, you can contribute to the project by donating your cycling data.";
    var Question_five_title$2 = "Is my privacy respected when I contribute my data?";
    var Question_five_answerOne$2 = "Yes, Open Knowledge Belgium guarantees the openness of the project so that society benefits as a whole and takes all required measures according to the GDPR regulations concerning data privacy and protection.";
    var Question_five_answerTwo$2 = "We are collecting cycling data of many individual cyclists and aim to make the anonymous aggregated data available to the public as open data. The aggregated data will be published in a way that it's not possible to retrieve any personal information of an individual cyclist.";
    var Question_five_answerThree$2 = "The data publishing will be done based on the principle of differential privacy, which is a system for publicly sharing information about a dataset by describing the patterns of groups within the dataset while withholding information about individuals in the dataset. This basically means that data will only be published if a particular individual's information cannot be retrieved.";
    var Question_six_title$2 = "Can I delete my data?";
    var Question_six_answer$2 = "Yes! Although you contribute your data in an anonymous way (we don't ask for your name or any other information that identifies you), you can ask us to extract your data from the Bike Data Project platform.If you'd like to do so, please send us an email to bikedataproject@openknowledge.be with the name of the app you've used to contribute your data and, if possible, also the ID number associated with your account in the app.";
    var Question_seven_title$2 = "What data am I sharing from my app?";
    var Question_seven_answer$2 = "We mainly want to ask you to contribute the data regarding your cycling activities, more specifically where and when you cycle. Besides that, there's the possibility to share information on your gender, age, type of bicycles and the reason of your bicycle ride(leisure, sports, commute, ...).";
    var Question_eight_title$2 = "How do I get access to the open data?";
    var Question_eight_answerOne$2 = "The anonymous aggregated cycling data will be opened up to the public as open data. The open data provided by the Bike Data Project platform can be freely used by different stakeholders and for different purposes.";
    var Question_eight_answerTwo$2 = "All aggregated cycling data will be available as open data by the end of October 2020. For now, you can contribute to the project by donating your cycling data.";
    var Question_nine_title$2 = "I'd love to be more involved in this project - how can I help?";
    var Question_nine_answer$2 = "That's awesome! Feel free to join our Slack group (https://join.slack.com/t/bikedataproject/shared_invite/zt-hr00amgw-elYn9WbdFHLta8qQKW_wvQ) and introduce yourself there. We'd love to hear how you'd like to contribute to the project!";
    var Contact_title$2 = "Contact";
    var Further_questions$2 = "For any further questions or information, please contact us via:";
    var Follow_socials$2 = "Follow our project via our social media channels:";
    var Cookies_title$2 = "Cookie Policy";
    var What_are_cookies$2 = "1. What are cookies";
    var Cookies_section_one$2 = "Cookies are tiny files that are downloaded to your computer, to improve your experience. This page describes what information they gather, how we use it and why we sometimes need to store these cookies. We will also share how you can prevent these cookies from being stored. However, this may downgrade or \"break\" certain elements of the site functionality. For more general information on cookies";
    var Cookies_section_oneLink$2 = "see this Wikipedia article on HTTP Cookies.";
    var How_we_use_cookies$2 = "2. How we use cookies";
    var Cookies_section_two$2 = "We use cookies for a variety of reasons detailed below. Unfortunately, in most cases there are no industry standard options for disabling cookies without completely disabling the functionality and features they add to this site. It is recommended that you leave all cookies if you are not sure whether you need them or not in case they are used to provide a service that you use.";
    var Disabling_cookies$2 = "3. Disabling cookies";
    var Cookies_section_three$2 = "You can prevent cookies being downloaded by adjusting your browser settings (see the Help menu of your browser to find out how to do this). Please be aware that disabling cookies might affect the functionality of this and many other websites that you visit. Disabling cookies will usually result in disabling certain functionality and features of this site as well. If you'd like to disable cookies, we recommend using";
    var Cookies_section_threeLink$2 = "on Firefox.";
    var Cookies_we_set$2 = "4. Cookies we set";
    var Cookies_section_fourOne$2 = "Our website includes a newsletter subscription service and cookies may be used to remember if you are already registered and whether to show certain notifications which might only be valid to subscribed/unsubscribed users.";
    var Cookies_section_fourTwo$2 = "In order to provide you with a great experience on this site, we provide the functionality to set the language according to the language you use in your browser. In order to remember your preferences we need to set cookies, so that this information can be recalled whenever you interact with a page that is affected by your preferences.";
    var Third_party_cookies$2 = "5. Third party cookies";
    var Cookies_section_five$2 = "Our site doesn’t make use of cookies provided by third parties.";
    var More_information$2 = "6. More Information";
    var Cookies_section_six$2 = "As previously mentioned, if there is anything that you aren't sure you need or not, it's usually safer to leave cookies enabled - just in case it does interact with one of the features you use on our site. If you are still looking for more information, you can contact us at ";
    var Privacy_title$2 = "Privacy Policy";
    var Privacy_introOne$2 = "Responsible for the processing of the Data and Owner";
    var Privacy_introTwo$2 = "Bike Data Project with Open Knowledge Belgium as legal entity, a not-for-profit organization, incorporated and existing under the laws of Belgium, with registered office at 12 Cantersteen 1000 Brussels, Belgium, with company number 0845.419.930.";
    var Privacy_policy_section$2 = "1. Privacy Policy";
    var Privacy_section_one$2 = "This ‘Privacy Policy’ applies to the ‘Personal Data’ collected by Bike Data Project through this website.";
    var What_does_personal$2 = "2. What does personal data mean?";
    var Privacy_section_two$2 = "In this Privacy Policy, Personal Data refers to information that makes it possible to identify you. An identifiable person is someone who can be identified, either directly or indirectly, in particular by referring to an identification number or to one or more factors that are linked to physical, physiological, mental, economic, cultural or social identity. A typical example of personal information is your name and email address.";
    var What_personal_data$2 = "3. What personal data do we collect?";
    var Privacy_section_three$2 = "We might collect your Personal Data from the following sources:";
    var Privacy_section_threeOne$2 = "3.1 Personal Data that you provide during the data contribution process on the platform.";
    var Privacy_section_threeOne_pointOne$2 = "Data about your public profile in your preferred cycling app (mandatory)";
    var Privacy_section_threeOne_pointTwo$2 = "Data about your private cycling activitiesin your preferred cycling app (mandatory)";
    var Privacy_section_threeOne_pointThree$2 = "Your consent to these terms";
    var Privacy_section_threeTwo$2 = "3.2 Personal Data that we collect when you visit our website.";
    var Privacy_section_threeTwo_content$2 = "We use cookies to automatically collect personal data about you when you use this website. For more information, please consult our Cookie Policy.";
    var Privacy_section_threeThree$2 = "3.3. Personal Data that you provide when sharing your bike data";
    var Privacy_section_threeThree_pointOne$2 = "Your cycling rides (mandatory)";
    var Privacy_section_threeThree_pointTwo$2 = "Your age range (optional)";
    var Privacy_section_threeThree_pointThree$2 = "Your gender (optional)";
    var Privacy_section_threeThree_pointFour$2 = "Your cycling trip purpose (optional)";
    var Privacy_section_threeThree_pointFive$2 = "Your type of bicycle (optional)";
    var How_use_personal_data$2 = "4. How do we use personal data?";
    var Privacy_section_fourOne$2 = "We are collecting cycling data of many individual cyclists and aim to make the anonymous aggregated data available to the public as open data. The aggregated data will be published in a way that it's not possible to retrieve any personal information of an individual cyclist.";
    var Privacy_section_fourTwo$2 = "The data publishing will be done based on the principle of differential privacy, which is a system for publicly sharing information about a dataset by describing the patterns of groups within the dataset while withholding information about individuals in the dataset. This basically means that data will only be published if a particular individual's information cannot be retrieved.In case it's not possible the respect the disclosure of a particular individual's information, the data won't be published.";
    var Privacy_section_fourThree$2 = "The personal data is only stored and processed for the period required for the purpose of the processing. After that, the data will be deleted or anonymized. Bike Data Project relies on DigitalOcean which is certified under major privacy and security standards. DigitalOcean services are GDPR compliant.";
    var With_whom_do$2 = "5. With whom do we share your personal data?";
    var Privacy_section_five$2 = "Your personal data will not be shared with any third party. We will never sell or rent your personal data to other service providers, nor will we share your Personal Data with any service providers who are not compliant with the GDPR.";
    var Where_do_we_transfer$2 = "6. Where do we transfer your personal data to?";
    var Privacy_section_six$2 = "We only transfer your Personal Data to service providers established outside the European Economic Area if they comply to art 44 GDPR. All US-based service providers comply with Privacy Shield.";
    var Automated_decision$2 = "7. Automated decision-making and profiling ";
    var Privacy_section_seven$2 = "The processing of your personal data does not include profiling and will not  be subjected to automated decision-making for the Bike Data Project.";
    var What_rights_do$2 = "8. What rights do you have? ";
    var Privacy_section_eight$2 = "You have the right to view your personal data at any time, as well as the right to be informed of the use that Bike Data Project makes of your personal data.";
    var Privacy_section_eightOne$2 = "1. Right to rectification, removal and restriction of processing";
    var Privacy_section_eightOne_content$2 = "You are free to decide whether or not to provide your personal data to Bike Data Project. In addition, you always have the right to amend, supplement or remove your personal data at Bike Data Project. You acknowledge that a refusal to provide or a request for the removal of personal data means that certain services can no longer be delivered. You may also request the limitation of the processing of your personal data.";
    var Privacy_section_eightTwo$2 = "2. Right to object";
    var Privacy_section_eightTwo_content$2 = "You have the right to object to the processing of your personal data, as long as this is for serious and legitimate reasons.";
    var Privacy_section_eightThree$2 = "3. Right to data portability";
    var Privacy_section_eightThree_content$2 = "You have the right to obtain the personal data you have provided to Bike Data Project in a structured, typical and machine-readable form and/or transfer it to different controllers.";
    var Privacy_section_eightFour$2 = "4. Right to withdraw consent";
    var Privacy_section_eightFour_content$2 = "Insofar as the processing is based on your prior consent, you have the right to withdraw this approval.";
    var Privacy_section_eightFive$2 = "5. Right to lodge a complaint";
    var Privacy_section_eightFive_content$2 = "You have the right to lodge a complaint to the Belgian Privacy Commission:  Personal Privacy Protection Commission, Drukpersstraat 35,1000 Brussels,  Belgium, Tel +32 (0)2 274 48 00, Fax +32 (0)2 274 48 35, email:  commission@privacycommission.be. This does not affect relief before a civil  court.";
    var Exercising_your_rights$2 = "9. Exercising your rights";
    var Privacy_section_nine$2 = "You can exercise your rights by contacting Bike Data Project to this end by sending an email to support bikedataproject@openknowledge.be, provided you enclose a copy of your identity card";
    var Additional_info$2 = "Additional information on data collection and processing";
    var Legal_procedures$2 = "Legal procedures";
    var Legal_procedures_contentOne$2 = "The Processor and the Controller for the processing of the Data might use the Personal Data of the User for legal purposes, for the court or legal proceedings in the event of unlawful use of this Application or the related services.";
    var Legal_procedures_contentTwo$2 = "The User is aware that the Processor and the Data Controller might be obliged to disclose the personal data at the request of competent government institutions for the processing of the Data.";
    var Security_measures$2 = "Security measures";
    var Security_measures_contentOne$2 = "Bike Data Project has developed security measures which have been adjusted at the technological and organisational level to prevent the destruction, loss, falsification, changing, prohibited access or the erroneous disclosure to third parties of personal data as well as any other prohibited processing of this data.";
    var Security_measures_contentTwo$2 = "Under no circumstances can Bike Data Project be held liable for any direct or indirect loss resulting from the incorrect or unlawful use of your personal data by a third party.";
    var Security_measures_contentThree$2 = "You must at all times comply with the security instructions, which includes preventing all prohibited access to your login details including your password. You are solely responsible for the usage of the website on your computer, from your IP-address and with your identification details, as well as for keeping these confidential.";
    var Definitions_legal_framework$2 = "Definitions and legal framework";
    var Personal_data$2 = "Personal data (or Data)";
    var Personal_data_content$2 = "All information regarding a natural person, a legal person, an institution or an association that has been or might be identified directly or indirectly by reference to other information.";
    var Usage_data$2 = "Usage data";
    var Usage_data_content$2 = "Information that is automatically collected from this Application (or external services used in this Application), including: the IP addresses or domain names of the computers used by the Users of this Application, the URI (Uniform Resource Identifier) ​​addresses, the time of the request, the method used to submit the request to the server, the size of the file received in response to it, the numerical code indicating the status of the server response (successful, error, etc.), the functions of the browser and the operating system of the User, the different time data per visit (such as the time spent on each page of the application) and the data collected while using the application (example : the order of pages visited or other parameters about the operating system of the device).";
    var User$2 = "User";
    var User_content$2 = "The person using this Application and who must agree with or be authorized by the Data Subject to whom the Personal Data refer.";
    var Person_concerned$2 = "The person concerned";
    var Person_concerned_content$2 = "The legal person or natural person to whom the Personal Data relate.";
    var Data_processor$2 = "Data processor (or Data supervisor)";
    var Data_processor_content$2 = "The natural person, legal entity, government administration or any other institution, association or organization that has been authorized by the Data Controller to process the Personal Data in accordance with this privacy policy.";
    var Responsible_processing$2 = "Responsible for the processing of the data (or Owner)";
    var Responsible_processing_content$2 = "The natural person, legal person, government administration or any other institution, association or organization with the right, also jointly with the Controller for the processing of the Data to make decisions regarding the purposes and methods of processing Personal Data and the means used, including security measures regarding the exploitation and use of this Application. The Controller for the processing of the Data is the Owner of this Application, unless otherwise indicated.";
    var This_application$2 = "This application";
    var This_application_content$2 = "The hardware or software tools through which the Personal Data of the User are collected.";
    var Cookie$2 = "Cookie";
    var Cookie_content$2 = "Small chunk of data stored on the User's device. See our Cookie policy.";
    var Legal_information$2 = "Legal information";
    var Legal_information_content$2 = "Notice to European Users: this privacy statement has been drawn up with due observance of the obligations in art. 10 of the European Directive 95/46 / EC and the provisions of European Directive 2002/58 / EC, as well as the revision in Directive 2009/136 / EC regarding cookies.";
    var Changes_privacy_policy$2 = "Changes to this privacy policy";
    var Changes_privacy_policy_date$2 = "Last updated: 28 September 2020";
    var Changes_privacy_policy_content$2 = "The Controller for the processing of the Data reserves the right to change this privacy policy at any time by notifying Users on this page. We encourage you to check this page for possible changes. The date of the last change is indicated at the bottom of the page. If a User objects to any change in the policy, the User must not continue to use this Application. One might request the Controller for the processing of the Data to delete the Personal Data. Unless otherwise indicated, the valid Privacy Policy applicable at that time applies to all Personal Data that the Controller has stored for the processing of the Data about Users.";
    var Terms_title$2 = "Terms of Use";
    var Terms_introOne$2 = "With the Bike Data Project, Open Knowledge Belgium – the umbrella organisation for open knowledge and open data initiatives in Belgium –  provides a community-driven open bike data platform that collects data on where and when people actually cycle.";
    var Terms_introTwo$2 = "The platform aims at aggregating data from cyclists, coming from different mobile applications and sources, into one open bike data platform in order to empower local communities in making cycling more visible and decision-makers in making cities more liveable and bike-friendly.";
    var Terms_introThree$2 = "The participation in this project and use of this platform is subject to a number of rules. Below you can find the general conditions of our project , as we are convinced that clear rules provide the best guarantee for a respectful community.";
    var Terms_introFour$2 = "Because Open Knowledge Belgium appreciates the feedback of the Bike Data Project community, we welcome any ideas to further improve the platform. You can email your suggestions to support";
    var Who_can_contribute$2 = "Who can contribute to the Bike Data Project and who can make use of the open data provided by the Bike Data Project?";
    var Who_can_contribute_contentOne$2 = "Any kind of cyclist can contribute to the project by sharing cycling data. You can either link your preferred cycling app to share your data or use the Bike Data Project app in order to contribute to the Bike Data Project. For using the app of the Bike Data Project, you don’t need to create an account to use the app, so you and your collected cycling data will stay anonymous.";
    var Who_can_contribute_contentTwo$2 = "The anonymous aggregated cycling data will be opened up to the public as open data. The open data provided by the Bike Data Project platform is published under a Creative Commons Attribution 4.0 International Licens, which imposes no restrictions on your use of the open data. You are only required to give appropriate credit to the Bike Data Project by providing the name of the project, copyright notice, license notice, disclaimer notice and a link to the platform.";
    var Limitation_of_liability$2 = "Limitation of Liability";
    var Limitation_of_liability_contentOne$2 = "The project cannot be held responsible for any failure or delay in performing the conditions . The platform cannot be held responsible for any liability in case of personal damage from using it. You shall defend, indemnify and hold harmless the Bike Data Project (and each of its partners and/or volunteers) from any claim, demand, action, damage, loss, cost or expense, including without limitation reasonable attorneys’ fees, arising out or relating to (a) your use of our project; (b) any member content or submissions you provide; (c) your violation of these terms; (d) your violation of any rights of another; or (e) your conduct in connection with the services. Further, if you are using the project on behalf of any entity, you represent and warrant that such entity agrees to indemnify you and the Bike Data Project for violations of these terms in accordance with this section. If you are obligated to indemnify us, we will have the right, in our sole and unfettered discretion, to control any action or proceeding and determine whether we wish to settle it, and if so, on what terms.";
    var Limitation_of_liability_contentTwo$2 = "We firmly believe in freedom of speech. However, in order to ensure that the platform can be used in a constructive way by the users, with respect for different opinions and without people having to be afraid to participate in the project, we do not allow offensive behaviour that harasses, intimidates or uses fear to silence another user.";
    var Spam$2 = "Spam";
    var Spam_contentOne$2 = "We strive at all times to protect the Bike Data Project platform user from technical abuse and spam. Accounts that are used to perform the actions listed below can be temporarily blocked or permanently deleted.";
    var Spam_contentTwo$2 = "Malware / phishing / viruses / worms / Trojans: You may not post malicious content or links to such content for the purpose of damaging or disrupting someone else's browsers or computers, or of violating someone's privacy. Spam: You are not allowed to use the Bike Data Project platform to spam people.";
    var Infringement$2 = "Infringement of applicable laws";
    var Infringement_contentOne$2 = "The use of the account may not in any way infringe applicable laws. This includes infringements against privacy legislation, intellectual property rights, the criminal code, etc. The account may not be used to promote illegal activities in any way.";
    var Infringement_contentTwo$2 = "The account may not be used to promote illegal activities in any way.";
    var Breaches_aforementioned_rules$2 = "In case of breaches of the aforementioned rules";
    var Breaches_aforementioned_rules_content$2 = "It may occur that harmful files can be downloaded via the platform, whether or not due to a user, or that users place harmful hyperlinks. Every download by a user or click on a hyperlink, placed by a user, is done at the user’s own risk. Any damage incurred is completely and solely the responsibility of this user.";
    var Property_rights$2 = "Property rights Bike Data Project";
    var Property_rights_content$2 = "The source code of Bike Data Project is published under an open source MIT license. You agree to be bound by and comply with any license agreement that applies to this open source software. The visual identity, including the logo and colors, is available under CC BY 4.0. The name of the Bike Data Project cannot be used nor replicated.";
    var Thanks_Bigletter$2 = "Thank You";
    var Thanks_Fitbit_title$2 = "Thank you for linking you Fitbit account!";
    var Thanks_Content1$2 = "Your Fibit account is now linked to the Bike Data Project.";
    var Thanks_Content2$2 = "Your contributions will show up automatically from now on when you log bicycle rides via FitBit.";
    var en = {
    	Contribute: Contribute$2,
    	The_data: The_data$2,
    	About: About$2,
    	FAQ: FAQ$2,
    	Contact: Contact$2,
    	Heading: Heading$2,
    	Introduction: Introduction$2,
    	Label_total_km: Label_total_km$2,
    	Help_title: Help_title$2,
    	Ask_for_favor: Ask_for_favor$2,
    	By_sharing_your: By_sharing_your$2,
    	Every_cyclist_can: Every_cyclist_can$2,
    	Donate_title: Donate_title$2,
    	Several_ways_to_contribute: Several_ways_to_contribute$2,
    	You_not_using: You_not_using$2,
    	Connect_existing_account: Connect_existing_account$2,
    	Download_our_app: Download_our_app$2,
    	Data_title: Data_title$2,
    	Rides_collected: Rides_collected$2,
    	Distance_collected: Distance_collected$2,
    	Average_duration: Average_duration$2,
    	Average_speed: Average_speed$2,
    	Average_distance: Average_distance$2,
    	co2_saved: co2_saved$2,
    	Data_subtitle: Data_subtitle$2,
    	Data_button: Data_button$2,
    	Contribute_title: Contribute_title$2,
    	People_who_work: People_who_work$2,
    	Common_goal: Common_goal$2,
    	Visible_title: Visible_title$2,
    	Community_more_visible: Community_more_visible$2,
    	Globally_but_locally: Globally_but_locally$2,
    	Informed_title: Informed_title$2,
    	Email_label: Email_label$2,
    	Informed_placeholder: Informed_placeholder$2,
    	Partners_title: Partners_title$2,
    	Footer_intro: Footer_intro$2,
    	Footer_nav_title: Footer_nav_title$2,
    	Footer_contact: Footer_contact$2,
    	Footer_street: Footer_street$2,
    	Footer_city: Footer_city$2,
    	Footer_copyright_one: Footer_copyright_one$2,
    	Footer_copyright_two: Footer_copyright_two$2,
    	Terms_of_use: Terms_of_use$2,
    	Privacy_policy: Privacy_policy$2,
    	Cookie_policy: Cookie_policy$2,
    	Help: Help$2,
    	Contribute_big: Contribute_big$2,
    	Data: Data$2,
    	Power: Power$2,
    	Partners: Partners$2,
    	About_us: About_us$2,
    	Faq: Faq$2,
    	Contact_us: Contact_us$2,
    	Cookies: Cookies$2,
    	Privacy: Privacy$2,
    	Terms: Terms$2,
    	Map_title: Map_title$2,
    	Data_content_one: Data_content_one$2,
    	Data_content_two: Data_content_two$2,
    	Data_content_three: Data_content_three$2,
    	Data_content_listOne: Data_content_listOne$2,
    	Data_content_listTwo: Data_content_listTwo$2,
    	Data_content_listThree: Data_content_listThree$2,
    	Data_content_listFour: Data_content_listFour$2,
    	Data_content_four: Data_content_four$2,
    	Map_subtitle: Map_subtitle$2,
    	About_title: About_title$2,
    	About_intro: About_intro$2,
    	About_titleOne: About_titleOne$2,
    	About_contentOne_oneBefore: About_contentOne_oneBefore$2,
    	About_contentOne_oneMiddle: About_contentOne_oneMiddle$2,
    	About_contentOne_oneAfter: About_contentOne_oneAfter$2,
    	About_contentOne_twoBefore: About_contentOne_twoBefore$2,
    	About_contentOne_twoAfter: About_contentOne_twoAfter$2,
    	About_contentOne_three: About_contentOne_three$2,
    	About_titleTwo: About_titleTwo$2,
    	About_contentTwo_one: About_contentTwo_one$2,
    	About_contentTwo_two: About_contentTwo_two$2,
    	About_titleThree: About_titleThree$2,
    	About_contentThree_one: About_contentThree_one$2,
    	About_contentThree_two: About_contentThree_two$2,
    	About_contentThree_listOneBold: About_contentThree_listOneBold$2,
    	About_contentThree_listOne: About_contentThree_listOne$2,
    	About_contentThree_listTwoBold: About_contentThree_listTwoBold$2,
    	About_contentThree_listTwo: About_contentThree_listTwo$2,
    	About_contentThree_listThreeBold: About_contentThree_listThreeBold$2,
    	About_contentThree_listThree: About_contentThree_listThree$2,
    	About_titleFour: About_titleFour$2,
    	About_contentFour: About_contentFour$2,
    	Faq_title: Faq_title$2,
    	Question_one_title: Question_one_title$2,
    	Question_one_answerOne: Question_one_answerOne$2,
    	Question_one_answerTwo: Question_one_answerTwo$2,
    	Question_two_title: Question_two_title$2,
    	Question_two_answerOne: Question_two_answerOne$2,
    	Question_two_answerTwo: Question_two_answerTwo$2,
    	Question_two_answerThree: Question_two_answerThree$2,
    	Question_three_title: Question_three_title$2,
    	Question_three_answer: Question_three_answer$2,
    	Question_four_title: Question_four_title$2,
    	Question_four_answerOne: Question_four_answerOne$2,
    	Question_four_answerTwo: Question_four_answerTwo$2,
    	Question_four_answerThree: Question_four_answerThree$2,
    	Question_four_answerFour: Question_four_answerFour$2,
    	Question_four_answerFive: Question_four_answerFive$2,
    	Question_four_answerSix: Question_four_answerSix$2,
    	Question_four_answerSeven: Question_four_answerSeven$2,
    	Question_five_title: Question_five_title$2,
    	Question_five_answerOne: Question_five_answerOne$2,
    	Question_five_answerTwo: Question_five_answerTwo$2,
    	Question_five_answerThree: Question_five_answerThree$2,
    	Question_six_title: Question_six_title$2,
    	Question_six_answer: Question_six_answer$2,
    	Question_seven_title: Question_seven_title$2,
    	Question_seven_answer: Question_seven_answer$2,
    	Question_eight_title: Question_eight_title$2,
    	Question_eight_answerOne: Question_eight_answerOne$2,
    	Question_eight_answerTwo: Question_eight_answerTwo$2,
    	Question_nine_title: Question_nine_title$2,
    	Question_nine_answer: Question_nine_answer$2,
    	Contact_title: Contact_title$2,
    	Further_questions: Further_questions$2,
    	Follow_socials: Follow_socials$2,
    	Cookies_title: Cookies_title$2,
    	What_are_cookies: What_are_cookies$2,
    	Cookies_section_one: Cookies_section_one$2,
    	Cookies_section_oneLink: Cookies_section_oneLink$2,
    	How_we_use_cookies: How_we_use_cookies$2,
    	Cookies_section_two: Cookies_section_two$2,
    	Disabling_cookies: Disabling_cookies$2,
    	Cookies_section_three: Cookies_section_three$2,
    	Cookies_section_threeLink: Cookies_section_threeLink$2,
    	Cookies_we_set: Cookies_we_set$2,
    	Cookies_section_fourOne: Cookies_section_fourOne$2,
    	Cookies_section_fourTwo: Cookies_section_fourTwo$2,
    	Third_party_cookies: Third_party_cookies$2,
    	Cookies_section_five: Cookies_section_five$2,
    	More_information: More_information$2,
    	Cookies_section_six: Cookies_section_six$2,
    	Privacy_title: Privacy_title$2,
    	Privacy_introOne: Privacy_introOne$2,
    	Privacy_introTwo: Privacy_introTwo$2,
    	Privacy_policy_section: Privacy_policy_section$2,
    	Privacy_section_one: Privacy_section_one$2,
    	What_does_personal: What_does_personal$2,
    	Privacy_section_two: Privacy_section_two$2,
    	What_personal_data: What_personal_data$2,
    	Privacy_section_three: Privacy_section_three$2,
    	Privacy_section_threeOne: Privacy_section_threeOne$2,
    	Privacy_section_threeOne_pointOne: Privacy_section_threeOne_pointOne$2,
    	Privacy_section_threeOne_pointTwo: Privacy_section_threeOne_pointTwo$2,
    	Privacy_section_threeOne_pointThree: Privacy_section_threeOne_pointThree$2,
    	Privacy_section_threeTwo: Privacy_section_threeTwo$2,
    	Privacy_section_threeTwo_content: Privacy_section_threeTwo_content$2,
    	Privacy_section_threeThree: Privacy_section_threeThree$2,
    	Privacy_section_threeThree_pointOne: Privacy_section_threeThree_pointOne$2,
    	Privacy_section_threeThree_pointTwo: Privacy_section_threeThree_pointTwo$2,
    	Privacy_section_threeThree_pointThree: Privacy_section_threeThree_pointThree$2,
    	Privacy_section_threeThree_pointFour: Privacy_section_threeThree_pointFour$2,
    	Privacy_section_threeThree_pointFive: Privacy_section_threeThree_pointFive$2,
    	How_use_personal_data: How_use_personal_data$2,
    	Privacy_section_fourOne: Privacy_section_fourOne$2,
    	Privacy_section_fourTwo: Privacy_section_fourTwo$2,
    	Privacy_section_fourThree: Privacy_section_fourThree$2,
    	With_whom_do: With_whom_do$2,
    	Privacy_section_five: Privacy_section_five$2,
    	Where_do_we_transfer: Where_do_we_transfer$2,
    	Privacy_section_six: Privacy_section_six$2,
    	Automated_decision: Automated_decision$2,
    	Privacy_section_seven: Privacy_section_seven$2,
    	What_rights_do: What_rights_do$2,
    	Privacy_section_eight: Privacy_section_eight$2,
    	Privacy_section_eightOne: Privacy_section_eightOne$2,
    	Privacy_section_eightOne_content: Privacy_section_eightOne_content$2,
    	Privacy_section_eightTwo: Privacy_section_eightTwo$2,
    	Privacy_section_eightTwo_content: Privacy_section_eightTwo_content$2,
    	Privacy_section_eightThree: Privacy_section_eightThree$2,
    	Privacy_section_eightThree_content: Privacy_section_eightThree_content$2,
    	Privacy_section_eightFour: Privacy_section_eightFour$2,
    	Privacy_section_eightFour_content: Privacy_section_eightFour_content$2,
    	Privacy_section_eightFive: Privacy_section_eightFive$2,
    	Privacy_section_eightFive_content: Privacy_section_eightFive_content$2,
    	Exercising_your_rights: Exercising_your_rights$2,
    	Privacy_section_nine: Privacy_section_nine$2,
    	Additional_info: Additional_info$2,
    	Legal_procedures: Legal_procedures$2,
    	Legal_procedures_contentOne: Legal_procedures_contentOne$2,
    	Legal_procedures_contentTwo: Legal_procedures_contentTwo$2,
    	Security_measures: Security_measures$2,
    	Security_measures_contentOne: Security_measures_contentOne$2,
    	Security_measures_contentTwo: Security_measures_contentTwo$2,
    	Security_measures_contentThree: Security_measures_contentThree$2,
    	Definitions_legal_framework: Definitions_legal_framework$2,
    	Personal_data: Personal_data$2,
    	Personal_data_content: Personal_data_content$2,
    	Usage_data: Usage_data$2,
    	Usage_data_content: Usage_data_content$2,
    	User: User$2,
    	User_content: User_content$2,
    	Person_concerned: Person_concerned$2,
    	Person_concerned_content: Person_concerned_content$2,
    	Data_processor: Data_processor$2,
    	Data_processor_content: Data_processor_content$2,
    	Responsible_processing: Responsible_processing$2,
    	Responsible_processing_content: Responsible_processing_content$2,
    	This_application: This_application$2,
    	This_application_content: This_application_content$2,
    	Cookie: Cookie$2,
    	Cookie_content: Cookie_content$2,
    	Legal_information: Legal_information$2,
    	Legal_information_content: Legal_information_content$2,
    	Changes_privacy_policy: Changes_privacy_policy$2,
    	Changes_privacy_policy_date: Changes_privacy_policy_date$2,
    	Changes_privacy_policy_content: Changes_privacy_policy_content$2,
    	Terms_title: Terms_title$2,
    	Terms_introOne: Terms_introOne$2,
    	Terms_introTwo: Terms_introTwo$2,
    	Terms_introThree: Terms_introThree$2,
    	Terms_introFour: Terms_introFour$2,
    	Who_can_contribute: Who_can_contribute$2,
    	Who_can_contribute_contentOne: Who_can_contribute_contentOne$2,
    	Who_can_contribute_contentTwo: Who_can_contribute_contentTwo$2,
    	Limitation_of_liability: Limitation_of_liability$2,
    	Limitation_of_liability_contentOne: Limitation_of_liability_contentOne$2,
    	Limitation_of_liability_contentTwo: Limitation_of_liability_contentTwo$2,
    	Spam: Spam$2,
    	Spam_contentOne: Spam_contentOne$2,
    	Spam_contentTwo: Spam_contentTwo$2,
    	Infringement: Infringement$2,
    	Infringement_contentOne: Infringement_contentOne$2,
    	Infringement_contentTwo: Infringement_contentTwo$2,
    	Breaches_aforementioned_rules: Breaches_aforementioned_rules$2,
    	Breaches_aforementioned_rules_content: Breaches_aforementioned_rules_content$2,
    	Property_rights: Property_rights$2,
    	Property_rights_content: Property_rights_content$2,
    	Thanks_Bigletter: Thanks_Bigletter$2,
    	Thanks_Fitbit_title: Thanks_Fitbit_title$2,
    	Thanks_Content1: Thanks_Content1$2,
    	Thanks_Content2: Thanks_Content2$2
    };

    var en$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Contribute: Contribute$2,
        The_data: The_data$2,
        About: About$2,
        FAQ: FAQ$2,
        Contact: Contact$2,
        Heading: Heading$2,
        Introduction: Introduction$2,
        Label_total_km: Label_total_km$2,
        Help_title: Help_title$2,
        Ask_for_favor: Ask_for_favor$2,
        By_sharing_your: By_sharing_your$2,
        Every_cyclist_can: Every_cyclist_can$2,
        Donate_title: Donate_title$2,
        Several_ways_to_contribute: Several_ways_to_contribute$2,
        You_not_using: You_not_using$2,
        Connect_existing_account: Connect_existing_account$2,
        Download_our_app: Download_our_app$2,
        Data_title: Data_title$2,
        Rides_collected: Rides_collected$2,
        Distance_collected: Distance_collected$2,
        Average_duration: Average_duration$2,
        Average_speed: Average_speed$2,
        Average_distance: Average_distance$2,
        co2_saved: co2_saved$2,
        Data_subtitle: Data_subtitle$2,
        Data_button: Data_button$2,
        Contribute_title: Contribute_title$2,
        People_who_work: People_who_work$2,
        Common_goal: Common_goal$2,
        Visible_title: Visible_title$2,
        Community_more_visible: Community_more_visible$2,
        Globally_but_locally: Globally_but_locally$2,
        Informed_title: Informed_title$2,
        Email_label: Email_label$2,
        Informed_placeholder: Informed_placeholder$2,
        Partners_title: Partners_title$2,
        Footer_intro: Footer_intro$2,
        Footer_nav_title: Footer_nav_title$2,
        Footer_contact: Footer_contact$2,
        Footer_street: Footer_street$2,
        Footer_city: Footer_city$2,
        Footer_copyright_one: Footer_copyright_one$2,
        Footer_copyright_two: Footer_copyright_two$2,
        Terms_of_use: Terms_of_use$2,
        Privacy_policy: Privacy_policy$2,
        Cookie_policy: Cookie_policy$2,
        Help: Help$2,
        Contribute_big: Contribute_big$2,
        Data: Data$2,
        Power: Power$2,
        Partners: Partners$2,
        About_us: About_us$2,
        Faq: Faq$2,
        Contact_us: Contact_us$2,
        Cookies: Cookies$2,
        Privacy: Privacy$2,
        Terms: Terms$2,
        Map_title: Map_title$2,
        Data_content_one: Data_content_one$2,
        Data_content_two: Data_content_two$2,
        Data_content_three: Data_content_three$2,
        Data_content_listOne: Data_content_listOne$2,
        Data_content_listTwo: Data_content_listTwo$2,
        Data_content_listThree: Data_content_listThree$2,
        Data_content_listFour: Data_content_listFour$2,
        Data_content_four: Data_content_four$2,
        Map_subtitle: Map_subtitle$2,
        About_title: About_title$2,
        About_intro: About_intro$2,
        About_titleOne: About_titleOne$2,
        About_contentOne_oneBefore: About_contentOne_oneBefore$2,
        About_contentOne_oneMiddle: About_contentOne_oneMiddle$2,
        About_contentOne_oneAfter: About_contentOne_oneAfter$2,
        About_contentOne_twoBefore: About_contentOne_twoBefore$2,
        About_contentOne_twoAfter: About_contentOne_twoAfter$2,
        About_contentOne_three: About_contentOne_three$2,
        About_titleTwo: About_titleTwo$2,
        About_contentTwo_one: About_contentTwo_one$2,
        About_contentTwo_two: About_contentTwo_two$2,
        About_titleThree: About_titleThree$2,
        About_contentThree_one: About_contentThree_one$2,
        About_contentThree_two: About_contentThree_two$2,
        About_contentThree_listOneBold: About_contentThree_listOneBold$2,
        About_contentThree_listOne: About_contentThree_listOne$2,
        About_contentThree_listTwoBold: About_contentThree_listTwoBold$2,
        About_contentThree_listTwo: About_contentThree_listTwo$2,
        About_contentThree_listThreeBold: About_contentThree_listThreeBold$2,
        About_contentThree_listThree: About_contentThree_listThree$2,
        About_titleFour: About_titleFour$2,
        About_contentFour: About_contentFour$2,
        Faq_title: Faq_title$2,
        Question_one_title: Question_one_title$2,
        Question_one_answerOne: Question_one_answerOne$2,
        Question_one_answerTwo: Question_one_answerTwo$2,
        Question_two_title: Question_two_title$2,
        Question_two_answerOne: Question_two_answerOne$2,
        Question_two_answerTwo: Question_two_answerTwo$2,
        Question_two_answerThree: Question_two_answerThree$2,
        Question_three_title: Question_three_title$2,
        Question_three_answer: Question_three_answer$2,
        Question_four_title: Question_four_title$2,
        Question_four_answerOne: Question_four_answerOne$2,
        Question_four_answerTwo: Question_four_answerTwo$2,
        Question_four_answerThree: Question_four_answerThree$2,
        Question_four_answerFour: Question_four_answerFour$2,
        Question_four_answerFive: Question_four_answerFive$2,
        Question_four_answerSix: Question_four_answerSix$2,
        Question_four_answerSeven: Question_four_answerSeven$2,
        Question_five_title: Question_five_title$2,
        Question_five_answerOne: Question_five_answerOne$2,
        Question_five_answerTwo: Question_five_answerTwo$2,
        Question_five_answerThree: Question_five_answerThree$2,
        Question_six_title: Question_six_title$2,
        Question_six_answer: Question_six_answer$2,
        Question_seven_title: Question_seven_title$2,
        Question_seven_answer: Question_seven_answer$2,
        Question_eight_title: Question_eight_title$2,
        Question_eight_answerOne: Question_eight_answerOne$2,
        Question_eight_answerTwo: Question_eight_answerTwo$2,
        Question_nine_title: Question_nine_title$2,
        Question_nine_answer: Question_nine_answer$2,
        Contact_title: Contact_title$2,
        Further_questions: Further_questions$2,
        Follow_socials: Follow_socials$2,
        Cookies_title: Cookies_title$2,
        What_are_cookies: What_are_cookies$2,
        Cookies_section_one: Cookies_section_one$2,
        Cookies_section_oneLink: Cookies_section_oneLink$2,
        How_we_use_cookies: How_we_use_cookies$2,
        Cookies_section_two: Cookies_section_two$2,
        Disabling_cookies: Disabling_cookies$2,
        Cookies_section_three: Cookies_section_three$2,
        Cookies_section_threeLink: Cookies_section_threeLink$2,
        Cookies_we_set: Cookies_we_set$2,
        Cookies_section_fourOne: Cookies_section_fourOne$2,
        Cookies_section_fourTwo: Cookies_section_fourTwo$2,
        Third_party_cookies: Third_party_cookies$2,
        Cookies_section_five: Cookies_section_five$2,
        More_information: More_information$2,
        Cookies_section_six: Cookies_section_six$2,
        Privacy_title: Privacy_title$2,
        Privacy_introOne: Privacy_introOne$2,
        Privacy_introTwo: Privacy_introTwo$2,
        Privacy_policy_section: Privacy_policy_section$2,
        Privacy_section_one: Privacy_section_one$2,
        What_does_personal: What_does_personal$2,
        Privacy_section_two: Privacy_section_two$2,
        What_personal_data: What_personal_data$2,
        Privacy_section_three: Privacy_section_three$2,
        Privacy_section_threeOne: Privacy_section_threeOne$2,
        Privacy_section_threeOne_pointOne: Privacy_section_threeOne_pointOne$2,
        Privacy_section_threeOne_pointTwo: Privacy_section_threeOne_pointTwo$2,
        Privacy_section_threeOne_pointThree: Privacy_section_threeOne_pointThree$2,
        Privacy_section_threeTwo: Privacy_section_threeTwo$2,
        Privacy_section_threeTwo_content: Privacy_section_threeTwo_content$2,
        Privacy_section_threeThree: Privacy_section_threeThree$2,
        Privacy_section_threeThree_pointOne: Privacy_section_threeThree_pointOne$2,
        Privacy_section_threeThree_pointTwo: Privacy_section_threeThree_pointTwo$2,
        Privacy_section_threeThree_pointThree: Privacy_section_threeThree_pointThree$2,
        Privacy_section_threeThree_pointFour: Privacy_section_threeThree_pointFour$2,
        Privacy_section_threeThree_pointFive: Privacy_section_threeThree_pointFive$2,
        How_use_personal_data: How_use_personal_data$2,
        Privacy_section_fourOne: Privacy_section_fourOne$2,
        Privacy_section_fourTwo: Privacy_section_fourTwo$2,
        Privacy_section_fourThree: Privacy_section_fourThree$2,
        With_whom_do: With_whom_do$2,
        Privacy_section_five: Privacy_section_five$2,
        Where_do_we_transfer: Where_do_we_transfer$2,
        Privacy_section_six: Privacy_section_six$2,
        Automated_decision: Automated_decision$2,
        Privacy_section_seven: Privacy_section_seven$2,
        What_rights_do: What_rights_do$2,
        Privacy_section_eight: Privacy_section_eight$2,
        Privacy_section_eightOne: Privacy_section_eightOne$2,
        Privacy_section_eightOne_content: Privacy_section_eightOne_content$2,
        Privacy_section_eightTwo: Privacy_section_eightTwo$2,
        Privacy_section_eightTwo_content: Privacy_section_eightTwo_content$2,
        Privacy_section_eightThree: Privacy_section_eightThree$2,
        Privacy_section_eightThree_content: Privacy_section_eightThree_content$2,
        Privacy_section_eightFour: Privacy_section_eightFour$2,
        Privacy_section_eightFour_content: Privacy_section_eightFour_content$2,
        Privacy_section_eightFive: Privacy_section_eightFive$2,
        Privacy_section_eightFive_content: Privacy_section_eightFive_content$2,
        Exercising_your_rights: Exercising_your_rights$2,
        Privacy_section_nine: Privacy_section_nine$2,
        Additional_info: Additional_info$2,
        Legal_procedures: Legal_procedures$2,
        Legal_procedures_contentOne: Legal_procedures_contentOne$2,
        Legal_procedures_contentTwo: Legal_procedures_contentTwo$2,
        Security_measures: Security_measures$2,
        Security_measures_contentOne: Security_measures_contentOne$2,
        Security_measures_contentTwo: Security_measures_contentTwo$2,
        Security_measures_contentThree: Security_measures_contentThree$2,
        Definitions_legal_framework: Definitions_legal_framework$2,
        Personal_data: Personal_data$2,
        Personal_data_content: Personal_data_content$2,
        Usage_data: Usage_data$2,
        Usage_data_content: Usage_data_content$2,
        User: User$2,
        User_content: User_content$2,
        Person_concerned: Person_concerned$2,
        Person_concerned_content: Person_concerned_content$2,
        Data_processor: Data_processor$2,
        Data_processor_content: Data_processor_content$2,
        Responsible_processing: Responsible_processing$2,
        Responsible_processing_content: Responsible_processing_content$2,
        This_application: This_application$2,
        This_application_content: This_application_content$2,
        Cookie: Cookie$2,
        Cookie_content: Cookie_content$2,
        Legal_information: Legal_information$2,
        Legal_information_content: Legal_information_content$2,
        Changes_privacy_policy: Changes_privacy_policy$2,
        Changes_privacy_policy_date: Changes_privacy_policy_date$2,
        Changes_privacy_policy_content: Changes_privacy_policy_content$2,
        Terms_title: Terms_title$2,
        Terms_introOne: Terms_introOne$2,
        Terms_introTwo: Terms_introTwo$2,
        Terms_introThree: Terms_introThree$2,
        Terms_introFour: Terms_introFour$2,
        Who_can_contribute: Who_can_contribute$2,
        Who_can_contribute_contentOne: Who_can_contribute_contentOne$2,
        Who_can_contribute_contentTwo: Who_can_contribute_contentTwo$2,
        Limitation_of_liability: Limitation_of_liability$2,
        Limitation_of_liability_contentOne: Limitation_of_liability_contentOne$2,
        Limitation_of_liability_contentTwo: Limitation_of_liability_contentTwo$2,
        Spam: Spam$2,
        Spam_contentOne: Spam_contentOne$2,
        Spam_contentTwo: Spam_contentTwo$2,
        Infringement: Infringement$2,
        Infringement_contentOne: Infringement_contentOne$2,
        Infringement_contentTwo: Infringement_contentTwo$2,
        Breaches_aforementioned_rules: Breaches_aforementioned_rules$2,
        Breaches_aforementioned_rules_content: Breaches_aforementioned_rules_content$2,
        Property_rights: Property_rights$2,
        Property_rights_content: Property_rights_content$2,
        Thanks_Bigletter: Thanks_Bigletter$2,
        Thanks_Fitbit_title: Thanks_Fitbit_title$2,
        Thanks_Content1: Thanks_Content1$2,
        Thanks_Content2: Thanks_Content2$2,
        'default': en
    });

    var Contribute$1 = "Participer";
    var The_data$1 = "Les données";
    var About$1 = "À propos";
    var FAQ$1 = "FAQ";
    var Contact$1 = "Contact";
    var Heading$1 = "Collecte de données par et pour les cyclistes.";
    var Introduction$1 = "Grâce aux données partagées par les citoyens et citoyennes du monde entier, le Bike Data Project vise à montrer où et quand le vélo est utilisé. Les données recueillies aideront les communautés locales et les institutions à rendre la pratique du vélo et nos villes plus sûres.";
    var Label_total_km$1 = "Nombre total de kilomètres parcourus et partagés jusqu'à présent par des citoyens et citoyennes du monde entier";
    var Help_title$1 = "Nous avons besoin de votre aide !";
    var Ask_for_favor$1 = "Pour que cela fonctionne, nous avons besoin de vos contributions de données cyclables.";
    var By_sharing_your$1 = "Nous voulons analyser où et quand vous roulez à vélo. Vos contributions de données, combinées avec celles d’autres cyclistes, aideront à créer des villes plus adaptées au vélo.";
    var Every_cyclist_can$1 = "Chaque type de cycliste a quelque chose à contribuer. Par exemple, certaines personnes enregistrent déjà leur entraînement mais ce n’est pas suffisant. Nous voulons prendre en considération les parcours plus courts : sur le chemin du travail, en allant déposer les enfants à l’école ou en allant faire vos courses. Tout fonctionne !";
    var Donate_title$1 = "Partagez vos données cyclables";
    var Several_ways_to_contribute$1 = "Il existe plusieurs façons de contribuer au Bike Data Project. Pour l'instant, vous pouvez soit connecter votre compte Strava, soit télécharger vos fichiers Garmin. Une fois votre application connectée, vous n'avez plus rien à faire : vos trajets seront automatiquement téléchargés sur la plateforme du Bike Data Project.";
    var You_not_using$1 = "Que faire si vous n'utilisez pas encore l'une des applications répertoriées? Vous pourrez bientôt télécharger et utiliser l'application du Bike Data Project. Nous travaillons aussi sur l'intégration d'autres applications de cyclisme !";
    var Connect_existing_account$1 = "Connectez votre compte";
    var Download_our_app$1 = "Télécharger notre application (disponible prochainement)";
    var Data_title$1 = "Données collectées dans le monde";
    var Rides_collected$1 = "Déplacements enregistrés";
    var Distance_collected$1 = "Distance collectée";
    var Average_duration$1 = "Durée moyenne";
    var Average_speed$1 = "Vitesse moyenne";
    var Average_distance$1 = "Distance moyenne";
    var co2_saved$1 = "CO2 sauvé";
    var Data_subtitle$1 = "Intéressé.e dans les données de votre région?";
    var Data_button$1 = "Explorez les données";
    var Contribute_title$1 = "A qui serviront ces données ?";
    var People_who_work$1 = "Les professionnel.le.s qui travaillent sur les questions de mobilité et de planification urbaine dans le monde ont besoin d’information, et donc de données, pour développer des infrastructures modernes et créer des villes durables. Certain.e.s sont déjà convaincu.e.s et d’autres restent encore à convaincre. Au plus nous aurons des données à leur fournir, au plus nous aurons un impact important.";
    var Common_goal$1 = "Ces données sont ouvertes et peuvent être utilisées pour d’autres produits ou services liés à la pratique du vélo. Le but est d'agréger les données cyclables - et donc de les anonymiser - pour les rendre disponibles en tant que données ouvertes et de faciliter la création de villes plus adaptées aux cyclistes. Pour nous et les générations à venir.";
    var Visible_title$1 = "Plus de données cyclables signifie plus de possibilités pour et par les cyclistes.";
    var Community_more_visible$1 = "Le Bike Data Project permet de rassembler des données cyclables issues de différentes applications dans une plateforme unique qui, basée sur les principes de données ouvertes et de logiciel ouvert, sont disponibles et utilisables à tou.te.s afin de s’assurer que la société entière en bénéficie.";
    var Globally_but_locally$1 = "On sait peu de chose sur la façon dont les cyclistes se déplacent dans les villes. Si des données sont disponibles, elles sont souvent fermées, restreintes et vendues par un fournisseur unique d’application mobile. Dans d’autres cas, ces données sont collectées manuellement et sont donc statiques. Si nous voulons faire en sorte que plus de personnes fassent du vélo en ville et rendre ce choix aussi logique et évident qu’a pu l’être la voiture dans le passé, nous devons récolter autant d’informations sur le comportement des cyclistes que de données actuellement collectées sur la circulation automobile.";
    var Informed_title$1 = "Restez informé.e";
    var Email_label$1 = "Email";
    var Informed_placeholder$1 = "Votre adresse email";
    var Partners_title$1 = "Partenaires du projet";
    var Footer_intro$1 = "Bike Data Project est un projet organisé par Open Knowledge Belgium";
    var Footer_nav_title$1 = "Information";
    var Footer_contact$1 = "Contact";
    var Footer_street$1 = "Cantersteen 12";
    var Footer_city$1 = "1000 Bruxelles";
    var Footer_copyright_one$1 = "Sauf indication contraire, le contenu de ce site est sous licence";
    var Footer_copyright_two$1 = "Creative Commons Attribution 4.0 International License";
    var Terms_of_use$1 = "Conditions d’utilisation";
    var Privacy_policy$1 = "Vie Privée";
    var Cookie_policy$1 = "Cookies";
    var Help$1 = "Aide";
    var Contribute_big$1 = "Contribuez";
    var Data$1 = "Data";
    var Power$1 = "Power";
    var Partners$1 = "Partenaires";
    var About_us$1 = "À propos";
    var Faq$1 = "Faq";
    var Contact_us$1 = "Contact";
    var Cookies$1 = "Cookies";
    var Privacy$1 = "Vie Privée";
    var Terms$1 = "Conditions";
    var Map_title$1 = "Les données";
    var Data_content_one$1 = "Faites défiler la page vers le bas pour explorer la carte et voir toutes les données cyclables collectées jusqu’à présent.";
    var Data_content_two$1 = "Les données collectées dans ce projet sont des contributions de différents types de cyclistes. Toutes les données individuelles sont agrégées en données collectives qui sont donc anonymisées. Ces données collectives visualisent des traits de comportements des utilisateurs et utilisatrices en montrant comment et où les cyclistes se déplacent à vélo.";
    var Data_content_three$1 = "Les données agrégées et non-personnelles seront ouvertes au public sous forme de données ouvertes. Ces données ouvertes, diffusées via The Bike Data Project, peuvent être utilisées par différents acteurs et pour différentes raisons. Voici une liste non-exhaustive du type d’utilisations possible avec ces données : ";
    var Data_content_listOne$1 = "Les expert.e.s de la mobilité, de la planification urbaine ou du design urbain ont besoin de données ouvertes pour développer des infrastructures modernes et, ainsi, créer des villes durables.";
    var Data_content_listTwo$1 = "Les citoyen.ne.s peuvent visualiser le nombre de cyclistes et le nombre de kilomètres parcourus dans leur ville en regardant la carte.";
    var Data_content_listThree$1 = "La société civile et les journalistes peuvent utiliser ces données pour analyser la situation des cyclistes dans une ville, comme par exemple le temps que les cyclistes attendent à un feu rouge.";
    var Data_content_listFour$1 = "Les entreprises actives dans les données peuvent les utiliser pour développer des outils avancés de navigations et de recommandations d’amélioration de l’infrastructure cycliste. Les données peuvent être utile pour tout service ou produit lié à l’utilisation du vélo.";
    var Data_content_four$1 = "Toutes les données agrégées et anonymisées seront publiées comme données ouvertes fin Octobre 2020. Contribuez déjà vos données cyclables au projet !";
    var Map_subtitle$1 = "Voir tout le code open source";
    var About_title$1 = "À propos du projet";
    var About_intro$1 = "Avec le Bike Data Project, Open Knowledge Belgium - l’organisation parapluie pour la connaissance ouverte et les données ouvertes en Belgique - veut construire une plateforme de données ouvertes collectées par les cyclistes et bénéficiant aux cyclistes. Le but est d’observer quand et où les cyclistes se déplacent. Ces données sont importées grâces à des applications différentes qui sont connectées à la plateforme du Bike Data Project. Ces données ouvertes collectives permettront aux communautés locales de rendre le vélo plus visible et aux pouvoirs publics de créer des villes plus cyclables et vivables.";
    var About_titleOne$1 = "Qui est derrière ce projet ?";
    var About_contentOne_oneBefore$1 = "Le Bike Data Project a initialement été initié par";
    var About_contentOne_oneMiddle$1 = "et lancé dans le cadre de la sortie du";
    var About_contentOne_oneAfter$1 = ", réalisé par Fredrik Gertten. Etant donné que ce documentaire ai été projeté dans plus de 50 pays, déjà plus de 275.000 déplacements à vélo ont été collectés.";
    var About_contentOne_twoBefore$1 = "Début 2020, le projet a été déplacé sous Open Knowledge Belgium.";
    var About_contentOne_twoAfter$1 = "(à but non lucratif / vzw / asbl), en tant que section locale d'Open Knowledge International, est une association parapluie pour diverses initiatives de connaissance ouverte et de données ouvertes en Belgique. Nous aspirons à un monde dans lequel la connaissance crée du pouvoir pour le plus grand nombre et non pour quelques personnes. Nous faison activement la promotion de l'ouverture à travers des projets et des événements, au grand public ainsi qu'aux expert.e.s du domaine. En tant qu'organisation parapluie, nous sommes constitués de personnes principalement des bénévoles et passionnées par l'ouverture, utilisant le plaidoyer, la recherche, la technologie et les projets pour débloquer des informations, permettant aux gens d'utiliser et de partager leurs connaissances.";
    var About_contentOne_three$1 = "Open Knowledge Belgium garantit l'ouverture du projet à toutes fins et prend toutes les mesures nécessaires conformément à la réglementation GDPR concernant la confidentialité et la protection des données. Avec des conditions d'utilisation transparentes et claires pour ce projet, Open Knowledge Belgium souhaite montrer l'exemple sur la manière de traiter les problèmes liés à la vie privée et souhaite profiter de l'occasion pour informer les citoyens sur leurs droits numériques.";
    var About_titleTwo$1 = "Plus de données sur le cyclisme signifie plus d’opportunités par et pour les cyclistes";
    var About_contentTwo_one$1 = "On sait peu de choses sur la façon dont les cyclistes se déplacent dans les villes aujourd'hui. S'il y a des données disponibles, il s'agit de données fermées et restreintes vendues par un seul fournisseur d'application ou de données statiques collectées via des comptages manuels. Si nous voulons avoir plus de gens à vélo dans les villes et rendre le vélo aussi simple et logique que la voiture, nous devons également obtenir les mêmes données sur le comportement des cyclistes que nous avons sur le transport en voiture.";
    var About_contentTwo_two$1 = "Open Knowledge Belgium vise à créer un impact en montrant où et quand les gens font du vélo. Le Bike Data Project offre la possibilité de collecter toutes les données cyclistes de différentes applications sur une seule plateforme, qui - basée sur le principe de l'open source et des données ouvertes - est adaptable et accessible par tous pour garantir qu’elle profite à la société dans son entièreté.";
    var About_titleThree$1 = "L'infrastructure numérique publique comme bien commun";
    var About_contentThree_one$1 = "Comme pour des activités comme OpenStreetMap Belgium et Open Planner Team d'Open Knowledge Belgium, le Bike Data Project est conçu comme un projet collaboratif ouvert à tou.t.es et qui fait bénéficier la société dans son ensemble. Par conséquent, l'infrastructure numérique et les données agrégées, étant basées sur les principes de l'open source et des données ouvertes - sont librement adaptables et accessibles à tou.t.es.";
    var About_contentThree_two$1 = "De plus, Open Knowledge Belgium souhaite jouer, avec le Bike Data Project, un rôle important dans des mouvements sociétaux plus larges :";
    var About_contentThree_listOneBold$1 = "Les citoyen.ne.s peuvent reprendre le contrôle de leurs données";
    var About_contentThree_listOne$1 = "grâce à la forte réglementation européenne GDPR. Dans le cas du Bike Data Project, nous voulons encourager les citoyen.ne.s à extraire leurs données d'applications tierces (par exemple des applications populaires comme Strava et même potentiellement Google Maps) et leur demander de les contribuer à une bonne cause.";
    var About_contentThree_listTwoBold$1 = "Promouvoir le partage des compétences et encourager l'apprentissage au sein de la communauté";
    var About_contentThree_listTwo$1 = "tout au long du processus, de la construction du projet au développement de la plateforme. Fortement inspirés par le travail de la School of Data de Riga, nous souhaitons impliquer la communauté cycliste dans les campagnes locales du Bike Data Project dès le premier jour. Tout au long d'une série d'événements, Open Knowledge Belgium souhaite améliorer la maîtrise des données.";
    var About_contentThree_listThreeBold$1 = "Penser globalement, agir localement.";
    var About_contentThree_listThree$1 = "La plateforme Bike Data Project est globale et ouverte par défaut. Bien qu'il soit possible pour les communautés cyclistes du monde entier de contribuer au projet, Open Knowledge Belgium souhaite soutenir les communautés locales en les faisant agir au niveau local.";
    var About_titleFour$1 = "Durabilité à long terme du Bike Data Project";
    var About_contentFour$1 = "Open Knowledge Belgium s'associe à Bruxelles Mobilité pour lancer, dans le cadre de son programme Bike for Brussels, une première campagne en Région de Bruxelles-Capitale. Le lancement de campagnes locales de crowdsourcing dans différentes villes et la mise en place de la plateforme de données ouvertes font partie d'un plan à plus long terme pour le Bike Data Project. Lorsqu'une campagne de crowdsourcing dans une ville ou une région spécifique prend fin, la plateforme restera en ligne et sera maintenue par la communauté open source d'Open Knowledge Belgium. Les communautés cyclistes d'autres villes seront encouragées à lancer une campagne dans leurs villes et à utiliser la plateforme. Compte tenu de l'intérêt des différentes parties prenantes pour la Bike Data Platform, Open Knowledge Belgium a déjà reçu la confirmation de différentes parties prenantes de leur souhait de contribuer financièrement au projet afin que les coûts du serveur puissent être couverts. De cette manière, le projet sera pérennisé sur le long terme.";
    var Faq_title$1 = "Questions fréquemment posées";
    var Question_one_title$1 = "Pourquoi devrais-je participer à ce projet ?";
    var Question_one_answerOne$1 = "En contribuant vos données cyclistes, vous pouvez contribuer à rendre nos villes mieux adaptées aux cyclistes.";
    var Question_one_answerTwo$1 = "Plus de données sur le cyclisme signifie plus d’opportunités par et pour les cyclistes. On sait peu de choses sur la façon dont les cyclistes se déplacent dans les villes aujourd'hui. S'il y a des données disponibles, il s'agit de données fermées et restreintes vendues par un seul fournisseur d'application, ou de données statiques collectées via des comptages manuels. Si nous voulons avoir plus de gens à vélo dans les villes et rendre le vélo aussi simple et logique que la voiture, nous devons également obtenir les mêmes données sur le comportement des cyclistes que nous avons sur le transport en voiture.";
    var Question_two_title$1 = "Comment fonctionne ce projet ?";
    var Question_two_answerOne$1 = "Pour faire ce travail, nous avons besoin que vous fournissez vos données cyclistes. Nous avons besoin de savoir où vous faites du vélo. Vos contributions de données, combinées aux données de nombreux et nombreuses autres cyclistes, rendront les villes plus adaptées aux cyclistes.";
    var Question_two_answerTwo$1 = "Nous demandons à différents types de cyclistes (par exemple, les navetteurs/navetteuses quotidiens, les livreurs/livreuses, les sportifs/sportives et les touristes) d’enregistrer leurs déplacements à vélo via leur application mobile préférée et de fournir leurs données à la plateforme du Bike Data Project. Chaque type de cycliste a quelque chose à apporter à ce projet. Certaines personnes suivent déjà leurs activités sportives. C'est super, mais nous voulons aussi vraiment prendre en compte les trajets courts: se rendre au travail, déposer les enfants à l'école ou en allant à l'épicerie du coin.";
    var Question_two_answerThree$1 = "En retour, les données cyclistes agrégées et anonymisées seront ouvertes au public et pourront être librement utilisées par n'importe qui. Nous visons à créer un impact en montrant où et quand les gens font du vélo. Plus de données signifie plus d'influence sur les personnes au pouvoir pour rendre les villes plus durables et plus adaptées aux vélos.";
    var Question_three_title$1 = "Comment puis-je contribuer mes données à la plateforme ?";
    var Question_three_answer$1 = "Vous pouvez simplement connecter une application cycliste à la plateforme du Bike Data Project. Pour l'instant, vous pouvez soit connecter votre compte Strava, soit télécharger vos fichiers Garmin, mais nous travaillons également sur l'intégration d'autres applications. Une fois votre application connectée, vous n'avez plus rien à faire et vos trajets seront automatiquement téléchargés sur la plateforme. Si vous n'utilisez pas encore d'application de cyclisme, vous pourrez bientôt utiliser notre propre application. Avec l'application Bike Data Project, vous n'aurez pas besoin de créer de compte : vous pourrez partager anonymement vos données sur la plateforme.";
    var Question_four_title$1 = "Que se passe-t-il avec mes données ?";
    var Question_four_answerOne$1 = "Les données collectées dans le cadre de ce projet sont des contributions de tous types de cyclistes. Toutes les données individuelles sont agrégées en données collectives. Les données collectives nous donnent alors des modèles que nous pouvons utiliser pour montrer où et quand les cyclistes font du vélo.";
    var Question_four_answerTwo$1 = "Les données cyclistes agrégées non-privées seront ouvertes au public en tant que données ouvertes. Les données ouvertes fournies par la plateforme Bike Data Project peuvent être librement utilisées par différentes parties prenantes et à des fins différentes. Voici une liste non exhaustive des différents cas d'utilisation des données ouvertes :";
    var Question_four_answerThree$1 = "Les expert.e.s en mobilité et les urbanistes du monde entier ont besoin de données ouvertes comme celles-ci pour les aider à développer des infrastructures modernes et des villes durables.";
    var Question_four_answerFour$1 = "Les citoyen.ne.s peuvent avoir un aperçu du nombre de cyclistes, des kilomètres parcourus dans la ville et consulter une carte avec le nombre de cyclistes par itinéraire.";
    var Question_four_answerFive$1 = "La société civile et les journalistes peuvent utiliser les données pour analyser la situation des cyclistes dans la ville, comme par exemple le temps que les cyclistes attendent en moyenne aux feux de signalisation.";
    var Question_four_answerSix$1 = "Les sociétés active dans la gestion de données et de logiciels peuvent obtenir des informations intelligentes sur le cyclisme et créer des outils tels que des planificateurs d'itinéraires cyclables avancés et des moteurs de recommandation pour améliorer l'infrastructure cyclable. Les données peuvent également être très utiles pour d'autres produits et services liés au vélo.";
    var Question_four_answerSeven$1 = "Toutes les données cyclables agrégées seront disponibles sous forme de données ouvertes d'ici la fin octobre 2020. Pour l'instant, vous pouvez contribuer au projet en faisant don de vos données cyclistes.";
    var Question_five_title$1 = "Ma vie privée est-elle respectée lorsque je communique mes données ?";
    var Question_five_answerOne$1 = "Oui, Open Knowledge Belgium garantit l'ouverture du projet afin que la société en profite dans son ensemble et prend toutes les mesures nécessaires conformément à la réglementation GDPR concernant la confidentialité et la protection des données.";
    var Question_five_answerTwo$1 = "Nous collectons des données de nombreux cyclistes individuels et visons à rendre les données agrégées non privées disponibles au public sous forme de données ouvertes. Les données agrégées seront publiées de manière à ce qu'il ne soit pas possible de récupérer les informations personnelles d'une personne.";
    var Question_five_answerThree$1 = "La publication des données se fera sur la base du principe de confidentialité différentielle, qui est un système de partage public d'informations sur un ensemble de données en décrivant les modèles de groupes au sein de l'ensemble de données tout en retenant des informations sur les individus de l'ensemble de données. Cela signifie essentiellement que les données ne seront publiées que si les informations d'une personne particulière ne peuvent pas être récupérées.";
    var Question_six_title$1 = "Puis-je supprimer mes données ?";
    var Question_six_answer$1 = "Oui ! Bien que vous fournissiez vos données de manière anonyme (nous ne vous demandons pas votre nom ou toute autre information qui vous identifie), vous pouvez nous demander d'extraire vos données de la plateforme Bike Data Project. Veuillez nous envoyer un e-mail à bikedataproject@openknowledge.be avec le nom de l'application que vous avez utilisée pour fournir vos données et, si possible, également le numéro d'identification associé à votre compte dans l'application.";
    var Question_seven_title$1 = "Quelles données est-ce que je partage depuis mon application ?";
    var Question_seven_answer$1 = "Nous souhaitons principalement vous demander de fournir les données concernant vos activités cyclistes, plus précisément où et quand vous faites du vélo. En plus de cela, il est possible de partager des informations sur votre genre, votre âge, le type de vélo et la raison de votre déplacement (loisirs, sports, domicile-travail,...).";
    var Question_eight_title$1 = "Comment accéder aux données ouvertes ?";
    var Question_eight_answerOne$1 = "Les données cyclistes agrégées non privées seront ouvertes au public en tant que données ouvertes. Les données ouvertes fournies par la plateforme Bike Data Project peuvent être librement utilisées par différentes parties prenantes et à des fins différentes.";
    var Question_eight_answerTwo$1 = "Toutes les données cyclables agrégées seront disponibles sous forme de données ouvertes d'ici la fin octobre 2020. Pour l'instant, vous pouvez contribuer au projet en faisant don de vos données cyclistes.";
    var Question_nine_title$1 = "J'aimerais être plus impliqué.e dans ce projet - comment aider ?";
    var Question_nine_answer$1 = "C'est génial! N'hésitez pas à rejoindre notre groupe Slack (https://join.slack.com/t/bikedataproject/sharedinvite/zt-g60t5w5c-lT2ucV0HtLEVnE4wG9hTg) et à vous y introduire. Nous serons super heureux de savoir comment vous aimeriez contribuer au projet !";
    var Contact_title$1 = "Contact";
    var Further_questions$1 = "Pour toute question ou information complémentaire, veuillez nous contacter via :";
    var Follow_socials$1 = "Pour toute question ou information complémentaire, veuillez nous contacter via :";
    var Cookies_title$1 = "Cookie Policy";
    var What_are_cookies$1 = "1. Que sont les cookies ?";
    var Cookies_section_one$1 = "Les cookies sont de petits fichiers téléchargés sur votre ordinateur pour améliorer votre expérience. Cette page décrit les informations qu'ils collectent, comment nous les utilisons et pourquoi nous avons parfois besoin de stocker ces cookies. Nous partagerons également comment vous pouvez empêcher le stockage de ces cookies. Cependant, cela peut rétrograder ou «casser» certains éléments de la fonctionnalité du site. Pour plus d'informations générales sur les cookies";
    var Cookies_section_oneLink$1 = "voir cet article de Wikipedia sur les cookies HTTP.";
    var How_we_use_cookies$1 = "2. Comment nous utilisons les cookies";
    var Cookies_section_two$1 = "Nous utilisons des cookies pour diverses raisons détaillées ci-dessous. Malheureusement, dans la plupart des cas, il n'y a pas d'options standard pour désactiver les cookies sans désactiver complètement les fonctionnalités qu'ils ajoutent à ce site. Il est recommandé de laisser tous les cookies si vous n'êtes pas sûr d'en avoir besoin ou non au cas où ils seraient utilisés pour fournir un service que vous utilisez.";
    var Disabling_cookies$1 = "3. Désactiver les cookies";
    var Cookies_section_three$1 = "Vous pouvez empêcher le téléchargement de cookies en ajustant les paramètres de votre navigateur (voir le menu Aide de votre navigateur pour savoir comment procéder). Veuillez noter que la désactivation des cookies peut affecter la fonctionnalité de ce site Web et de nombreux autres sites Web que vous visitez. La désactivation des cookies entraînera généralement la désactivation de certaines fonctionnalités et fonctionnalités de ce site. Si vous souhaitez désactiver les cookies, nous vous recommandons d'utiliser";
    var Cookies_section_threeLink$1 = "Firefox.";
    var Cookies_we_set$1 = "4. Cookies que nous définissons";
    var Cookies_section_fourOne$1 = "Notre site web comprend un service d'abonnement à la newsletter et des cookies peuvent être utilisés pour vous rappeler si vous êtes déjà inscrit et si vous souhaitez afficher certaines notifications qui ne sont valables que pour les utilisateurs abonnés/désabonnés.";
    var Cookies_section_fourTwo$1 = "Afin de vous offrir une excellente expérience sur ce site, nous fournissons la fonctionnalité permettant de définir la langue en fonction de la langue que vous utilisez dans votre navigateur. Afin de nous souvenir de vos préférences, nous devons définir des cookies, afin que ces informations puissent être rappelées chaque fois que vous interagissez avec une page qui est affectée par vos préférences.";
    var Third_party_cookies$1 = "5. Cookies tiers";
    var Cookies_section_five$1 = "Notre site n'utilise pas de cookies fournis par des tiers.";
    var More_information$1 = "6. Plus d'information";
    var Cookies_section_six$1 = "Comme mentionné précédemment, s'il y a quelque chose dont vous n'êtes pas sûr d'avoir besoin ou non, il est généralement plus sûr de laisser les cookies activés - juste au cas où ils interagissent avec l'une des fonctionnalités que vous utilisez sur notre site. Si vous cherchez toujours plus d'informations, vous pouvez nous contacter au ";
    var Privacy_title$1 = "Politique de confidentialité";
    var Privacy_introOne$1 = "Responsable du traitement des données et propriétaire";
    var Privacy_introTwo$1 = "Bike Data Project est sous Open Knowledge Belgium en tant que personne morale, une organisation à but non lucratif, constituée et existant sous le droit belge, avec siège social au 12 Cantersteen 1000 Bruxelles, Belgique, sous le numéro d'entreprise 0845.419.930.";
    var Privacy_policy_section$1 = "1. Politique de la Vie Privée";
    var Privacy_section_one$1 = "Cette «Politique de confidentialité» s'applique aux «Données personnelles» collectées par Bike Data Project via ce site Web.";
    var What_does_personal$1 = "2. Que signifient les données personnelles ?";
    var Privacy_section_two$1 = "Dans cette politique de confidentialité, les données personnelles font référence aux informations qui permettent de vous identifier. Une personne identifiable est une personne qui peut être identifiée, directement ou indirectement, notamment par référence à un numéro d'identification ou à un ou plusieurs facteurs liés à l'identité physique, physiologique, mentale, économique, culturelle ou sociale. Un exemple typique d'informations personnelles est votre nom et votre adresse e-mail.";
    var What_personal_data$1 = "3. Quelles données personnelles collectons-nous ?";
    var Privacy_section_three$1 = "Nous pouvons collecter vos données personnelles à partir des sources suivantes :";
    var Privacy_section_threeOne$1 = "3.1 Données personnelles que vous fournissez lors du processus de contribution des données sur la plateforme.";
    var Privacy_section_threeOne_pointOne$1 = "Données sur votre profil public dans votre application cycliste préférée (obligatoire)";
    var Privacy_section_threeOne_pointTwo$1 = "Données sur vos activités cyclistes privées dans votre application cycliste préférée (obligatoire)";
    var Privacy_section_threeOne_pointThree$1 = "Votre consentez à ces conditions";
    var Privacy_section_threeTwo$1 = "3.2 Données personnelles que nous collectons lorsque vous visitez notre site Web.";
    var Privacy_section_threeTwo_content$1 = "Nous utilisons des cookies pour collecter automatiquement des données personnelles vous concernant lorsque vous utilisez ce site Web. Pour plus d'informations, veuillez consulter notre politique en matière de cookies.";
    var Privacy_section_threeThree$1 = "3.3. Données personnelles que vous fournissez lors du partage des données cyclistes";
    var Privacy_section_threeThree_pointOne$1 = "Vos déplacements à vélo (obligatoire)";
    var Privacy_section_threeThree_pointTwo$1 = "Votre tranche d'âge (facultatif)";
    var Privacy_section_threeThree_pointThree$1 = "Votre genre (facultatif)";
    var Privacy_section_threeThree_pointFour$1 = "La raison de votre déplacement à vélo (facultatif)";
    var Privacy_section_threeThree_pointFive$1 = "Votre type de vélo (facultatif)";
    var How_use_personal_data$1 = "4. Comment utilisons-nous les données personnelles ?";
    var Privacy_section_fourOne$1 = "Nous collectons des données cyclistes de nombreux cyclistes individuels et visons à rendre les données agrégées non privées disponibles au public sous forme de données ouvertes. Les données agrégées seront publiées de manière à ce qu'il ne soit pas possible de récupérer les informations personnelles d'un cycliste individuel.";
    var Privacy_section_fourTwo$1 = "La publication des données se fera sur la base du principe de confidentialité différentielle, qui est un système de partage public d'informations sur un ensemble de données en décrivant les modèles de groupes au sein de l'ensemble de données tout en retenant des informations sur les individus de l'ensemble de données. Cela signifie essentiellement que les données ne seront publiées que si les informations d'une personne en particulier ne peuvent pas être récupérées.";
    var Privacy_section_fourThree$1 = "Les données personnelles ne sont stockées et traitées que pendant la durée requise aux fins du traitement. Après cela, les données seront supprimées ou rendues anonymes. Bike Data Project s'appuie sur DigitalOcean qui est certifié selon les principales normes de confidentialité et de sécurité. Les services DigitalOcean sont conformes au GDPR. Toutes les informations relatives à DigitalOcean peuvent être trouvées ici.";
    var With_whom_do$1 = "5. Avec qui partageons-nous vos données personnelles ?";
    var Privacy_section_five$1 = "Vos données personnelles ne seront partagées avec aucun tiers. Nous ne vendrons ni ne louerons jamais vos données personnelles à d'autres fournisseurs de services, ni ne partagerons vos données personnelles avec des fournisseurs de services qui ne sont pas conformes au RGPD.";
    var Where_do_we_transfer$1 = "6. Où transférons-nous vos données personnelles ?";
    var Privacy_section_six$1 = "Nous ne transférons vos données personnelles à des prestataires de services établis en dehors de l'Espace économique européen que s'ils se conforment à l'article 44 du RGPD. Tous les fournisseurs de services basés aux États-Unis se conforment au Privacy Shield.";
    var Automated_decision$1 = "7. Prise de décision et profilage automatisés.";
    var Privacy_section_seven$1 = "Le traitement de vos données personnelles n'inclut pas le profilage et ne sera pas soumis à une prise de décision automatisée pour le Bike Data Project.";
    var What_rights_do$1 = "8. Quels droits avez-vous ? ";
    var Privacy_section_eight$1 = "Vous avez le droit de consulter vos données personnelles à tout moment, ainsi que le droit d'être informé.e de l'utilisation que Bike Data Project fait de vos données personnelles.";
    var Privacy_section_eightOne$1 = "1. Droit de rectification, de suppression et de limitation du traitement";
    var Privacy_section_eightOne_content$1 = "Vous êtes libre de décider de fournir ou non vos données personnelles au Bike Data Project. De plus, vous avez toujours le droit de modifier, compléter ou supprimer vos données personnelles sur le Bike Data Project. Vous reconnaissez qu'un refus de fournir ou une demande de suppression de données personnelles signifie que certains services ne peuvent plus être fournis. Vous pouvez également demander la limitation du traitement de vos données personnelles.";
    var Privacy_section_eightTwo$1 = "2. Droit d'opposition";
    var Privacy_section_eightTwo_content$1 = "Vous avez le droit de vous opposer au traitement de vos données personnelles, pour autant que cela soit pour des raisons sérieuses et légitimes.";
    var Privacy_section_eightThree$1 = "3. Droit à la portabilité des données";
    var Privacy_section_eightThree_content$1 = "Vous avez le droit d'obtenir les données personnelles que vous avez fournies au Bike Data Project sous une forme structurée, typique et lisible par machine et/ou de les transférer à différents contrôleurs.";
    var Privacy_section_eightFour$1 = "4. Droit de retirer son consentement";
    var Privacy_section_eightFour_content$1 = "Dans la mesure où le traitement est basé sur votre consentement préalable, vous avez le droit de retirer cette approbation.";
    var Privacy_section_eightFive$1 = "5. Droit de déposer une plainte";
    var Privacy_section_eightFive_content$1 = "Vous avez le droit de déposer une plainte auprès de la Commission belge de la protection de la vie privée: Personal Privacy Protection Commission, Drukpersstraat 35, 1000 Bruxelles, Belgique, Tel +32 (0) 2274 48 00, Fax +32 (0) 2274 48 35, email : commission@privacycommission.be. Cela n'affecte pas la réparation devant un tribunal civil.";
    var Exercising_your_rights$1 = "9. Exercer vos droits";
    var Privacy_section_nine$1 = "Vous pouvez exercer vos droits en contactant Bike Data Project à cet effet en envoyant un email à support bikedataproject@openknowledge.be, à condition de joindre une copie de votre carte d'identité";
    var Additional_info$1 = "Informations supplémentaires sur la collecte et le traitement des données";
    var Legal_procedures$1 = "Procédures légales";
    var Legal_procedures_contentOne$1 = "The Processor and the Controller for the processing of the Data might use the Personal Data of the User for legal purposes, for the court or legal proceedings in the event of unlawful use of this Application or the related services.";
    var Legal_procedures_contentTwo$1 = "Le sous-traitant et le responsable du traitement des données peuvent utiliser les données personnelles de l'utilisateur à des fins légales, pour le tribunal ou des procédures judiciaires en cas d'utilisation illégale de cette application ou des services associés.";
    var Security_measures$1 = "Mesures de sécurité";
    var Security_measures_contentOne$1 = "Bike Data Project a développé des mesures de sécurité qui ont été ajustées au niveau technologique et organisationnel pour empêcher la destruction, la perte, la falsification, la modification, l'accès interdit ou la divulgation erronée à des tiers de données personnelles ainsi que tout autre traitement interdit de ces données.";
    var Security_measures_contentTwo$1 = "En aucun cas Bike Data Project ne pourra être tenu pour responsable de toute perte directe ou indirecte résultant d'une utilisation incorrecte ou illicite de vos données personnelles par un tiers.";
    var Security_measures_contentThree$1 = "Vous devez à tout moment vous conformer aux instructions de sécurité, qui incluent la prévention de tout accès interdit à vos informations de connexion, y compris votre mot de passe. Vous êtes seul responsable de l'utilisation du site Web sur votre ordinateur, de votre adresse IP et de vos informations d'identification, ainsi que de la confidentialité de celles-ci.";
    var Definitions_legal_framework$1 = "Définitions et cadre juridique";
    var Personal_data$1 = "Données personnelles (ou données)";
    var Personal_data_content$1 = "Toute information concernant une personne physique, une personne morale, une institution ou une association qui a été ou pourrait être identifiée directement ou indirectement par référence à d'autres informations.";
    var Usage_data$1 = "Des données d'utilisation";
    var Usage_data_content$1 = "Les informations qui sont automatiquement collectées à partir de cette Application (ou des services externes utilisés dans cette Application), y compris: les adresses IP ou les noms de domaine des ordinateurs utilisés par les Utilisateurs de cette Application, les adresses URI (Uniform Resource Identifier), l'heure de la requête, la méthode utilisée pour soumettre la requête au serveur, la taille du fichier reçu en réponse, le code numérique indiquant l'état de la réponse du serveur (succès, erreur, etc.), les fonctions du navigateur et le système d'exploitation de l'Utilisateur, les différentes données de temps par visite (comme le temps passé sur chaque page de l'application) et les données collectées lors de l'utilisation de l'application (exemple: l'ordre des pages visitées ou d'autres paramètres concernant le système d'exploitation de l'appareil).";
    var User$1 = "Utilisateur";
    var User_content$1 = "La personne utilisant cette application et qui doit être d'accord avec ou être autorisée par la personne concernée à laquelle se réfèrent les données personnelles.";
    var Person_concerned$1 = "La personne concernée";
    var Person_concerned_content$1 = "La personne morale ou physique à laquelle se rapportent les données personnelles.";
    var Data_processor$1 = "Processeur de données (ou superviseur de données)";
    var Data_processor_content$1 = "La personne physique, la personne morale, l'administration gouvernementale ou toute autre institution, association ou organisation qui a été autorisée par le contrôleur de données à traiter les données personnelles conformément à la présente politique de confidentialité.";
    var Responsible_processing$1 = "Responsable du traitement des données (ou propriétaire)";
    var Responsible_processing_content$1 = "La personne physique, la personne morale, l'administration gouvernementale ou toute autre institution, association ou organisation ayant le droit, également conjointement avec le responsable du traitement des données, de prendre des décisions concernant les finalités et les méthodes de traitement des données personnelles et les moyens utilisés, y compris mesures de sécurité concernant l'exploitation et l'utilisation de cette application. Le responsable du traitement des données est le propriétaire de cette application, sauf indication contraire.";
    var This_application$1 = "Cette application";
    var This_application_content$1 = "Les outils matériels ou logiciels par lesquels les données personnelles de l'utilisateur sont collectées.";
    var Cookie$1 = "Cookie";
    var Cookie_content$1 = "Petit morceau de données stocké sur l'appareil de l'utilisateur. Consultez notre politique relative aux cookies.";
    var Legal_information$1 = "Information légale";
    var Legal_information_content$1 = "Avis aux utilisateurs européens: cette déclaration de confidentialité a été rédigée dans le respect des obligations de l'art. 10 de la directive européenne 95/46 / CE et les dispositions de la directive européenne 2002/58 / CE, ainsi que la révision de la directive 2009/136 / CE concernant les cookies.";
    var Changes_privacy_policy$1 = "Modifications de cette politique de confidentialité";
    var Changes_privacy_policy_date$1 = "Dernière mise à jour: 16 septembre 2020";
    var Changes_privacy_policy_content$1 = "Le Responsable du traitement des Données se réserve le droit de modifier cette politique de confidentialité à tout moment en informant les Utilisateurs sur cette page. Nous vous encourageons à consulter cette page pour d'éventuels changements. La date du dernier changement est indiquée en bas de page. Si un utilisateur s'oppose à toute modification de la politique, l'utilisateur ne doit pas continuer à utiliser cette application. On peut demander au responsable du traitement des données de supprimer les données personnelles. Sauf indication contraire, la politique de confidentialité en vigueur à ce moment-là s'applique à toutes les données personnelles que le contrôleur a stockées pour le traitement des données sur les utilisateurs.";
    var Terms_title$1 = "Conditions d'utilisation";
    var Terms_introOne$1 = "Avec le Bike Data Project, Open Knowledge Belgium - l'organisation parapluie des initiatives de connaissance ouverte et de données ouvertes en Belgique - fournit une plateforme de données cyclables collaborative qui collecte des données sur où et quand les cyclistes font du vélo.";
    var Terms_introTwo$1 = "La plate-forme vise à regrouper les données des cyclistes, provenant de différentes applications et sources mobiles, en une seule plate-forme de données de vélo ouverte afin de permettre aux communautés locales de rendre le cyclisme plus visible et aux décideurs de rendre les villes plus vivables et plus conviviales pour les vélos.";
    var Terms_introThree$1 = "La participation à ce projet et l'utilisation de cette plateforme sont soumises à un certain nombre de règles. Vous trouverez ci-dessous les conditions générales de notre projet, car nous sommes convaincus que des règles claires offrent la meilleure garantie pour une communauté respectueuse.";
    var Terms_introFour$1 = "Parce qu'Open Knowledge Belgium apprécie les retours de la communauté Bike Data Project, nous accueillons toute idée pour améliorer encore la plateforme. Vous pouvez envoyer vos suggestions par e-mail.";
    var Who_can_contribute$1 = "Qui peut contribuer au Bike Data Project et qui peut utiliser les données ouvertes fournies par le Bike Data Project ?";
    var Who_can_contribute_contentOne$1 = "Tout type de cycliste peut contribuer au projet en partageant des données cyclables. Vous pouvez soit lier votre application cycliste préférée pour partager vos données, soit utiliser l'application Bike Data Project afin de contribuer au Bike Data Project. Pour utiliser l'application du Bike Data Project, vous n'avez pas besoin de créer un compte pour utiliser l'application.Vous et vos données cyclistes collectées resteront donc anonymes.";
    var Who_can_contribute_contentTwo$1 = "Les données cyclistes agrégées non privées seront ouvertes au public en tant que données ouvertes. Les données ouvertes fournies par la plate-forme Bike Data Project sont publiées sous une licence internationale Creative Commons Attribution 4.0, qui n'impose aucune restriction sur votre utilisation des données ouvertes. Vous n'êtes tenu de donner un crédit approprié au projet de données de vélo qu'en fournissant le nom du projet, un avis de droit d'auteur, un avis de licence, un avis de non-responsabilité et un lien vers la plate-forme.";
    var Limitation_of_liability$1 = "Limitation de responsabilité";
    var Limitation_of_liability_contentOne$1 = "Le projet ne peut être tenu responsable de tout échec ou retard dans l'exécution des conditions. La plateforme ne saurait être tenue pour responsable de toute responsabilité en cas de dommage personnel résultant de son utilisation. Vous devez défendre, indemniser et dégager de toute responsabilité le Bike Data Project (et chacun de ses partenaires et / ou bénévoles) contre toute réclamation, demande, action, dommage, perte, coût ou dépense, y compris, sans limitation, les honoraires d'avocat raisonnables, découlant ou concernant (a) votre utilisation de notre projet; (b) tout contenu de membre ou soumissions que vous fournissez; (c) votre violation de ces conditions; (d) votre violation des droits d'autrui; ou (e) votre conduite en relation avec les services. En outre, si vous utilisez le projet au nom d'une entité, vous déclarez et garantissez que cette entité accepte de vous indemniser, vous et le Bike Data Project, pour les violations de ces conditions conformément à la présente section. Si vous êtes obligé de nous indemniser, nous aurons le droit, à notre seule et entière discrétion, de contrôler toute action ou procédure et de déterminer si nous souhaitons la régler et, le cas échéant, à quelles conditions.";
    var Limitation_of_liability_contentTwo$1 = "Nous croyons fermement à la liberté d'expression. Cependant, afin de garantir que la plateforme puisse être utilisée de manière constructive par les utilisateurs, dans le respect des différentes opinions et sans que les gens aient à craindre de participer au projet, nous n'autorisons pas les comportements offensants qui harcèlent, intimident ou utilisent peur de faire taire un autre utilisateur.";
    var Spam$1 = "Spam";
    var Spam_contentOne$1 = "Nous nous efforçons à tout moment de protéger l'utilisateur de la plateforme Bike Data Project contre les abus techniques et les spams. Les comptes utilisés pour effectuer les actions répertoriées ci-dessous peuvent être temporairement bloqués ou supprimés définitivement.";
    var Spam_contentTwo$1 = "Malware / phishing / viruses / worms / Trojans: Vous ne pouvez pas publier de contenu malveillant ou des liens vers un tel contenu dans le but d'endommager ou de perturber les navigateurs ou les ordinateurs de quelqu'un d'autre, ou de violer la vie privée de quelqu'un. Spam: vous n'êtes pas autorisé à utiliser la plateforme Bike Data Project pour spammer des personnes.";
    var Infringement$1 = "Violation des lois applicables";
    var Infringement_contentOne$1 = "L'utilisation du compte ne doit en aucun cas enfreindre les lois applicables. Cela inclut les infractions à la législation sur la protection de la vie privée, aux droits de propriété intellectuelle, au code pénal, etc. Le compte ne peut en aucun cas être utilisé pour promouvoir des activités illégales.";
    var Infringement_contentTwo$1 = "Le compte ne peut en aucun cas être utilisé pour promouvoir des activités illégales.";
    var Breaches_aforementioned_rules$1 = "En cas de non-respect des règles précitées";
    var Breaches_aforementioned_rules_content$1 = "Il peut arriver que des fichiers nuisibles puissent être téléchargés via la plateforme, que ce soit du fait ou non d'un utilisateur, ou que les utilisateurs placent des hyperliens nuisibles. Tout téléchargement par un utilisateur ou clic sur un lien hypertexte, placé par un utilisateur, se fait aux risques et périls de l'utilisateur. Tout dommage encouru est entièrement et uniquement de la responsabilité de cet utilisateur.";
    var Property_rights$1 = "Droits de propriété Bike Data Project";
    var Property_rights_content$1 = "Le code source de Bike Data Project est publié sous une licence open source MIT. Vous acceptez d'être lié et de vous conformer à tout accord de licence qui s'applique à ce logiciel open source. L'identité visuelle, y compris le logo et les couleurs, est disponible sous CC BY 4.0. Le nom du Bike Data Project ne peut être ni utilisé ni répliqué.";
    var Thanks_Bigletter$1 = "Thank You";
    var Thanks_Fitbit_title$1 = "Thank you for linking your Fitbit account!";
    var Thanks_Content1$1 = "Your Fibit account is now linked to the Bike Data Project.";
    var Thanks_Content2$1 = "Your contributions will show up automatically from now on when you log bicycle rides via FitBit.";
    var fr = {
    	Contribute: Contribute$1,
    	The_data: The_data$1,
    	About: About$1,
    	FAQ: FAQ$1,
    	Contact: Contact$1,
    	Heading: Heading$1,
    	Introduction: Introduction$1,
    	Label_total_km: Label_total_km$1,
    	Help_title: Help_title$1,
    	Ask_for_favor: Ask_for_favor$1,
    	By_sharing_your: By_sharing_your$1,
    	Every_cyclist_can: Every_cyclist_can$1,
    	Donate_title: Donate_title$1,
    	Several_ways_to_contribute: Several_ways_to_contribute$1,
    	You_not_using: You_not_using$1,
    	Connect_existing_account: Connect_existing_account$1,
    	Download_our_app: Download_our_app$1,
    	Data_title: Data_title$1,
    	Rides_collected: Rides_collected$1,
    	Distance_collected: Distance_collected$1,
    	Average_duration: Average_duration$1,
    	Average_speed: Average_speed$1,
    	Average_distance: Average_distance$1,
    	co2_saved: co2_saved$1,
    	Data_subtitle: Data_subtitle$1,
    	Data_button: Data_button$1,
    	Contribute_title: Contribute_title$1,
    	People_who_work: People_who_work$1,
    	Common_goal: Common_goal$1,
    	Visible_title: Visible_title$1,
    	Community_more_visible: Community_more_visible$1,
    	Globally_but_locally: Globally_but_locally$1,
    	Informed_title: Informed_title$1,
    	Email_label: Email_label$1,
    	Informed_placeholder: Informed_placeholder$1,
    	Partners_title: Partners_title$1,
    	Footer_intro: Footer_intro$1,
    	Footer_nav_title: Footer_nav_title$1,
    	Footer_contact: Footer_contact$1,
    	Footer_street: Footer_street$1,
    	Footer_city: Footer_city$1,
    	Footer_copyright_one: Footer_copyright_one$1,
    	Footer_copyright_two: Footer_copyright_two$1,
    	Terms_of_use: Terms_of_use$1,
    	Privacy_policy: Privacy_policy$1,
    	Cookie_policy: Cookie_policy$1,
    	Help: Help$1,
    	Contribute_big: Contribute_big$1,
    	Data: Data$1,
    	Power: Power$1,
    	Partners: Partners$1,
    	About_us: About_us$1,
    	Faq: Faq$1,
    	Contact_us: Contact_us$1,
    	Cookies: Cookies$1,
    	Privacy: Privacy$1,
    	Terms: Terms$1,
    	Map_title: Map_title$1,
    	Data_content_one: Data_content_one$1,
    	Data_content_two: Data_content_two$1,
    	Data_content_three: Data_content_three$1,
    	Data_content_listOne: Data_content_listOne$1,
    	Data_content_listTwo: Data_content_listTwo$1,
    	Data_content_listThree: Data_content_listThree$1,
    	Data_content_listFour: Data_content_listFour$1,
    	Data_content_four: Data_content_four$1,
    	Map_subtitle: Map_subtitle$1,
    	About_title: About_title$1,
    	About_intro: About_intro$1,
    	About_titleOne: About_titleOne$1,
    	About_contentOne_oneBefore: About_contentOne_oneBefore$1,
    	About_contentOne_oneMiddle: About_contentOne_oneMiddle$1,
    	About_contentOne_oneAfter: About_contentOne_oneAfter$1,
    	About_contentOne_twoBefore: About_contentOne_twoBefore$1,
    	About_contentOne_twoAfter: About_contentOne_twoAfter$1,
    	About_contentOne_three: About_contentOne_three$1,
    	About_titleTwo: About_titleTwo$1,
    	About_contentTwo_one: About_contentTwo_one$1,
    	About_contentTwo_two: About_contentTwo_two$1,
    	About_titleThree: About_titleThree$1,
    	About_contentThree_one: About_contentThree_one$1,
    	About_contentThree_two: About_contentThree_two$1,
    	About_contentThree_listOneBold: About_contentThree_listOneBold$1,
    	About_contentThree_listOne: About_contentThree_listOne$1,
    	About_contentThree_listTwoBold: About_contentThree_listTwoBold$1,
    	About_contentThree_listTwo: About_contentThree_listTwo$1,
    	About_contentThree_listThreeBold: About_contentThree_listThreeBold$1,
    	About_contentThree_listThree: About_contentThree_listThree$1,
    	About_titleFour: About_titleFour$1,
    	About_contentFour: About_contentFour$1,
    	Faq_title: Faq_title$1,
    	Question_one_title: Question_one_title$1,
    	Question_one_answerOne: Question_one_answerOne$1,
    	Question_one_answerTwo: Question_one_answerTwo$1,
    	Question_two_title: Question_two_title$1,
    	Question_two_answerOne: Question_two_answerOne$1,
    	Question_two_answerTwo: Question_two_answerTwo$1,
    	Question_two_answerThree: Question_two_answerThree$1,
    	Question_three_title: Question_three_title$1,
    	Question_three_answer: Question_three_answer$1,
    	Question_four_title: Question_four_title$1,
    	Question_four_answerOne: Question_four_answerOne$1,
    	Question_four_answerTwo: Question_four_answerTwo$1,
    	Question_four_answerThree: Question_four_answerThree$1,
    	Question_four_answerFour: Question_four_answerFour$1,
    	Question_four_answerFive: Question_four_answerFive$1,
    	Question_four_answerSix: Question_four_answerSix$1,
    	Question_four_answerSeven: Question_four_answerSeven$1,
    	Question_five_title: Question_five_title$1,
    	Question_five_answerOne: Question_five_answerOne$1,
    	Question_five_answerTwo: Question_five_answerTwo$1,
    	Question_five_answerThree: Question_five_answerThree$1,
    	Question_six_title: Question_six_title$1,
    	Question_six_answer: Question_six_answer$1,
    	Question_seven_title: Question_seven_title$1,
    	Question_seven_answer: Question_seven_answer$1,
    	Question_eight_title: Question_eight_title$1,
    	Question_eight_answerOne: Question_eight_answerOne$1,
    	Question_eight_answerTwo: Question_eight_answerTwo$1,
    	Question_nine_title: Question_nine_title$1,
    	Question_nine_answer: Question_nine_answer$1,
    	Contact_title: Contact_title$1,
    	Further_questions: Further_questions$1,
    	Follow_socials: Follow_socials$1,
    	Cookies_title: Cookies_title$1,
    	What_are_cookies: What_are_cookies$1,
    	Cookies_section_one: Cookies_section_one$1,
    	Cookies_section_oneLink: Cookies_section_oneLink$1,
    	How_we_use_cookies: How_we_use_cookies$1,
    	Cookies_section_two: Cookies_section_two$1,
    	Disabling_cookies: Disabling_cookies$1,
    	Cookies_section_three: Cookies_section_three$1,
    	Cookies_section_threeLink: Cookies_section_threeLink$1,
    	Cookies_we_set: Cookies_we_set$1,
    	Cookies_section_fourOne: Cookies_section_fourOne$1,
    	Cookies_section_fourTwo: Cookies_section_fourTwo$1,
    	Third_party_cookies: Third_party_cookies$1,
    	Cookies_section_five: Cookies_section_five$1,
    	More_information: More_information$1,
    	Cookies_section_six: Cookies_section_six$1,
    	Privacy_title: Privacy_title$1,
    	Privacy_introOne: Privacy_introOne$1,
    	Privacy_introTwo: Privacy_introTwo$1,
    	Privacy_policy_section: Privacy_policy_section$1,
    	Privacy_section_one: Privacy_section_one$1,
    	What_does_personal: What_does_personal$1,
    	Privacy_section_two: Privacy_section_two$1,
    	What_personal_data: What_personal_data$1,
    	Privacy_section_three: Privacy_section_three$1,
    	Privacy_section_threeOne: Privacy_section_threeOne$1,
    	Privacy_section_threeOne_pointOne: Privacy_section_threeOne_pointOne$1,
    	Privacy_section_threeOne_pointTwo: Privacy_section_threeOne_pointTwo$1,
    	Privacy_section_threeOne_pointThree: Privacy_section_threeOne_pointThree$1,
    	Privacy_section_threeTwo: Privacy_section_threeTwo$1,
    	Privacy_section_threeTwo_content: Privacy_section_threeTwo_content$1,
    	Privacy_section_threeThree: Privacy_section_threeThree$1,
    	Privacy_section_threeThree_pointOne: Privacy_section_threeThree_pointOne$1,
    	Privacy_section_threeThree_pointTwo: Privacy_section_threeThree_pointTwo$1,
    	Privacy_section_threeThree_pointThree: Privacy_section_threeThree_pointThree$1,
    	Privacy_section_threeThree_pointFour: Privacy_section_threeThree_pointFour$1,
    	Privacy_section_threeThree_pointFive: Privacy_section_threeThree_pointFive$1,
    	How_use_personal_data: How_use_personal_data$1,
    	Privacy_section_fourOne: Privacy_section_fourOne$1,
    	Privacy_section_fourTwo: Privacy_section_fourTwo$1,
    	Privacy_section_fourThree: Privacy_section_fourThree$1,
    	With_whom_do: With_whom_do$1,
    	Privacy_section_five: Privacy_section_five$1,
    	Where_do_we_transfer: Where_do_we_transfer$1,
    	Privacy_section_six: Privacy_section_six$1,
    	Automated_decision: Automated_decision$1,
    	Privacy_section_seven: Privacy_section_seven$1,
    	What_rights_do: What_rights_do$1,
    	Privacy_section_eight: Privacy_section_eight$1,
    	Privacy_section_eightOne: Privacy_section_eightOne$1,
    	Privacy_section_eightOne_content: Privacy_section_eightOne_content$1,
    	Privacy_section_eightTwo: Privacy_section_eightTwo$1,
    	Privacy_section_eightTwo_content: Privacy_section_eightTwo_content$1,
    	Privacy_section_eightThree: Privacy_section_eightThree$1,
    	Privacy_section_eightThree_content: Privacy_section_eightThree_content$1,
    	Privacy_section_eightFour: Privacy_section_eightFour$1,
    	Privacy_section_eightFour_content: Privacy_section_eightFour_content$1,
    	Privacy_section_eightFive: Privacy_section_eightFive$1,
    	Privacy_section_eightFive_content: Privacy_section_eightFive_content$1,
    	Exercising_your_rights: Exercising_your_rights$1,
    	Privacy_section_nine: Privacy_section_nine$1,
    	Additional_info: Additional_info$1,
    	Legal_procedures: Legal_procedures$1,
    	Legal_procedures_contentOne: Legal_procedures_contentOne$1,
    	Legal_procedures_contentTwo: Legal_procedures_contentTwo$1,
    	Security_measures: Security_measures$1,
    	Security_measures_contentOne: Security_measures_contentOne$1,
    	Security_measures_contentTwo: Security_measures_contentTwo$1,
    	Security_measures_contentThree: Security_measures_contentThree$1,
    	Definitions_legal_framework: Definitions_legal_framework$1,
    	Personal_data: Personal_data$1,
    	Personal_data_content: Personal_data_content$1,
    	Usage_data: Usage_data$1,
    	Usage_data_content: Usage_data_content$1,
    	User: User$1,
    	User_content: User_content$1,
    	Person_concerned: Person_concerned$1,
    	Person_concerned_content: Person_concerned_content$1,
    	Data_processor: Data_processor$1,
    	Data_processor_content: Data_processor_content$1,
    	Responsible_processing: Responsible_processing$1,
    	Responsible_processing_content: Responsible_processing_content$1,
    	This_application: This_application$1,
    	This_application_content: This_application_content$1,
    	Cookie: Cookie$1,
    	Cookie_content: Cookie_content$1,
    	Legal_information: Legal_information$1,
    	Legal_information_content: Legal_information_content$1,
    	Changes_privacy_policy: Changes_privacy_policy$1,
    	Changes_privacy_policy_date: Changes_privacy_policy_date$1,
    	Changes_privacy_policy_content: Changes_privacy_policy_content$1,
    	Terms_title: Terms_title$1,
    	Terms_introOne: Terms_introOne$1,
    	Terms_introTwo: Terms_introTwo$1,
    	Terms_introThree: Terms_introThree$1,
    	Terms_introFour: Terms_introFour$1,
    	Who_can_contribute: Who_can_contribute$1,
    	Who_can_contribute_contentOne: Who_can_contribute_contentOne$1,
    	Who_can_contribute_contentTwo: Who_can_contribute_contentTwo$1,
    	Limitation_of_liability: Limitation_of_liability$1,
    	Limitation_of_liability_contentOne: Limitation_of_liability_contentOne$1,
    	Limitation_of_liability_contentTwo: Limitation_of_liability_contentTwo$1,
    	Spam: Spam$1,
    	Spam_contentOne: Spam_contentOne$1,
    	Spam_contentTwo: Spam_contentTwo$1,
    	Infringement: Infringement$1,
    	Infringement_contentOne: Infringement_contentOne$1,
    	Infringement_contentTwo: Infringement_contentTwo$1,
    	Breaches_aforementioned_rules: Breaches_aforementioned_rules$1,
    	Breaches_aforementioned_rules_content: Breaches_aforementioned_rules_content$1,
    	Property_rights: Property_rights$1,
    	Property_rights_content: Property_rights_content$1,
    	Thanks_Bigletter: Thanks_Bigletter$1,
    	Thanks_Fitbit_title: Thanks_Fitbit_title$1,
    	Thanks_Content1: Thanks_Content1$1,
    	Thanks_Content2: Thanks_Content2$1
    };

    var fr$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Contribute: Contribute$1,
        The_data: The_data$1,
        About: About$1,
        FAQ: FAQ$1,
        Contact: Contact$1,
        Heading: Heading$1,
        Introduction: Introduction$1,
        Label_total_km: Label_total_km$1,
        Help_title: Help_title$1,
        Ask_for_favor: Ask_for_favor$1,
        By_sharing_your: By_sharing_your$1,
        Every_cyclist_can: Every_cyclist_can$1,
        Donate_title: Donate_title$1,
        Several_ways_to_contribute: Several_ways_to_contribute$1,
        You_not_using: You_not_using$1,
        Connect_existing_account: Connect_existing_account$1,
        Download_our_app: Download_our_app$1,
        Data_title: Data_title$1,
        Rides_collected: Rides_collected$1,
        Distance_collected: Distance_collected$1,
        Average_duration: Average_duration$1,
        Average_speed: Average_speed$1,
        Average_distance: Average_distance$1,
        co2_saved: co2_saved$1,
        Data_subtitle: Data_subtitle$1,
        Data_button: Data_button$1,
        Contribute_title: Contribute_title$1,
        People_who_work: People_who_work$1,
        Common_goal: Common_goal$1,
        Visible_title: Visible_title$1,
        Community_more_visible: Community_more_visible$1,
        Globally_but_locally: Globally_but_locally$1,
        Informed_title: Informed_title$1,
        Email_label: Email_label$1,
        Informed_placeholder: Informed_placeholder$1,
        Partners_title: Partners_title$1,
        Footer_intro: Footer_intro$1,
        Footer_nav_title: Footer_nav_title$1,
        Footer_contact: Footer_contact$1,
        Footer_street: Footer_street$1,
        Footer_city: Footer_city$1,
        Footer_copyright_one: Footer_copyright_one$1,
        Footer_copyright_two: Footer_copyright_two$1,
        Terms_of_use: Terms_of_use$1,
        Privacy_policy: Privacy_policy$1,
        Cookie_policy: Cookie_policy$1,
        Help: Help$1,
        Contribute_big: Contribute_big$1,
        Data: Data$1,
        Power: Power$1,
        Partners: Partners$1,
        About_us: About_us$1,
        Faq: Faq$1,
        Contact_us: Contact_us$1,
        Cookies: Cookies$1,
        Privacy: Privacy$1,
        Terms: Terms$1,
        Map_title: Map_title$1,
        Data_content_one: Data_content_one$1,
        Data_content_two: Data_content_two$1,
        Data_content_three: Data_content_three$1,
        Data_content_listOne: Data_content_listOne$1,
        Data_content_listTwo: Data_content_listTwo$1,
        Data_content_listThree: Data_content_listThree$1,
        Data_content_listFour: Data_content_listFour$1,
        Data_content_four: Data_content_four$1,
        Map_subtitle: Map_subtitle$1,
        About_title: About_title$1,
        About_intro: About_intro$1,
        About_titleOne: About_titleOne$1,
        About_contentOne_oneBefore: About_contentOne_oneBefore$1,
        About_contentOne_oneMiddle: About_contentOne_oneMiddle$1,
        About_contentOne_oneAfter: About_contentOne_oneAfter$1,
        About_contentOne_twoBefore: About_contentOne_twoBefore$1,
        About_contentOne_twoAfter: About_contentOne_twoAfter$1,
        About_contentOne_three: About_contentOne_three$1,
        About_titleTwo: About_titleTwo$1,
        About_contentTwo_one: About_contentTwo_one$1,
        About_contentTwo_two: About_contentTwo_two$1,
        About_titleThree: About_titleThree$1,
        About_contentThree_one: About_contentThree_one$1,
        About_contentThree_two: About_contentThree_two$1,
        About_contentThree_listOneBold: About_contentThree_listOneBold$1,
        About_contentThree_listOne: About_contentThree_listOne$1,
        About_contentThree_listTwoBold: About_contentThree_listTwoBold$1,
        About_contentThree_listTwo: About_contentThree_listTwo$1,
        About_contentThree_listThreeBold: About_contentThree_listThreeBold$1,
        About_contentThree_listThree: About_contentThree_listThree$1,
        About_titleFour: About_titleFour$1,
        About_contentFour: About_contentFour$1,
        Faq_title: Faq_title$1,
        Question_one_title: Question_one_title$1,
        Question_one_answerOne: Question_one_answerOne$1,
        Question_one_answerTwo: Question_one_answerTwo$1,
        Question_two_title: Question_two_title$1,
        Question_two_answerOne: Question_two_answerOne$1,
        Question_two_answerTwo: Question_two_answerTwo$1,
        Question_two_answerThree: Question_two_answerThree$1,
        Question_three_title: Question_three_title$1,
        Question_three_answer: Question_three_answer$1,
        Question_four_title: Question_four_title$1,
        Question_four_answerOne: Question_four_answerOne$1,
        Question_four_answerTwo: Question_four_answerTwo$1,
        Question_four_answerThree: Question_four_answerThree$1,
        Question_four_answerFour: Question_four_answerFour$1,
        Question_four_answerFive: Question_four_answerFive$1,
        Question_four_answerSix: Question_four_answerSix$1,
        Question_four_answerSeven: Question_four_answerSeven$1,
        Question_five_title: Question_five_title$1,
        Question_five_answerOne: Question_five_answerOne$1,
        Question_five_answerTwo: Question_five_answerTwo$1,
        Question_five_answerThree: Question_five_answerThree$1,
        Question_six_title: Question_six_title$1,
        Question_six_answer: Question_six_answer$1,
        Question_seven_title: Question_seven_title$1,
        Question_seven_answer: Question_seven_answer$1,
        Question_eight_title: Question_eight_title$1,
        Question_eight_answerOne: Question_eight_answerOne$1,
        Question_eight_answerTwo: Question_eight_answerTwo$1,
        Question_nine_title: Question_nine_title$1,
        Question_nine_answer: Question_nine_answer$1,
        Contact_title: Contact_title$1,
        Further_questions: Further_questions$1,
        Follow_socials: Follow_socials$1,
        Cookies_title: Cookies_title$1,
        What_are_cookies: What_are_cookies$1,
        Cookies_section_one: Cookies_section_one$1,
        Cookies_section_oneLink: Cookies_section_oneLink$1,
        How_we_use_cookies: How_we_use_cookies$1,
        Cookies_section_two: Cookies_section_two$1,
        Disabling_cookies: Disabling_cookies$1,
        Cookies_section_three: Cookies_section_three$1,
        Cookies_section_threeLink: Cookies_section_threeLink$1,
        Cookies_we_set: Cookies_we_set$1,
        Cookies_section_fourOne: Cookies_section_fourOne$1,
        Cookies_section_fourTwo: Cookies_section_fourTwo$1,
        Third_party_cookies: Third_party_cookies$1,
        Cookies_section_five: Cookies_section_five$1,
        More_information: More_information$1,
        Cookies_section_six: Cookies_section_six$1,
        Privacy_title: Privacy_title$1,
        Privacy_introOne: Privacy_introOne$1,
        Privacy_introTwo: Privacy_introTwo$1,
        Privacy_policy_section: Privacy_policy_section$1,
        Privacy_section_one: Privacy_section_one$1,
        What_does_personal: What_does_personal$1,
        Privacy_section_two: Privacy_section_two$1,
        What_personal_data: What_personal_data$1,
        Privacy_section_three: Privacy_section_three$1,
        Privacy_section_threeOne: Privacy_section_threeOne$1,
        Privacy_section_threeOne_pointOne: Privacy_section_threeOne_pointOne$1,
        Privacy_section_threeOne_pointTwo: Privacy_section_threeOne_pointTwo$1,
        Privacy_section_threeOne_pointThree: Privacy_section_threeOne_pointThree$1,
        Privacy_section_threeTwo: Privacy_section_threeTwo$1,
        Privacy_section_threeTwo_content: Privacy_section_threeTwo_content$1,
        Privacy_section_threeThree: Privacy_section_threeThree$1,
        Privacy_section_threeThree_pointOne: Privacy_section_threeThree_pointOne$1,
        Privacy_section_threeThree_pointTwo: Privacy_section_threeThree_pointTwo$1,
        Privacy_section_threeThree_pointThree: Privacy_section_threeThree_pointThree$1,
        Privacy_section_threeThree_pointFour: Privacy_section_threeThree_pointFour$1,
        Privacy_section_threeThree_pointFive: Privacy_section_threeThree_pointFive$1,
        How_use_personal_data: How_use_personal_data$1,
        Privacy_section_fourOne: Privacy_section_fourOne$1,
        Privacy_section_fourTwo: Privacy_section_fourTwo$1,
        Privacy_section_fourThree: Privacy_section_fourThree$1,
        With_whom_do: With_whom_do$1,
        Privacy_section_five: Privacy_section_five$1,
        Where_do_we_transfer: Where_do_we_transfer$1,
        Privacy_section_six: Privacy_section_six$1,
        Automated_decision: Automated_decision$1,
        Privacy_section_seven: Privacy_section_seven$1,
        What_rights_do: What_rights_do$1,
        Privacy_section_eight: Privacy_section_eight$1,
        Privacy_section_eightOne: Privacy_section_eightOne$1,
        Privacy_section_eightOne_content: Privacy_section_eightOne_content$1,
        Privacy_section_eightTwo: Privacy_section_eightTwo$1,
        Privacy_section_eightTwo_content: Privacy_section_eightTwo_content$1,
        Privacy_section_eightThree: Privacy_section_eightThree$1,
        Privacy_section_eightThree_content: Privacy_section_eightThree_content$1,
        Privacy_section_eightFour: Privacy_section_eightFour$1,
        Privacy_section_eightFour_content: Privacy_section_eightFour_content$1,
        Privacy_section_eightFive: Privacy_section_eightFive$1,
        Privacy_section_eightFive_content: Privacy_section_eightFive_content$1,
        Exercising_your_rights: Exercising_your_rights$1,
        Privacy_section_nine: Privacy_section_nine$1,
        Additional_info: Additional_info$1,
        Legal_procedures: Legal_procedures$1,
        Legal_procedures_contentOne: Legal_procedures_contentOne$1,
        Legal_procedures_contentTwo: Legal_procedures_contentTwo$1,
        Security_measures: Security_measures$1,
        Security_measures_contentOne: Security_measures_contentOne$1,
        Security_measures_contentTwo: Security_measures_contentTwo$1,
        Security_measures_contentThree: Security_measures_contentThree$1,
        Definitions_legal_framework: Definitions_legal_framework$1,
        Personal_data: Personal_data$1,
        Personal_data_content: Personal_data_content$1,
        Usage_data: Usage_data$1,
        Usage_data_content: Usage_data_content$1,
        User: User$1,
        User_content: User_content$1,
        Person_concerned: Person_concerned$1,
        Person_concerned_content: Person_concerned_content$1,
        Data_processor: Data_processor$1,
        Data_processor_content: Data_processor_content$1,
        Responsible_processing: Responsible_processing$1,
        Responsible_processing_content: Responsible_processing_content$1,
        This_application: This_application$1,
        This_application_content: This_application_content$1,
        Cookie: Cookie$1,
        Cookie_content: Cookie_content$1,
        Legal_information: Legal_information$1,
        Legal_information_content: Legal_information_content$1,
        Changes_privacy_policy: Changes_privacy_policy$1,
        Changes_privacy_policy_date: Changes_privacy_policy_date$1,
        Changes_privacy_policy_content: Changes_privacy_policy_content$1,
        Terms_title: Terms_title$1,
        Terms_introOne: Terms_introOne$1,
        Terms_introTwo: Terms_introTwo$1,
        Terms_introThree: Terms_introThree$1,
        Terms_introFour: Terms_introFour$1,
        Who_can_contribute: Who_can_contribute$1,
        Who_can_contribute_contentOne: Who_can_contribute_contentOne$1,
        Who_can_contribute_contentTwo: Who_can_contribute_contentTwo$1,
        Limitation_of_liability: Limitation_of_liability$1,
        Limitation_of_liability_contentOne: Limitation_of_liability_contentOne$1,
        Limitation_of_liability_contentTwo: Limitation_of_liability_contentTwo$1,
        Spam: Spam$1,
        Spam_contentOne: Spam_contentOne$1,
        Spam_contentTwo: Spam_contentTwo$1,
        Infringement: Infringement$1,
        Infringement_contentOne: Infringement_contentOne$1,
        Infringement_contentTwo: Infringement_contentTwo$1,
        Breaches_aforementioned_rules: Breaches_aforementioned_rules$1,
        Breaches_aforementioned_rules_content: Breaches_aforementioned_rules_content$1,
        Property_rights: Property_rights$1,
        Property_rights_content: Property_rights_content$1,
        Thanks_Bigletter: Thanks_Bigletter$1,
        Thanks_Fitbit_title: Thanks_Fitbit_title$1,
        Thanks_Content1: Thanks_Content1$1,
        Thanks_Content2: Thanks_Content2$1,
        'default': fr
    });

    var Contribute = "Deelnemen";
    var The_data = "De Data";
    var About = "Over";
    var FAQ = "FAQ";
    var Contact = "Contact";
    var Heading = "Burgers verzamelen fietsdata om steden fietsvriendelijker te maken.";
    var Introduction = "Dankzij data gedeeld door burgers overal ter wereld, wil het Bike Data Project laten zien waar en wanneer mensen met de fiets rijden. De verzamelde fietsgegevens bieden inzichten die lokale gemeenschappen en besluitvormers gebruiken om fietsen en steden veiliger te maken.";
    var Label_total_km = "Totaal aantal kilometers gefietst en gedeeld door burgers over de hele wereld";
    var Help_title = "We hebben je hulp nodig!";
    var Ask_for_favor = "Voor dit project willen we je vragen om je fietsgegevens te delen.";
    var By_sharing_your = "We moeten weten waar er wordt gefietst. Jouw gegevensbijdragen, gecombineerd met de gegevens van veel andere fietsers, zullen steden geschikter maken voor fietsers.";
    var Every_cyclist_can = "Alle fieters kunnen deelnemen aan dit project. Sommige mensen houden hun activiteit al bij voor trainingsdoeleinden. Dat is mooi, maar we willen ook rekening houden met andere activiteiten: pendelen naar het werk, de kinderen naar school brengen of voor een snelle rit naar de supermarkt.";
    var Donate_title = "Deel jouw fietsdata";
    var Several_ways_to_contribute = "Er zijn verschillende manieren waarop je je gegevens met het Bike Data Project kunt delen. Voorlopig kan je je Strava-account verbinden of je Garmin-bestanden uploaden. Zodra jouw app is verbonden, kan je doorgaan zoals je gewend bent en worden jouw ritten automatisch geüpload naar het platform van het Bike Data Project.";
    var You_not_using = "Wat als je nog geen van deze apps gebruikt? Binnenkort kan je de Bike Data Project-app downloaden en gebruiken. Bovendien werken we ook aan de integratie van andere fietsapps!";
    var Connect_existing_account = "Koppel je bestaand account";
    var Download_our_app = "Download onze app (komt binnenkort)";
    var Data_title = "Verzamelde data wereldwijd";
    var Rides_collected = "ritten verzameld";
    var Distance_collected = "afstand verzameld";
    var Average_duration = "gemiddelde duur";
    var Average_speed = "gemiddelde snelheid";
    var Average_distance = "gemiddelde afstand";
    var co2_saved = "CO2 bespaard";
    var Data_subtitle = "Geïnteresseerd in de gegevens per regio?";
    var Data_button = "Verken de data";
    var Contribute_title = "Voor wie zijn de data nuttig?";
    var People_who_work = "Mobiliteitsplanners en stadsplanners hebben dit soort data nodig om moderne infrastructuur en duurzame steden te ontwikkelen. Sommigen van hen zijn op de hoogte en anderen moeten we nog overtuigen. Hoe meer data we kunnen verstrekken, hoe groter de impact zal zijn.";
    var Common_goal = "De data kunnen ook waardevol zijn voor andere fietsgerelateerde producten en diensten. Het gemeenschappelijke doel is om fietsdata te verzamelen en deze beschikbaar te stellen als open data zodat steden fietsvriendelijker worden gemaakt. Voor ons en de mensen die komen.";
    var Visible_title = "Meer fietsdata betekent meer slagkracht door en voor fietsers";
    var Community_more_visible = "Het Bike Data Project biedt de mogelijkheid om fietsdata van verschillende applicaties te verzamelen in één platform, dat - gebaseerd op het principe van open source en open data - aanpasbaar en voor iedereen toegankelijk is om ervoor te zorgen dat het de samenleving ten goede komt.";
    var Globally_but_locally = "Er is weinig bekend over hoe fietsers zich vandaag in steden verplaatsen. Als er gegevens beschikbaar zijn, gaat het om gesloten en beperkte gegevens die worden verkocht door één app-provider of statische gegevens verzameld via handmatige tellingen. Als we meer mensen op de fiets willen en en de keuze voor de fiets net zo makkelijk en logisch willen maken als de auto, hebben we evenveel informatie nodig over het gedrag van fietsers als over autoverkeer.";
    var Informed_title = "Blijf op de hoogte";
    var Email_label = "E-mail";
    var Informed_placeholder = "Jouw e-mailadres";
    var Partners_title = "Projectpartners";
    var Footer_intro = "Bike Data Project is een project beheerd door Open Knowledge Belgium";
    var Footer_nav_title = "Informatie";
    var Footer_contact = "Contact";
    var Footer_street = "Cantersteen 12";
    var Footer_city = "1000 Brussels";
    var Footer_copyright_one = "Tenzij anders vermeld, is de inhoud van deze site gelicentieerd onder een";
    var Footer_copyright_two = "Creative Commons Attribution 4.0 International License";
    var Terms_of_use = "Gebruiksvoorwaarden";
    var Privacy_policy = "Privacybeleid";
    var Cookie_policy = "Cookiebeleid";
    var Help = "Help";
    var Contribute_big = "Bijdragen";
    var Data = "Data";
    var Power = "Slagkracht";
    var Partners = "Partners";
    var About_us = "Over";
    var Faq = "Faq";
    var Contact_us = "Contact";
    var Cookies = "Cookies";
    var Privacy = "Privacy";
    var Terms = "Voorwaarden";
    var Map_title = "De data";
    var Data_content_one = "Scroll naar beneden om de kaart te verkennen met alle fietsgegevens die tot nu toe zijn verzameld.";
    var Data_content_two = "De data van dit project is afkomstig van allerlei verschillende soorten fietsers. Alle individuele fietsgegevens worden samengevoegd tot collectieve gegevens. De collectieve gegevens geven ons patronen waarmee we kunnen laten zien waar en wanneer fietsers zich verplaatsen.";
    var Data_content_three = "De anonieme geaggregeerde fietsdata worden als open data voor het publiek opengesteld. De open data van het Bike Data Project platform kunnen vrij worden gebruikt door verschillende belanghebbenden en doeleinden. Hier is een niet-exhaustieve lijst van verschillende gebruikstoepassingen van de open data:";
    var Data_content_listOne = "Transportexperts, stadsplanners, mobiliteitsplanners en stedenbouwkundigen over de hele wereld hebben dergelijke open data nodig om hen te helpen bij het ontwikkelen van moderne infrastructuur en duurzame steden.";
    var Data_content_listTwo = "Burgers kunnen een overzicht krijgen van het aantal fietsers en gefietste kilometers in hun buurt en een kaart bekijken met het aantal fietsers per route.";
    var Data_content_listThree = "Het maatschappelijk middenveld en journalisten gebruiken de data om de situatie van fietsers te analyseren, zoals de tijd die fietsers gemiddeld verliezen bij verkeerslichten.";
    var Data_content_listFour = "Data- en softwarebedrijven kunnen in de data duiken om slimme fietsinzichten te verkrijgen en tools te bouwen zoals geavanceerde fietsrouteplanners en aanbevelingsmotoren om de fietsinfrastructuur te verbeteren. De gegevens kunnen ook nuttig zijn voor andere fietsgerelateerde producten en diensten.";
    var Data_content_four = "Alle geaggregeerde fietsgegevens zullen vanaf eind oktober 2020 beschikbaar zijn als open data. Voorlopig kun je bijdragen aan het project door je fietsgegevens te delen.";
    var Map_subtitle = "Bekijk onze open source code";
    var About_title = "Over het Bike Data Project";
    var About_intro = "Met het Bike Data Project wil Open Knowledge Belgium - de koepelorganisatie voor open kennis en open data-initiatieven in België - een community-driven open fietsdataplatform aanbieden dat data verzamelt over waar en wanneer mensen fietsen. Het project heeft tot doel gegevens van fietsers, afkomstig van verschillende mobiele applicaties en bronnen, samen te voegen tot één open fietsdataplatform. De collectieve open data zullen lokale gemeenschappen in staat stellen om fietsen zichtbaarder te maken en besluitvormers de mogelijkheid bieden om steden leefbaarder en fietsvriendelijker te maken.";
    var About_titleOne = "Korte geschiedenis: wie zit er achter het project";
    var About_contentOne_oneBefore = "Het Bike Data Project is in eerste instantie opgezet door";
    var About_contentOne_oneMiddle = "en gelanceerd als onderdeel van de release van de ";
    var About_contentOne_oneAfter = ", geregisseerd door Fredrik Gertten. Doordat de documentaire in meer dan 50 landen is vertoond, zijn er al meer dan 275.000 verzamelde fietsritten verzameld.";
    var About_contentOne_twoBefore = "Begin 2020 werd het project ondergebracht bij Open Knowledge Belgium.";
    var About_contentOne_twoAfter = "is een non-profit organisatie en officiële afdeling van Open Knowledge International die aan de hand van activiteiten en projecten bijdraagt tot een wereld waar kennis kansen creëert voor velen, niet voor enkelen. De organisatie beschikt over een grote groep vrijwilligers die door middel van technologie, onderzoek, community-gedreven bijeenkomsten en projecten bijdragen tot het gebruik en delen van open kennis in België en daarbuiten.";
    var About_contentOne_three = "Open Knowledge Belgium staat in voor de openheid van het project voor alle doeleinden en neemt alle nodige maatregelen volgens de GDPR-regelgeving inzake gegevensprivacy en -bescherming. Met een transparante en duidelijke gebruiksvoorwaarden voor dit project wil Open Knowledge Belgium een ​​voorbeeld stellen in hoe om te gaan met privacygerelateerde kwesties en van de gelegenheid gebruik maken om burgers te informeren over hun digitale rechten.";
    var About_titleTwo = "Meer fietsgegevens betekent meer slagkracht door en voor fietsers";
    var About_contentTwo_one = "Er is weinig bekend over hoe fietsers zich vandaag in steden verplaatsen. Als er gegevens beschikbaar zijn, gaat het om gesloten en beperkte gegevens die worden verkocht door één app-provider of statische gegevens verzameld via handmatige tellingen. Als we meer mensen op de fiets willen en en de keuze voor de fiets net zo makkelijk en logisch willen maken als de auto, hebben we evenveel informatie nodig over het gedrag van fietsers als over autoverkeer.";
    var About_contentTwo_two = "Open Knowledge Belgium wil impact creëren door te laten zien waar en wanneer mensen fietsen. Het Bike Data Project biedt de mogelijkheid om alle fietsdata van verschillende applicaties te verzamelen op één platform, dat - gebaseerd is op het principe van open source en open gegevens - aanpasbaar en toegankelijk voor iedereen om ervoor te zorgen dat ze de samenleving ten goede komen.";
    var About_titleThree = "Openbare digitale infrastructuur als gemeengoed";
    var About_contentThree_one = "Vergelijkbaar met activiteiten zoals OpenStreetMap Belgium en Open Planner Team door Open Knowledge Belgium, is het Bike Data Project opgezet als een collaboratief project dat openstaat voor iedereen en dat de samenleving als geheel ten goede komt. Vandaar zijn de digitale infrastructuur en geaggregeerde data - gebaseerd op de principes van open source en open data - vrij aanpasbaar en voor iedereen toegankelijk.";
    var About_contentThree_two = "Bovendien streeft Open Knowledge Belgium ernaar om met dit Bike Data Project een belangrijke rol te spelen in bredere maatschappelijke bewegingen:";
    var About_contentThree_listOneBold = "Burgers kunnen de controle over hun data terugnemen";
    var About_contentThree_listOne = "dankzij de sterke Europese GDPR-wetgeving. In het geval van het Bike Data Project willen we burgers aanmoedigen om hun gegevens uit apps van derden te halen (bijv. Populaire apps zoals Strava en mogelijk zelfs Google Maps) en hen vragen om ze bij te dragen aan een goed doel.";
    var About_contentThree_listTwoBold = "Bevorderen van het delen van expertise en leren binnen de community";
    var About_contentThree_listTwo = "gedurende het hele proces van de datainzameling tot de verdere ontwikkeling van het platform. Sterk geïnspireerd door het werk van de School of Data in Riga, willen we de fietsgemeenschap vanaf de eerste dag betrekken bij de lokale Bike Data Project campagnes. Met een reeks community-gedreven evenementen wil Open Knowledge Belgium werk maken van meer datageletterdheid.";
    var About_contentThree_listThreeBold = "Denk globaal, handel lokaal.";
    var About_contentThree_listThree = "Het Bike Data Project platform is is van opzet globaal en open. Hoewel het voor fietsgemeenschappen over de hele wereld mogelijk is om bij te dragen aan het project, wil Open Knowledge Belgium de lokale gemeenschappen ondersteunen door hen op lokaal niveau te laten handelen.";
    var About_titleFour = "Duurzaamheid van het Bike Data Project op langere termijn";
    var About_contentFour = "Open Knowledge Belgium werkt samen met Brussel Mobiliteit om, als onderdeel van het Bike for Brussels-programma, een eerste campagne te lanceren in het Brussels Hoofdstedelijk Gewest. De lancering van lokale dataverzamelingsacties in verschillende steden en de opzet van het open dataplatform maken deel uit van een langeretermijnplan voor het Bike Data Project. Wanneer een dataverzamelingsactie in een specifieke stad of regio ten einde loopt, blijft het platform online en wordt het onderhouden door de open source community van Open Knowledge Belgium. Fietscommunities in andere steden zullen worden aangemoedigd om een ​​campagne te lanceren in hun steden en gebruik te maken van het platform. Gezien de interesse van verschillende stakeholders in het Bike Data Platform, heeft Open Knowledge Belgium al de bevestiging gekregen van verschillende stakeholders dat ze financieel willen bijdragen aan de project zodat de serverkosten kunnen worden gedekt. ​​Op die manier blijft het project op langere termijn in stand.";
    var Faq_title = "Veelgestelde vragen";
    var Question_one_title = "Waarom zou ik deelnemen aan dit project?";
    var Question_one_answerOne = "Door jouw fietsgegevens bij te dragen, kan je de ontwikkeling van meer fietsvriendelijke steden mogelijk maken.";
    var Question_one_answerTwo = "Meer fietsgegevens betekent meer slagkracht door en voor fietsers. Er is weinig bekend over hoe fietsers zich vandaag in steden verplaatsen. Als er gegevens beschikbaar zijn, gaat het om gesloten en beperkte gegevens die worden verkocht door één app-provider of statische gegevens verzameld via handmatige tellingen. Als we meer mensen op de fiets willen en en de keuze voor de fiets net zo makkelijk en logisch willen maken als de auto, hebben we evenveel informatie nodig over het gedrag van fietsers als over autoverkeer.";
    var Question_two_title = "Hoe werkt dit project?";
    var Question_two_answerOne = "Voor dit project willen we je vragen om je fietsgegevens bij te dragen. We moeten weten waar er wordt gefietst. Jouw gegevensbijdragen, gecombineerd met de gegevens van veel andere fietsers, zullen steden geschikter maken voor fietsers.";
    var Question_two_answerTwo = "We vragen verschillende soorten fietsers (bijv. pendelaars, bezorgers, sporters en toeristen) om hun fietsritten te registreren via hun favoriete mobiele applicatie en hun gegevens bij te dragen aan ons community-gedreven fietsdataplatform. Elke soort fietser heeft iets bij te dragen aan dit project. Sommige mensen houden hun activiteit al bij voor trainingsdoeleinden. Dat is mooi, maar we willen ook echt rekening houden met de korte routes: pendelen naar het werk, de kinderen naar school brengen of voor een snelle rit naar de supermarkt.";
    var Question_two_answerThree = "In ruil daarvoor worden de anonieme geaggregeerde fietsgegevens opengesteld voor het publiek en kunnen ze door iedereen vrij worden gebruikt. We willen impact creëren door te laten zien waar en wanneer mensen fietsen. Meer gegevens betekent meer invloed op beslissingsnemers om steden duurzamer en fietsvriendelijker te maken.";
    var Question_three_title = "Hoe draag ik mijn gegevens bij aan het platform?";
    var Question_three_answer = "Je kan eenvoudigweg je bestaande fietsapp verbinden met het Bike Data Project-platform. Momenteel kan je je Strava-account koppelen of je Garmin-bestanden uploaden, maar we werken ook aan de integratie van andere fietsapps. Zodra jouw app is verbonden, kan je gewoon doorgaan zoals je gewend bent en worden jouw ritten automatisch geüpload naar het Bike Data Project-platform. Als je nog geen fietsapp gebruikt, kan je binnenkort onze eigen app gebruiken. Met de Bike Data Project-app hoef je geen account aan te maken, maar kun je je gegevens anoniem delen met het platform.";
    var Question_four_title = "Wat gebeurt er met mijn gegevens?";
    var Question_four_answerOne = "Alle individuele fietsgegevens worden samengevoegd tot anonieme collectieve gegevens. De collectieve gegevens geven ons patronen waarmee we kunnen laten zien waar en wanneer fietsers zich verplaatsen.";
    var Question_four_answerTwo = "De anonieme geaggregeerde fietsgegevens worden als open data voor het publiek toegankelijk gemaakt. De open data van het Bike Data Project platform kunnen vrij worden gebruikt door verschillende belanghebbenden en doeleinden. Hier is een niet-exhaustieve lijst van verschillende gebruikstoepassingen van de open data:";
    var Question_four_answerThree = "Vervoersdeskundigen, stadsplanners, mobiliteitsplanners en stedenbouwkundigen over de hele wereld hebben open data nodig om hen te helpen moderne infrastructuur en duurzame steden te ontwikkelen.";
    var Question_four_answerFour = "Burgers kunnen een overzicht krijgen van het aantal fietsers en gefietste kilometers, en een kaart bekijken met het aantal fietsers per route.";
    var Question_four_answerFive = "Het maatschappelijk middenveld en journalisten gebruiken de gegevens om de situatie van fietsers in de stad te analyseren, zoals de tijd die fietsers gemiddeld verliezen bij verkeerslichten.";
    var Question_four_answerSix = "Data- en softwarebedrijven kunnen in de data duiken om slimme fietsinzichten te verkrijgen en tools bouwen zoals geavanceerde fietsrouteplanners en aanbevelingsmotoren om de fietsinfrastructuur te verbeteren. De gegevens kunnen ook erg handig zijn voor andere fietsgerelateerde producten en diensten.";
    var Question_four_answerSeven = "Alle geaggregeerde fietsgegevens zullen eind oktober 2020 beschikbaar zijn als open data. Voorlopig kun je bijdragen aan het project door je fietsgegevens te delen.";
    var Question_five_title = "Wordt mijn privacy gerespecteerd wanneer ik mijn gegevens deel?";
    var Question_five_answerOne = "Ja, Open Knowledge Belgium garandeert de openheid van het project en neemt alle nodige maatregelen volgens de GDPR-regelgeving inzake gegevensbescherming.";
    var Question_five_answerTwo = "We verzamelen fietsgegevens van veel individuele fietsers en streven ernaar om de anonieme verzamelde gegevens als open data beschikbaar te maken voor het publiek. De verzamelde gegevens worden gepubliceerd op een manier dat het niet mogelijk is om persoonlijke gegevens van een individuele fietser te achterhalen.";
    var Question_five_answerThree = "Het publiceren van de gegevens zal gebeuren volgens het concept van differentiële privacy, een methode voor het openbaar delen van informatie over een dataset door de patronen van groepen binnen de dataset te beschrijven, terwijl informatie over individuen in de dataset achterblijft. Dit betekent in feite dat gegevens worden alleen gepubliceerd als de informatie van een bepaald individu niet kan worden achtergehaald.";
    var Question_six_title = "Kan ik mijn gegevens verwijderen?";
    var Question_six_answer = "Ja! Hoewel je je gegevens op een anonieme manier bijdraagt (we vragen niet om uw naam of enige andere informatie die je identificeert), kan je ons vragen om je gegevens uit het Bike Data Project platform te halen. Wil je dit doen, stuur ons dan een e-mail naar bikedataproject@openknowledge.be met de naam van de app waarmee je je gegevens hebt verstrekt en, indien mogelijk, ook het ID-nummer dat aan je profiel in de app is gekoppeld.";
    var Question_seven_title = "Welke gegevens deel ik vanuit mijn app?";
    var Question_seven_answer = "We willen je vooral vragen om de gegevens over jouw fietsactiviteiten bij te dragen, meer specifiek waar en wanneer je fietst. Daarnaast is er de mogelijkheid om informatie te delen over jouw geslacht, leeftijd, type fiets en de reden van jouw fietsrit (vrije tijd, sport, woon-werkverkeer, ...).";
    var Question_eight_title = "Hoe krijg ik toegang tot de open data?";
    var Question_eight_answerOne = "De anonieme geaggregeerde fietsgegevens worden als open data voor het publiek toegankelijk gemaakt. De open data van het Bike Data Project platform kunnen vrij worden gebruikt door verschillende belanghebbenden en doeleinden.";
    var Question_eight_answerTwo = "Alle geaggregeerde fietsgegevens zijn eind oktober 2020 beschikbaar als open data. Voorlopig kun je bijdragen aan het project door je fietsgegevens te delen.";
    var Question_nine_title = "Ik zou graag meer betrokken willen zijn bij dit project - hoe kan ik helpen?";
    var Question_nine_answer = "Dat is geweldig! Voel je vrij om lid te worden van onze Slack groep (https://join.slack.com/t/bikedataproject/sharedinvite/zt-g60t5w5c-lT2ucV0HtLEVnE4wG9hTg) en stel jezelf daar voor. We horen graag hoe je wil bijdragen aan het project!";
    var Contact_title = "Contact";
    var Further_questions = "Voor verdere vragen of informatie kan je contact met ons opnemen via:";
    var Follow_socials = "Volg het Bike Data Project via onze social media kanalen:";
    var Cookies_title = "Cookiebeleid";
    var What_are_cookies = "1. Wat zijn cookies";
    var Cookies_section_one = "Cookies zijn kleine bestanden die naar uw computer worden gedownload om uw ervaring te verbeteren. Op deze pagina wordt beschreven welke informatie ze verzamelen, hoe we deze gebruiken en waarom we deze cookies soms moeten opslaan. We zullen ook delen hoe u kunt voorkomen dat deze cookies worden opgeslagen. Dit kan echter bepaalde elementen van de sitefunctionaliteit beperken of \"breken\". Voor meer algemene informatie over cookies";
    var Cookies_section_oneLink = "zie dit Wikipedia-artikel over HTTP-cookies.";
    var How_we_use_cookies = "2. Hoe we cookies gebruiken";
    var Cookies_section_two = "We gebruiken cookies om verschillende redenen die hieronder worden beschreven. Helaas zijn er in de meeste gevallen geen standaardopties voor het uitschakelen van cookies zonder de functionaliteit en functies die ze aan deze site toevoegen volledig uit te schakelen. Het wordt aanbevolen dat u alle cookies laat staan ​​als u niet zeker weet of u ze nodig heeft of niet, voor het geval ze worden gebruikt om een ​​dienst te leveren die u gebruikt.";
    var Disabling_cookies = "3. Cookies uitschakelen";
    var Cookies_section_three = "U kunt voorkomen dat cookies worden gedownload door uw browserinstellingen aan te passen (zie het helpmenu van uw browser om te zien hoe u dit moet doen). Houd er rekening mee dat het uitschakelen van cookies de functionaliteit van deze en vele andere websites die u bezoekt, kan beïnvloeden. Het uitschakelen van cookies zal meestal resulteren in het uitschakelen van bepaalde functies en functies van deze site. Als u cookies wilt uitschakelen, raden we u aan om";
    var Cookies_section_threeLink = "op Firefox.";
    var Cookies_we_set = "4. Cookies die we plaatsen";
    var Cookies_section_fourOne = "Onze website bevat een inschrijvingsmodule voor de nieuwsbrief en cookies kunnen worden gebruikt om te onthouden of u al bent geregistreerd en of u bepaalde meldingen wilt weergeven die mogelijk alleen geldig zijn voor aangemelde / niet-geabonneerde gebruikers.";
    var Cookies_section_fourTwo = "Om u een geweldige ervaring op deze site te bieden, bieden we de functionaliteit om de taal in te stellen op basis van de taal die u in uw browser gebruikt. Om uw voorkeuren te onthouden, moeten we cookies instellen, zodat deze informatie kan worden opgeroepen wanneer u een pagina bezoekt die wordt beïnvloed door uw voorkeuren.";
    var Third_party_cookies = "5. Cookies van derden";
    var Cookies_section_five = "Onze site maakt geen gebruik van cookies van derden.";
    var More_information = "6. Meer informatie";
    var Cookies_section_six = "Zoals eerder vermeld, is het, als er iets is waarvan je niet zeker weet of je het nodig hebt of niet, meestal veiliger om cookies ingeschakeld te laten - voor het geval dat het een interactie aangaat met een van de functies die je op onze site gebruikt. Als u op zoek bent naar meer informatie, kunt u contact met ons opnemen via ";
    var Privacy_title = "Privacybeleid";
    var Privacy_introOne = "Verantwoordelijk voor de verwerking van de gegevens en eigenaar";
    var Privacy_introTwo = "Bike Data Project met Open Knowledge Belgium als juridische entiteit, een non-profitorganisatie, opgericht en bestaande naar Belgisch recht, met maatschappelijke zetel te 12 Cantersteen 1000 Brussel, België, met ondernemingsnummer 0845.419.930.";
    var Privacy_policy_section = "1. Privacybeleid";
    var Privacy_section_one = "Dit ‘Privacybeleid’ is van toepassing op de ‘persoonlijke gegevens’ die door Bike Data Project via deze website worden verzameld.";
    var What_does_personal = "2. Wat wordt bedoeld met persoonlijke gegevens?";
    var Privacy_section_two = "In dit privacybeleid verwijst persoonsgegevens naar informatie waarmee u geïdentificeerd kunt worden. Een identificeerbare persoon is iemand die direct of indirect kan worden geïdentificeerd, in het bijzonder door te verwijzen naar een identificatienummer of naar een of meer factoren die verband houden met fysieke, fysiologische, mentale, economische, culturele of sociale identiteit. Een typisch voorbeeld van persoonlijke informatie is uw naam en e-mailadres.";
    var What_personal_data = "3. Welke persoonlijke gegevens verzamelen we?";
    var Privacy_section_three = "We kunnen uw persoonlijke gegevens verzamelen uit de volgende bronnen:";
    var Privacy_section_threeOne = "3.1 Persoonsgegevens die u verstrekt tijdens het gegevensinbrengproces op het platform.";
    var Privacy_section_threeOne_pointOne = "Gegevens over je openbare profiel in je favoriete fietsapp (verplicht)";
    var Privacy_section_threeOne_pointTwo = "Gegevens over je privé fietsactiviteiten in je favoriete fietsapp (verplicht)";
    var Privacy_section_threeOne_pointThree = "Uw toestemming voor deze voorwaarden";
    var Privacy_section_threeTwo = "3.2 Persoonsgegevens die we verzamelen wanneer u onze website bezoekt.";
    var Privacy_section_threeTwo_content = "We gebruiken cookies om automatisch persoonlijke gegevens over u te verzamelen wanneer u deze website gebruikt. Raadpleeg ons Cookiebeleid voor meer informatie.";
    var Privacy_section_threeThree = "3.3. Persoonsgegevens die u verstrekt bij het delen van uw fietsgegevens";
    var Privacy_section_threeThree_pointOne = "Uw fietsritten (verplicht)";
    var Privacy_section_threeThree_pointTwo = "Uw leeftijdscategorie (optioneel)";
    var Privacy_section_threeThree_pointThree = "Uw geslacht (optioneel)";
    var Privacy_section_threeThree_pointFour = "Het doel van uw fietstocht (optioneel)";
    var Privacy_section_threeThree_pointFive = "Uw type fiets (optioneel)";
    var How_use_personal_data = "4. Hoe gebruiken we persoonsgegevens?";
    var Privacy_section_fourOne = "We verzamelen fietsgegevens van veel individuele fietsers en streven ernaar de anonieme geaggregeerde gegevens als open data beschikbaar te maken voor het publiek. De geaggregeerde gegevens worden zo gepubliceerd dat het niet mogelijk is om persoonlijke informatie van een individuele fietser te achterhalen.";
    var Privacy_section_fourTwo = "Het publiceren van de gegevens zal gebeuren volgens het concept van differentiële privacy, een methode voor het openbaar delen van informatie over een dataset door de patronen van groepen binnen de dataset te beschrijven, terwijl informatie over individuen in de dataset achterblijft. Dit betekent in feite dat gegevens worden alleen gepubliceerd als de informatie van een bepaald individu niet kan worden achtergehaald.";
    var Privacy_section_fourThree = "De persoonsgegevens worden alleen opgeslagen en verwerkt gedurende de periode die nodig is voor het doel van de verwerking. Daarna worden de gegevens verwijderd of geanonimiseerd. Bike Data Project vertrouwt op DigitalOcean dat is gecertificeerd volgens de belangrijkste privacy- en beveiligingsnormen. DigitalOcean services voldoen aan de GDPR-wetgeving.";
    var With_whom_do = "5. Met wie delen we uw persoonsgegevens?";
    var Privacy_section_five = "Uw persoonlijke gegevens worden niet gedeeld met derden. We zullen uw persoonlijke gegevens nooit verkopen of verhuren aan andere dienstverleners, noch zullen we uw persoonlijke gegevens delen met dienstverleners die niet voldoen aan de GDPR-wetgeving.";
    var Where_do_we_transfer = "6. Waar transfereren we uw persoonsgegevens naartoe?";
    var Privacy_section_six = "We geven uw persoonsgegevens alleen door aan dienstverleners die buiten de Europese Economische Ruimte zijn gevestigd als ze voldoen aan art 44 GDPR.";
    var Automated_decision = "7. Geautomatiseerde besluitvorming en profilering";
    var Privacy_section_seven = "De verwerking van uw persoonsgegevens omvat geen profilering en zal niet worden onderworpen aan geautomatiseerde besluitvorming voor het Bike Data Project.";
    var What_rights_do = "8. Welke rechten heeft u?";
    var Privacy_section_eight = "U heeft te allen tijde het recht om uw persoonsgegevens in te zien, evenals het recht om geïnformeerd te worden over het gebruik dat Bike Data Project van uw persoonsgegevens maakt.";
    var Privacy_section_eightOne = "1. Recht op rectificatie, verwijdering en beperking van de verwerking";
    var Privacy_section_eightOne_content = "Het staat u vrij om al dan niet uw persoonsgegevens aan Bike Data Project te verstrekken. Daarnaast heb je altijd het recht om jouw persoonsgegevens bij Bike Data Project te wijzigen, aan te vullen of te verwijderen. U erkent dat een weigering om persoonsgegevens te verstrekken of een verzoek tot verwijdering van persoonsgegevens betekent dat bepaalde diensten niet meer geleverd kunnen worden. U kunt ook verzoeken om beperking van de verwerking van uw persoonsgegevens.";
    var Privacy_section_eightTwo = "2. Recht op bezwaar";
    var Privacy_section_eightTwo_content = "U heeft het recht om bezwaar te maken tegen de verwerking van uw persoonsgegevens, zolang dit om ernstige en legitieme redenen is.";
    var Privacy_section_eightThree = "3. Recht op overdraagbaarheid van gegevens";
    var Privacy_section_eightThree_content = "Je hebt het recht om de persoonsgegevens die u aan het Bike Data Project hebt verstrekt in een gestructureerde, typische en machineleesbare vorm te verkrijgen en / of over te dragen aan verschillende verwerkingsverantwoordelijken.";
    var Privacy_section_eightFour = "4. Recht om toestemming in te trekken";
    var Privacy_section_eightFour_content = "Voor zover de verwerking is gebaseerd op uw voorafgaande toestemming, heeft u het recht om deze toestemming in te trekken.";
    var Privacy_section_eightFive = "5. Recht om een ​​klacht in te dienen";
    var Privacy_section_eightFive_content = "U hebt het recht om een ​​klacht in te dienen bij de Belgische Privacycommissie: Persoonlijke Privacycommissie, Drukpersstraat 35, 1000 Brussel, België, Tel. +32 (0) 2274 48 00, Fax +32 (0) 2274 48 35, e-mail: commission@privacycommission.be. Dit heeft geen invloed op de voorziening voor een burgerlijke rechtbank.";
    var Exercising_your_rights = "9. Uitoefening van uw rechten";
    var Privacy_section_nine = "U kunt uw rechten uitoefenen door hiervoor contact op te nemen met het Bike Data Project door een e-mail te sturen naar bikedataproject@openknowledge.be, op voorwaarde dat u een kopie van uw identiteitskaart meestuurt.";
    var Additional_info = "Aanvullende informatie over het verzamelen en verwerken van gegevens";
    var Legal_procedures = "Juridische procedures";
    var Legal_procedures_contentOne = "De Verwerker en de Verantwoordelijke voor de verwerking van de Gegevens kunnen de Persoonsgegevens van de Gebruiker gebruiken voor juridische doeleinden, voor de rechtbank of gerechtelijke procedures in geval van onrechtmatig gebruik van deze Applicatie of de gerelateerde diensten.";
    var Legal_procedures_contentTwo = "De Gebruiker is zich ervan bewust dat de Verwerker en de Gegevensbeheerder mogelijk verplicht zijn om de persoonsgegevens vrij te geven op verzoek van bevoegde overheidsinstanties voor de verwerking van de Gegevens.";
    var Security_measures = "Beveiligingsmaatregelen";
    var Security_measures_contentOne = "Bike Data Project heeft beveiligingsmaatregelen ontwikkeld die op technologisch en organisatorisch niveau zijn aangepast om vernietiging, verlies, vervalsing, wijziging, verboden toegang of de foutieve bekendmaking aan derden van persoonsgegevens en elke andere verboden verwerking te voorkomen van deze gegevens.";
    var Security_measures_contentTwo = "Bike Data Project kan in geen geval aansprakelijk worden gesteld voor enige directe of indirecte schade die het gevolg is van het onjuist of onrechtmatig gebruik van uw persoonsgegevens door een derde partij.";
    var Security_measures_contentThree = "U dient zich te allen tijde te houden aan de veiligheidsinstructies, waaronder het voorkomen van alle verboden toegang tot uw inloggegevens inclusief uw wachtwoord. U bent als enige verantwoordelijk voor het gebruik van de website op uw computer, vanaf uw IP-adres en met uw identificatiegegevens, evenals voor het vertrouwelijk houden van deze.";
    var Definitions_legal_framework = "Definities en wettelijk kader";
    var Personal_data = "Persoonlijke gegevens (of gegevens)";
    var Personal_data_content = "Alle informatie betreffende een natuurlijke persoon, een rechtspersoon, een instelling of een vereniging die direct of indirect geïdentificeerd is of kan worden door middel van verwijzing naar andere informatie.";
    var Usage_data = "Gebruiksgegevens";
    var Usage_data_content = "Informatie die automatisch wordt verzameld via deze Applicatie (of externe services die in deze Applicatie worden gebruikt), inclusief: de IP-adressen of domeinnamen van de computers die worden gebruikt door de Gebruikers van deze Applicatie, de URI-adressen (Uniform Resource Identifier), het tijdstip van het verzoek, de methode die wordt gebruikt om het verzoek in te dienen bij de server, de grootte van het bestand dat erop wordt ontvangen, de numerieke code die de status van de serverreactie aangeeft (succesvol, fout, enz.), de functies van de browser en het besturingssysteem van de Gebruiker, de verschillende tijdgegevens per bezoek (zoals de tijd doorgebracht op elke pagina van de applicatie) en de gegevens die tijdens het gebruik van de applicatie worden verzameld (bijvoorbeeld: de volgorde van bezochte delen of andere parameters over het besturingssysteem van het apparaat).";
    var User = "Gebruiker";
    var User_content = "De persoon die deze Applicatie gebruikt en die akkoord moet gaan met of geautoriseerd moet zijn door de Betrokkene naar wie de Persoonsgegevens verwijzen.";
    var Person_concerned = "Betrokkene";
    var Person_concerned_content = "De rechtspersoon of natuurlijke persoon op wie de Persoonsgegevens betrekking hebben.";
    var Data_processor = "Gegevensverwerker (or Gegevenstoezichtshouder)";
    var Data_processor_content = "De natuurlijke persoon, rechtspersoon, overheidsadministratie of enige andere instelling, vereniging of organisatie die door de gegevensbeheerder is gemachtigd om de persoonsgegevens te verwerken in overeenstemming met dit privacybeleid.";
    var Responsible_processing = "Verantwoordelijk voor de verwerking van de gegevens (of eigenaar)";
    var Responsible_processing_content = "De natuurlijke persoon, rechtspersoon, overheidsadministratie of enige andere instelling, vereniging of organisatie die het recht heeft om, ook samen met de Verantwoordelijke voor de verwerking van de Gegevens, beslissingen te nemen over de doeleinden en methoden voor het verwerken van Persoonsgegevens en de middelen gebruikt, inclusief beveiligingsmaatregelen met betrekking tot de exploitatie en het gebruik van deze applicatie. De verantwoordelijke voor de verwerking van de gegevens is de eigenaar van deze applicatie, tenzij anders aangegeven.";
    var This_application = "Deze applicatie";
    var This_application_content = "De hardware of software tools waarmee de persoonlijke gegevens van de gebruiker worden verzameld.";
    var Cookie = "Cookie";
    var Cookie_content = "Klein stukje gegevens opgeslagen op het apparaat van de Gebruiker. Zie ons Cookiebeleid.";
    var Legal_information = "Juridische informatie";
    var Legal_information_content = "Kennisgeving aan Europese gebruikers: deze privacyverklaring is opgesteld met inachtneming van de verplichtingen in art. 10 van de Europese richtlijn 95/46 / EG en de bepalingen van de Europese richtlijn 2002/58 / EG, evenals de herziening in richtlijn 2009/136 / EG met betrekking tot cookies.";
    var Changes_privacy_policy = "Wijzigingen in dit privacybeleid";
    var Changes_privacy_policy_date = "Laatst bijgewerkt: 28 september 2020";
    var Changes_privacy_policy_content = "De verantwoordelijke voor de verwerking van de gegevens behoudt zich het recht voor om dit privacybeleid op elk moment te wijzigen door gebruikers op deze pagina op de hoogte te stellen. We raden u aan deze pagina te controleren op mogelijke wijzigingen. De datum van de laatste wijziging wordt aangegeven onderaan de pagina. Als een Gebruiker bezwaar maakt tegen enige wijziging in het beleid, mag de Gebruiker deze Applicatie niet blijven gebruiken. Men kan de Verwerkingsverantwoordelijke verzoeken om de Gegevens te verwerken om de Persoonsgegevens te verwijderen. Tenzij anders aangegeven, is het geldige privacybeleid dat op dat moment van toepassing is, van toepassing op alle persoonlijke gegevens die de verantwoordelijke heeft opgeslagen voor de verwerking van de gegevens over gebruikers.";
    var Terms_title = "Gebruiksvoorwaarden";
    var Terms_introOne = "Met het Bike Data Project biedt Open Knowledge Belgium - de koepelorganisatie voor open kennis en open data-initiatieven in België - een community-driven open fietsdataplatform dat data verzamelt over waar en wanneer er wordt gefietst.";
    var Terms_introTwo = "Het project heeft tot doel gegevens van fietsers, afkomstig van verschillende mobiele applicaties en bronnen, samen te voegen tot één open fietsdataplatform. De collectieve open data zullen lokale gemeenschappen in staat stellen om fietsen zichtbaarder te maken en besluitvormers de mogelijkheid bieden om steden leefbaarder en fietsvriendelijker te maken.";
    var Terms_introThree = "De deelname aan dit project en het gebruik van dit platform is onderworpen aan een aantal regels. Hieronder vindt u de algemene voorwaarden van het project, aangezien we ervan overtuigd zijn dat duidelijke regels de beste garantie bieden voor een respectvolle community.";
    var Terms_introFour = "Omdat Open Knowledge Belgium de feedback van de Bike Data Project community waardeert, verwelkomen we alle ideeën om het platform verder te verbeteren. U kunt uw suggesties e-mailen om";
    var Who_can_contribute = "Wie kan bijdragen aan het Bike Data Project en wie kan gebruik maken van de open data van het Bike Data Project?";
    var Who_can_contribute_contentOne = "Elke soort fietser kan bijdragen aan het project door fietsgegevens te delen. U kunt uw favoriete fietsapp koppelen om uw gegevens te delen of de Bike Data Project-app gebruiken om bij te dragen aan het Bike Data Project. Voor het gebruik van de app van het Bike Data Project hoeft u geen account aan te maken om de app te gebruiken, dus u en uw gedeelde fietsgegevens blijven anoniem.";
    var Who_can_contribute_contentTwo = "De anonieme geaggregeerde fietsdata worden als open data voor het publiek opengesteld. De open data van het Bike Data Project platform wordt gepubliceerd onder een Creative Commons Attribution 4.0 International Licentie, die geen beperkingen oplegt aan uw gebruik van de open data. U hoeft het Bike Data Project alleen op de juiste manier te vermelden door de naam van het project, copyrightmelding, licentiemelding, disclaimer en een link naar het platform op te geven.";
    var Limitation_of_liability = "Beperking van aansprakelijkheid";
    var Limitation_of_liability_contentOne = "Het Bike Data Project kan niet verantwoordelijk worden gehouden voor mislukkingen of vertragingen bij het gebruik van het platform. Het platform kan niet verantwoordelijk worden gehouden voor enige aansprakelijkheid in geval van persoonlijke schade door het gebruik ervan. U dient het Bike Data Project (en elk van zijn partners en / of vrijwilligers) te verdedigen, schadeloos te stellen en te vrijwaren tegen elke claim, eis, actie, schade, verlies, kosten of uitgave, inclusief maar niet beperkt tot redelijke advocaatkosten, die voortvloeien uit of met betrekking tot (a) uw gebruik van ons project; (b) alle ledeninhoud of inzendingen die u verstrekt; (c) uw schending van deze voorwaarden; (d) uw schending van rechten van een ander; of (e) uw gedrag in verband met de diensten. Verder, als u het project namens een entiteit gebruikt, verklaart en garandeert u dat een dergelijke entiteit ermee instemt u en het Bike Data Project schadeloos te stellen voor schendingen van deze voorwaarden in overeenstemming met deze sectie. Als u verplicht bent om ons schadeloos te stellen, hebben we het recht om, naar eigen goeddunken en onbeperkt, elke actie of procedure te controleren en te bepalen of we deze willen schikken, en zo ja, onder welke voorwaarden.";
    var Limitation_of_liability_contentTwo = "Wij geloven sterk in vrijheid van meningsuiting. Om er echter voor te zorgen dat het platform op een constructieve manier gebruikt kan worden door de gebruikers, met respect voor verschillende meningen en zonder dat mensen bang hoeven te zijn om deel te nemen aan het project, staan ​​wij geen aanstootgevend gedrag toe dat intimideert, intimideert of gebruikt angst om een ​​andere gebruiker het zwijgen op te leggen.";
    var Spam = "Spam";
    var Spam_contentOne = "We streven er te allen tijde naar om de gebruiker van het Bike Data Project platform te beschermen tegen technisch misbruik en spam. Accounts die worden gebruikt om de onderstaande acties uit te voeren, kunnen tijdelijk worden geblokkeerd of permanent worden verwijderd.";
    var Spam_contentTwo = "Malware / phishing / virussen / wormen / Trojaanse paarden: u mag geen schadelijke inhoud of links naar dergelijke inhoud plaatsen met als doel de browsers of computers van iemand anders te beschadigen of te verstoren, of om iemands privacy te schenden. Spam: het is niet toegestaan ​​om gebruik het Bike Data Project-platform om mensen te spammen.";
    var Infringement = "Inbreuk op toepasselijke wetgeving";
    var Infringement_contentOne = "Het gebruik van het account mag op geen enkele manier in strijd zijn met de toepasselijke wetgeving. Dit omvat inbreuken op de privacywetgeving, intellectuele eigendomsrechten, het wetboek van strafrecht, enz. Het account mag op geen enkele manier worden gebruikt om illegale activiteiten te promoten.";
    var Infringement_contentTwo = "Het account mag op geen enkele manier worden gebruikt om illegale activiteiten te promoten.";
    var Breaches_aforementioned_rules = "In geval van overtreding van de bovengenoemde regels";
    var Breaches_aforementioned_rules_content = "Het kan voorkomen dat via het platform schadelijke bestanden gedownload kunnen worden, al dan niet door een gebruiker, of dat gebruikers schadelijke hyperlinks plaatsen. Elke download door een gebruiker of het klikken op een hyperlink, geplaatst door een gebruiker, gebeurt op eigen risico van de gebruiker. Eventuele opgelopen schade is volledig en uitsluitend de verantwoordelijkheid van deze gebruiker.";
    var Property_rights = "Eigendomsrechten Bike Data Project";
    var Property_rights_content = "De broncode van het Bike Data Project is gepubliceerd onder een open source MIT-licentie. U gaat ermee akkoord gebonden te zijn aan en te voldoen aan alle licentieovereenkomsten die van toepassing zijn op deze open source software. De visuele identiteit, inclusief het logo en de kleuren, is beschikbaar onder CC BY 4.0. De naam van het Bike Data Project kan niet worden gebruikt of gerepliceerd.";
    var Thanks_Bigletter = "Bedankt";
    var Thanks_Fitbit_title = "Bedankt om je Fitbit account te verbinden!";
    var Thanks_Content1 = "Je Fitbit account is nu verbonden met het Bike Data Project.";
    var Thanks_Content2 = "Je fiets ritten worden nu automatisch gedeeld met een Bike Data Project als je je Fitbit gebruikt tijdens het fietsen.";
    var nl = {
    	Contribute: Contribute,
    	The_data: The_data,
    	About: About,
    	FAQ: FAQ,
    	Contact: Contact,
    	Heading: Heading,
    	Introduction: Introduction,
    	Label_total_km: Label_total_km,
    	Help_title: Help_title,
    	Ask_for_favor: Ask_for_favor,
    	By_sharing_your: By_sharing_your,
    	Every_cyclist_can: Every_cyclist_can,
    	Donate_title: Donate_title,
    	Several_ways_to_contribute: Several_ways_to_contribute,
    	You_not_using: You_not_using,
    	Connect_existing_account: Connect_existing_account,
    	Download_our_app: Download_our_app,
    	Data_title: Data_title,
    	Rides_collected: Rides_collected,
    	Distance_collected: Distance_collected,
    	Average_duration: Average_duration,
    	Average_speed: Average_speed,
    	Average_distance: Average_distance,
    	co2_saved: co2_saved,
    	Data_subtitle: Data_subtitle,
    	Data_button: Data_button,
    	Contribute_title: Contribute_title,
    	People_who_work: People_who_work,
    	Common_goal: Common_goal,
    	Visible_title: Visible_title,
    	Community_more_visible: Community_more_visible,
    	Globally_but_locally: Globally_but_locally,
    	Informed_title: Informed_title,
    	Email_label: Email_label,
    	Informed_placeholder: Informed_placeholder,
    	Partners_title: Partners_title,
    	Footer_intro: Footer_intro,
    	Footer_nav_title: Footer_nav_title,
    	Footer_contact: Footer_contact,
    	Footer_street: Footer_street,
    	Footer_city: Footer_city,
    	Footer_copyright_one: Footer_copyright_one,
    	Footer_copyright_two: Footer_copyright_two,
    	Terms_of_use: Terms_of_use,
    	Privacy_policy: Privacy_policy,
    	Cookie_policy: Cookie_policy,
    	Help: Help,
    	Contribute_big: Contribute_big,
    	Data: Data,
    	Power: Power,
    	Partners: Partners,
    	About_us: About_us,
    	Faq: Faq,
    	Contact_us: Contact_us,
    	Cookies: Cookies,
    	Privacy: Privacy,
    	Terms: Terms,
    	Map_title: Map_title,
    	Data_content_one: Data_content_one,
    	Data_content_two: Data_content_two,
    	Data_content_three: Data_content_three,
    	Data_content_listOne: Data_content_listOne,
    	Data_content_listTwo: Data_content_listTwo,
    	Data_content_listThree: Data_content_listThree,
    	Data_content_listFour: Data_content_listFour,
    	Data_content_four: Data_content_four,
    	Map_subtitle: Map_subtitle,
    	About_title: About_title,
    	About_intro: About_intro,
    	About_titleOne: About_titleOne,
    	About_contentOne_oneBefore: About_contentOne_oneBefore,
    	About_contentOne_oneMiddle: About_contentOne_oneMiddle,
    	About_contentOne_oneAfter: About_contentOne_oneAfter,
    	About_contentOne_twoBefore: About_contentOne_twoBefore,
    	About_contentOne_twoAfter: About_contentOne_twoAfter,
    	About_contentOne_three: About_contentOne_three,
    	About_titleTwo: About_titleTwo,
    	About_contentTwo_one: About_contentTwo_one,
    	About_contentTwo_two: About_contentTwo_two,
    	About_titleThree: About_titleThree,
    	About_contentThree_one: About_contentThree_one,
    	About_contentThree_two: About_contentThree_two,
    	About_contentThree_listOneBold: About_contentThree_listOneBold,
    	About_contentThree_listOne: About_contentThree_listOne,
    	About_contentThree_listTwoBold: About_contentThree_listTwoBold,
    	About_contentThree_listTwo: About_contentThree_listTwo,
    	About_contentThree_listThreeBold: About_contentThree_listThreeBold,
    	About_contentThree_listThree: About_contentThree_listThree,
    	About_titleFour: About_titleFour,
    	About_contentFour: About_contentFour,
    	Faq_title: Faq_title,
    	Question_one_title: Question_one_title,
    	Question_one_answerOne: Question_one_answerOne,
    	Question_one_answerTwo: Question_one_answerTwo,
    	Question_two_title: Question_two_title,
    	Question_two_answerOne: Question_two_answerOne,
    	Question_two_answerTwo: Question_two_answerTwo,
    	Question_two_answerThree: Question_two_answerThree,
    	Question_three_title: Question_three_title,
    	Question_three_answer: Question_three_answer,
    	Question_four_title: Question_four_title,
    	Question_four_answerOne: Question_four_answerOne,
    	Question_four_answerTwo: Question_four_answerTwo,
    	Question_four_answerThree: Question_four_answerThree,
    	Question_four_answerFour: Question_four_answerFour,
    	Question_four_answerFive: Question_four_answerFive,
    	Question_four_answerSix: Question_four_answerSix,
    	Question_four_answerSeven: Question_four_answerSeven,
    	Question_five_title: Question_five_title,
    	Question_five_answerOne: Question_five_answerOne,
    	Question_five_answerTwo: Question_five_answerTwo,
    	Question_five_answerThree: Question_five_answerThree,
    	Question_six_title: Question_six_title,
    	Question_six_answer: Question_six_answer,
    	Question_seven_title: Question_seven_title,
    	Question_seven_answer: Question_seven_answer,
    	Question_eight_title: Question_eight_title,
    	Question_eight_answerOne: Question_eight_answerOne,
    	Question_eight_answerTwo: Question_eight_answerTwo,
    	Question_nine_title: Question_nine_title,
    	Question_nine_answer: Question_nine_answer,
    	Contact_title: Contact_title,
    	Further_questions: Further_questions,
    	Follow_socials: Follow_socials,
    	Cookies_title: Cookies_title,
    	What_are_cookies: What_are_cookies,
    	Cookies_section_one: Cookies_section_one,
    	Cookies_section_oneLink: Cookies_section_oneLink,
    	How_we_use_cookies: How_we_use_cookies,
    	Cookies_section_two: Cookies_section_two,
    	Disabling_cookies: Disabling_cookies,
    	Cookies_section_three: Cookies_section_three,
    	Cookies_section_threeLink: Cookies_section_threeLink,
    	Cookies_we_set: Cookies_we_set,
    	Cookies_section_fourOne: Cookies_section_fourOne,
    	Cookies_section_fourTwo: Cookies_section_fourTwo,
    	Third_party_cookies: Third_party_cookies,
    	Cookies_section_five: Cookies_section_five,
    	More_information: More_information,
    	Cookies_section_six: Cookies_section_six,
    	Privacy_title: Privacy_title,
    	Privacy_introOne: Privacy_introOne,
    	Privacy_introTwo: Privacy_introTwo,
    	Privacy_policy_section: Privacy_policy_section,
    	Privacy_section_one: Privacy_section_one,
    	What_does_personal: What_does_personal,
    	Privacy_section_two: Privacy_section_two,
    	What_personal_data: What_personal_data,
    	Privacy_section_three: Privacy_section_three,
    	Privacy_section_threeOne: Privacy_section_threeOne,
    	Privacy_section_threeOne_pointOne: Privacy_section_threeOne_pointOne,
    	Privacy_section_threeOne_pointTwo: Privacy_section_threeOne_pointTwo,
    	Privacy_section_threeOne_pointThree: Privacy_section_threeOne_pointThree,
    	Privacy_section_threeTwo: Privacy_section_threeTwo,
    	Privacy_section_threeTwo_content: Privacy_section_threeTwo_content,
    	Privacy_section_threeThree: Privacy_section_threeThree,
    	Privacy_section_threeThree_pointOne: Privacy_section_threeThree_pointOne,
    	Privacy_section_threeThree_pointTwo: Privacy_section_threeThree_pointTwo,
    	Privacy_section_threeThree_pointThree: Privacy_section_threeThree_pointThree,
    	Privacy_section_threeThree_pointFour: Privacy_section_threeThree_pointFour,
    	Privacy_section_threeThree_pointFive: Privacy_section_threeThree_pointFive,
    	How_use_personal_data: How_use_personal_data,
    	Privacy_section_fourOne: Privacy_section_fourOne,
    	Privacy_section_fourTwo: Privacy_section_fourTwo,
    	Privacy_section_fourThree: Privacy_section_fourThree,
    	With_whom_do: With_whom_do,
    	Privacy_section_five: Privacy_section_five,
    	Where_do_we_transfer: Where_do_we_transfer,
    	Privacy_section_six: Privacy_section_six,
    	Automated_decision: Automated_decision,
    	Privacy_section_seven: Privacy_section_seven,
    	What_rights_do: What_rights_do,
    	Privacy_section_eight: Privacy_section_eight,
    	Privacy_section_eightOne: Privacy_section_eightOne,
    	Privacy_section_eightOne_content: Privacy_section_eightOne_content,
    	Privacy_section_eightTwo: Privacy_section_eightTwo,
    	Privacy_section_eightTwo_content: Privacy_section_eightTwo_content,
    	Privacy_section_eightThree: Privacy_section_eightThree,
    	Privacy_section_eightThree_content: Privacy_section_eightThree_content,
    	Privacy_section_eightFour: Privacy_section_eightFour,
    	Privacy_section_eightFour_content: Privacy_section_eightFour_content,
    	Privacy_section_eightFive: Privacy_section_eightFive,
    	Privacy_section_eightFive_content: Privacy_section_eightFive_content,
    	Exercising_your_rights: Exercising_your_rights,
    	Privacy_section_nine: Privacy_section_nine,
    	Additional_info: Additional_info,
    	Legal_procedures: Legal_procedures,
    	Legal_procedures_contentOne: Legal_procedures_contentOne,
    	Legal_procedures_contentTwo: Legal_procedures_contentTwo,
    	Security_measures: Security_measures,
    	Security_measures_contentOne: Security_measures_contentOne,
    	Security_measures_contentTwo: Security_measures_contentTwo,
    	Security_measures_contentThree: Security_measures_contentThree,
    	Definitions_legal_framework: Definitions_legal_framework,
    	Personal_data: Personal_data,
    	Personal_data_content: Personal_data_content,
    	Usage_data: Usage_data,
    	Usage_data_content: Usage_data_content,
    	User: User,
    	User_content: User_content,
    	Person_concerned: Person_concerned,
    	Person_concerned_content: Person_concerned_content,
    	Data_processor: Data_processor,
    	Data_processor_content: Data_processor_content,
    	Responsible_processing: Responsible_processing,
    	Responsible_processing_content: Responsible_processing_content,
    	This_application: This_application,
    	This_application_content: This_application_content,
    	Cookie: Cookie,
    	Cookie_content: Cookie_content,
    	Legal_information: Legal_information,
    	Legal_information_content: Legal_information_content,
    	Changes_privacy_policy: Changes_privacy_policy,
    	Changes_privacy_policy_date: Changes_privacy_policy_date,
    	Changes_privacy_policy_content: Changes_privacy_policy_content,
    	Terms_title: Terms_title,
    	Terms_introOne: Terms_introOne,
    	Terms_introTwo: Terms_introTwo,
    	Terms_introThree: Terms_introThree,
    	Terms_introFour: Terms_introFour,
    	Who_can_contribute: Who_can_contribute,
    	Who_can_contribute_contentOne: Who_can_contribute_contentOne,
    	Who_can_contribute_contentTwo: Who_can_contribute_contentTwo,
    	Limitation_of_liability: Limitation_of_liability,
    	Limitation_of_liability_contentOne: Limitation_of_liability_contentOne,
    	Limitation_of_liability_contentTwo: Limitation_of_liability_contentTwo,
    	Spam: Spam,
    	Spam_contentOne: Spam_contentOne,
    	Spam_contentTwo: Spam_contentTwo,
    	Infringement: Infringement,
    	Infringement_contentOne: Infringement_contentOne,
    	Infringement_contentTwo: Infringement_contentTwo,
    	Breaches_aforementioned_rules: Breaches_aforementioned_rules,
    	Breaches_aforementioned_rules_content: Breaches_aforementioned_rules_content,
    	Property_rights: Property_rights,
    	Property_rights_content: Property_rights_content,
    	Thanks_Bigletter: Thanks_Bigletter,
    	Thanks_Fitbit_title: Thanks_Fitbit_title,
    	Thanks_Content1: Thanks_Content1,
    	Thanks_Content2: Thanks_Content2
    };

    var nl$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Contribute: Contribute,
        The_data: The_data,
        About: About,
        FAQ: FAQ,
        Contact: Contact,
        Heading: Heading,
        Introduction: Introduction,
        Label_total_km: Label_total_km,
        Help_title: Help_title,
        Ask_for_favor: Ask_for_favor,
        By_sharing_your: By_sharing_your,
        Every_cyclist_can: Every_cyclist_can,
        Donate_title: Donate_title,
        Several_ways_to_contribute: Several_ways_to_contribute,
        You_not_using: You_not_using,
        Connect_existing_account: Connect_existing_account,
        Download_our_app: Download_our_app,
        Data_title: Data_title,
        Rides_collected: Rides_collected,
        Distance_collected: Distance_collected,
        Average_duration: Average_duration,
        Average_speed: Average_speed,
        Average_distance: Average_distance,
        co2_saved: co2_saved,
        Data_subtitle: Data_subtitle,
        Data_button: Data_button,
        Contribute_title: Contribute_title,
        People_who_work: People_who_work,
        Common_goal: Common_goal,
        Visible_title: Visible_title,
        Community_more_visible: Community_more_visible,
        Globally_but_locally: Globally_but_locally,
        Informed_title: Informed_title,
        Email_label: Email_label,
        Informed_placeholder: Informed_placeholder,
        Partners_title: Partners_title,
        Footer_intro: Footer_intro,
        Footer_nav_title: Footer_nav_title,
        Footer_contact: Footer_contact,
        Footer_street: Footer_street,
        Footer_city: Footer_city,
        Footer_copyright_one: Footer_copyright_one,
        Footer_copyright_two: Footer_copyright_two,
        Terms_of_use: Terms_of_use,
        Privacy_policy: Privacy_policy,
        Cookie_policy: Cookie_policy,
        Help: Help,
        Contribute_big: Contribute_big,
        Data: Data,
        Power: Power,
        Partners: Partners,
        About_us: About_us,
        Faq: Faq,
        Contact_us: Contact_us,
        Cookies: Cookies,
        Privacy: Privacy,
        Terms: Terms,
        Map_title: Map_title,
        Data_content_one: Data_content_one,
        Data_content_two: Data_content_two,
        Data_content_three: Data_content_three,
        Data_content_listOne: Data_content_listOne,
        Data_content_listTwo: Data_content_listTwo,
        Data_content_listThree: Data_content_listThree,
        Data_content_listFour: Data_content_listFour,
        Data_content_four: Data_content_four,
        Map_subtitle: Map_subtitle,
        About_title: About_title,
        About_intro: About_intro,
        About_titleOne: About_titleOne,
        About_contentOne_oneBefore: About_contentOne_oneBefore,
        About_contentOne_oneMiddle: About_contentOne_oneMiddle,
        About_contentOne_oneAfter: About_contentOne_oneAfter,
        About_contentOne_twoBefore: About_contentOne_twoBefore,
        About_contentOne_twoAfter: About_contentOne_twoAfter,
        About_contentOne_three: About_contentOne_three,
        About_titleTwo: About_titleTwo,
        About_contentTwo_one: About_contentTwo_one,
        About_contentTwo_two: About_contentTwo_two,
        About_titleThree: About_titleThree,
        About_contentThree_one: About_contentThree_one,
        About_contentThree_two: About_contentThree_two,
        About_contentThree_listOneBold: About_contentThree_listOneBold,
        About_contentThree_listOne: About_contentThree_listOne,
        About_contentThree_listTwoBold: About_contentThree_listTwoBold,
        About_contentThree_listTwo: About_contentThree_listTwo,
        About_contentThree_listThreeBold: About_contentThree_listThreeBold,
        About_contentThree_listThree: About_contentThree_listThree,
        About_titleFour: About_titleFour,
        About_contentFour: About_contentFour,
        Faq_title: Faq_title,
        Question_one_title: Question_one_title,
        Question_one_answerOne: Question_one_answerOne,
        Question_one_answerTwo: Question_one_answerTwo,
        Question_two_title: Question_two_title,
        Question_two_answerOne: Question_two_answerOne,
        Question_two_answerTwo: Question_two_answerTwo,
        Question_two_answerThree: Question_two_answerThree,
        Question_three_title: Question_three_title,
        Question_three_answer: Question_three_answer,
        Question_four_title: Question_four_title,
        Question_four_answerOne: Question_four_answerOne,
        Question_four_answerTwo: Question_four_answerTwo,
        Question_four_answerThree: Question_four_answerThree,
        Question_four_answerFour: Question_four_answerFour,
        Question_four_answerFive: Question_four_answerFive,
        Question_four_answerSix: Question_four_answerSix,
        Question_four_answerSeven: Question_four_answerSeven,
        Question_five_title: Question_five_title,
        Question_five_answerOne: Question_five_answerOne,
        Question_five_answerTwo: Question_five_answerTwo,
        Question_five_answerThree: Question_five_answerThree,
        Question_six_title: Question_six_title,
        Question_six_answer: Question_six_answer,
        Question_seven_title: Question_seven_title,
        Question_seven_answer: Question_seven_answer,
        Question_eight_title: Question_eight_title,
        Question_eight_answerOne: Question_eight_answerOne,
        Question_eight_answerTwo: Question_eight_answerTwo,
        Question_nine_title: Question_nine_title,
        Question_nine_answer: Question_nine_answer,
        Contact_title: Contact_title,
        Further_questions: Further_questions,
        Follow_socials: Follow_socials,
        Cookies_title: Cookies_title,
        What_are_cookies: What_are_cookies,
        Cookies_section_one: Cookies_section_one,
        Cookies_section_oneLink: Cookies_section_oneLink,
        How_we_use_cookies: How_we_use_cookies,
        Cookies_section_two: Cookies_section_two,
        Disabling_cookies: Disabling_cookies,
        Cookies_section_three: Cookies_section_three,
        Cookies_section_threeLink: Cookies_section_threeLink,
        Cookies_we_set: Cookies_we_set,
        Cookies_section_fourOne: Cookies_section_fourOne,
        Cookies_section_fourTwo: Cookies_section_fourTwo,
        Third_party_cookies: Third_party_cookies,
        Cookies_section_five: Cookies_section_five,
        More_information: More_information,
        Cookies_section_six: Cookies_section_six,
        Privacy_title: Privacy_title,
        Privacy_introOne: Privacy_introOne,
        Privacy_introTwo: Privacy_introTwo,
        Privacy_policy_section: Privacy_policy_section,
        Privacy_section_one: Privacy_section_one,
        What_does_personal: What_does_personal,
        Privacy_section_two: Privacy_section_two,
        What_personal_data: What_personal_data,
        Privacy_section_three: Privacy_section_three,
        Privacy_section_threeOne: Privacy_section_threeOne,
        Privacy_section_threeOne_pointOne: Privacy_section_threeOne_pointOne,
        Privacy_section_threeOne_pointTwo: Privacy_section_threeOne_pointTwo,
        Privacy_section_threeOne_pointThree: Privacy_section_threeOne_pointThree,
        Privacy_section_threeTwo: Privacy_section_threeTwo,
        Privacy_section_threeTwo_content: Privacy_section_threeTwo_content,
        Privacy_section_threeThree: Privacy_section_threeThree,
        Privacy_section_threeThree_pointOne: Privacy_section_threeThree_pointOne,
        Privacy_section_threeThree_pointTwo: Privacy_section_threeThree_pointTwo,
        Privacy_section_threeThree_pointThree: Privacy_section_threeThree_pointThree,
        Privacy_section_threeThree_pointFour: Privacy_section_threeThree_pointFour,
        Privacy_section_threeThree_pointFive: Privacy_section_threeThree_pointFive,
        How_use_personal_data: How_use_personal_data,
        Privacy_section_fourOne: Privacy_section_fourOne,
        Privacy_section_fourTwo: Privacy_section_fourTwo,
        Privacy_section_fourThree: Privacy_section_fourThree,
        With_whom_do: With_whom_do,
        Privacy_section_five: Privacy_section_five,
        Where_do_we_transfer: Where_do_we_transfer,
        Privacy_section_six: Privacy_section_six,
        Automated_decision: Automated_decision,
        Privacy_section_seven: Privacy_section_seven,
        What_rights_do: What_rights_do,
        Privacy_section_eight: Privacy_section_eight,
        Privacy_section_eightOne: Privacy_section_eightOne,
        Privacy_section_eightOne_content: Privacy_section_eightOne_content,
        Privacy_section_eightTwo: Privacy_section_eightTwo,
        Privacy_section_eightTwo_content: Privacy_section_eightTwo_content,
        Privacy_section_eightThree: Privacy_section_eightThree,
        Privacy_section_eightThree_content: Privacy_section_eightThree_content,
        Privacy_section_eightFour: Privacy_section_eightFour,
        Privacy_section_eightFour_content: Privacy_section_eightFour_content,
        Privacy_section_eightFive: Privacy_section_eightFive,
        Privacy_section_eightFive_content: Privacy_section_eightFive_content,
        Exercising_your_rights: Exercising_your_rights,
        Privacy_section_nine: Privacy_section_nine,
        Additional_info: Additional_info,
        Legal_procedures: Legal_procedures,
        Legal_procedures_contentOne: Legal_procedures_contentOne,
        Legal_procedures_contentTwo: Legal_procedures_contentTwo,
        Security_measures: Security_measures,
        Security_measures_contentOne: Security_measures_contentOne,
        Security_measures_contentTwo: Security_measures_contentTwo,
        Security_measures_contentThree: Security_measures_contentThree,
        Definitions_legal_framework: Definitions_legal_framework,
        Personal_data: Personal_data,
        Personal_data_content: Personal_data_content,
        Usage_data: Usage_data,
        Usage_data_content: Usage_data_content,
        User: User,
        User_content: User_content,
        Person_concerned: Person_concerned,
        Person_concerned_content: Person_concerned_content,
        Data_processor: Data_processor,
        Data_processor_content: Data_processor_content,
        Responsible_processing: Responsible_processing,
        Responsible_processing_content: Responsible_processing_content,
        This_application: This_application,
        This_application_content: This_application_content,
        Cookie: Cookie,
        Cookie_content: Cookie_content,
        Legal_information: Legal_information,
        Legal_information_content: Legal_information_content,
        Changes_privacy_policy: Changes_privacy_policy,
        Changes_privacy_policy_date: Changes_privacy_policy_date,
        Changes_privacy_policy_content: Changes_privacy_policy_content,
        Terms_title: Terms_title,
        Terms_introOne: Terms_introOne,
        Terms_introTwo: Terms_introTwo,
        Terms_introThree: Terms_introThree,
        Terms_introFour: Terms_introFour,
        Who_can_contribute: Who_can_contribute,
        Who_can_contribute_contentOne: Who_can_contribute_contentOne,
        Who_can_contribute_contentTwo: Who_can_contribute_contentTwo,
        Limitation_of_liability: Limitation_of_liability,
        Limitation_of_liability_contentOne: Limitation_of_liability_contentOne,
        Limitation_of_liability_contentTwo: Limitation_of_liability_contentTwo,
        Spam: Spam,
        Spam_contentOne: Spam_contentOne,
        Spam_contentTwo: Spam_contentTwo,
        Infringement: Infringement,
        Infringement_contentOne: Infringement_contentOne,
        Infringement_contentTwo: Infringement_contentTwo,
        Breaches_aforementioned_rules: Breaches_aforementioned_rules,
        Breaches_aforementioned_rules_content: Breaches_aforementioned_rules_content,
        Property_rights: Property_rights,
        Property_rights_content: Property_rights_content,
        Thanks_Bigletter: Thanks_Bigletter,
        Thanks_Fitbit_title: Thanks_Fitbit_title,
        Thanks_Content1: Thanks_Content1,
        Thanks_Content2: Thanks_Content2,
        'default': nl
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
